{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.array.unshift.js\");\n/* interact.js 1.10.17 | https://interactjs.io/license */\n!function (t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : (\"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : this).interact = t();\n}(function () {\n  var t = {};\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), t.default = void 0, t.default = function (t) {\n    return !(!t || !t.Window) && t instanceof t.Window;\n  };\n  var e = {};\n  Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  }), e.getWindow = function (e) {\n    return (0, t.default)(e) ? e : (e.ownerDocument || e).defaultView || r.window;\n  }, e.init = o, e.window = e.realWindow = void 0;\n  var n = void 0;\n  e.realWindow = n;\n  var r = void 0;\n  function o(t) {\n    e.realWindow = n = t;\n    var o = t.document.createTextNode(\"\");\n    o.ownerDocument !== t.document && \"function\" == typeof t.wrap && t.wrap(o) === o && (t = t.wrap(t)), e.window = r = t;\n  }\n  e.window = r, \"undefined\" != typeof window && window && o(window);\n  var i = {};\n  function a(t) {\n    return a = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    }, a(t);\n  }\n  Object.defineProperty(i, \"__esModule\", {\n    value: !0\n  }), i.default = void 0;\n  var s = function (t) {\n      return !!t && \"object\" === a(t);\n    },\n    l = function (t) {\n      return \"function\" == typeof t;\n    },\n    u = {\n      window: function (n) {\n        return n === e.window || (0, t.default)(n);\n      },\n      docFrag: function (t) {\n        return s(t) && 11 === t.nodeType;\n      },\n      object: s,\n      func: l,\n      number: function (t) {\n        return \"number\" == typeof t;\n      },\n      bool: function (t) {\n        return \"boolean\" == typeof t;\n      },\n      string: function (t) {\n        return \"string\" == typeof t;\n      },\n      element: function (t) {\n        if (!t || \"object\" !== a(t)) return !1;\n        var n = e.getWindow(t) || e.window;\n        return /object|function/.test(\"undefined\" == typeof Element ? \"undefined\" : a(Element)) ? t instanceof Element || t instanceof n.Element : 1 === t.nodeType && \"string\" == typeof t.nodeName;\n      },\n      plainObject: function (t) {\n        return s(t) && !!t.constructor && /function Object\\b/.test(t.constructor.toString());\n      },\n      array: function (t) {\n        return s(t) && void 0 !== t.length && l(t.splice);\n      }\n    };\n  i.default = u;\n  var c = {};\n  function f(t) {\n    var e = t.interaction;\n    if (\"drag\" === e.prepared.name) {\n      var n = e.prepared.axis;\n      \"x\" === n ? (e.coords.cur.page.y = e.coords.start.page.y, e.coords.cur.client.y = e.coords.start.client.y, e.coords.velocity.client.y = 0, e.coords.velocity.page.y = 0) : \"y\" === n && (e.coords.cur.page.x = e.coords.start.page.x, e.coords.cur.client.x = e.coords.start.client.x, e.coords.velocity.client.x = 0, e.coords.velocity.page.x = 0);\n    }\n  }\n  function d(t) {\n    var e = t.iEvent,\n      n = t.interaction;\n    if (\"drag\" === n.prepared.name) {\n      var r = n.prepared.axis;\n      if (\"x\" === r || \"y\" === r) {\n        var o = \"x\" === r ? \"y\" : \"x\";\n        e.page[o] = n.coords.start.page[o], e.client[o] = n.coords.start.client[o], e.delta[o] = 0;\n      }\n    }\n  }\n  Object.defineProperty(c, \"__esModule\", {\n    value: !0\n  }), c.default = void 0;\n  var p = {\n      id: \"actions/drag\",\n      install: function (t) {\n        var e = t.actions,\n          n = t.Interactable,\n          r = t.defaults;\n        n.prototype.draggable = p.draggable, e.map.drag = p, e.methodDict.drag = \"draggable\", r.actions.drag = p.defaults;\n      },\n      listeners: {\n        \"interactions:before-action-move\": f,\n        \"interactions:action-resume\": f,\n        \"interactions:action-move\": d,\n        \"auto-start:check\": function (t) {\n          var e = t.interaction,\n            n = t.interactable,\n            r = t.buttons,\n            o = n.options.drag;\n          if (o && o.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (r & n.options.drag.mouseButtons))) return t.action = {\n            name: \"drag\",\n            axis: \"start\" === o.lockAxis ? o.startAxis : o.lockAxis\n          }, !1;\n        }\n      },\n      draggable: function (t) {\n        return i.default.object(t) ? (this.options.drag.enabled = !1 !== t.enabled, this.setPerAction(\"drag\", t), this.setOnEvents(\"drag\", t), /^(xy|x|y|start)$/.test(t.lockAxis) && (this.options.drag.lockAxis = t.lockAxis), /^(xy|x|y)$/.test(t.startAxis) && (this.options.drag.startAxis = t.startAxis), this) : i.default.bool(t) ? (this.options.drag.enabled = t, this) : this.options.drag;\n      },\n      beforeMove: f,\n      move: d,\n      defaults: {\n        startAxis: \"xy\",\n        lockAxis: \"xy\"\n      },\n      getCursor: function () {\n        return \"move\";\n      }\n    },\n    v = p;\n  c.default = v;\n  var h = {};\n  Object.defineProperty(h, \"__esModule\", {\n    value: !0\n  }), h.default = void 0;\n  var g = {\n    init: function (t) {\n      var e = t;\n      g.document = e.document, g.DocumentFragment = e.DocumentFragment || y, g.SVGElement = e.SVGElement || y, g.SVGSVGElement = e.SVGSVGElement || y, g.SVGElementInstance = e.SVGElementInstance || y, g.Element = e.Element || y, g.HTMLElement = e.HTMLElement || g.Element, g.Event = e.Event, g.Touch = e.Touch || y, g.PointerEvent = e.PointerEvent || e.MSPointerEvent;\n    },\n    document: null,\n    DocumentFragment: null,\n    SVGElement: null,\n    SVGSVGElement: null,\n    SVGElementInstance: null,\n    Element: null,\n    HTMLElement: null,\n    Event: null,\n    Touch: null,\n    PointerEvent: null\n  };\n  function y() {}\n  var m = g;\n  h.default = m;\n  var b = {};\n  Object.defineProperty(b, \"__esModule\", {\n    value: !0\n  }), b.default = void 0;\n  var x = {\n      init: function (t) {\n        var e = h.default.Element,\n          n = t.navigator || {};\n        x.supportsTouch = \"ontouchstart\" in t || i.default.func(t.DocumentTouch) && h.default.document instanceof t.DocumentTouch, x.supportsPointerEvent = !1 !== n.pointerEnabled && !!h.default.PointerEvent, x.isIOS = /iP(hone|od|ad)/.test(n.platform), x.isIOS7 = /iP(hone|od|ad)/.test(n.platform) && /OS 7[^\\d]/.test(n.appVersion), x.isIe9 = /MSIE 9/.test(n.userAgent), x.isOperaMobile = \"Opera\" === n.appName && x.supportsTouch && /Presto/.test(n.userAgent), x.prefixedMatchesSelector = \"matches\" in e.prototype ? \"matches\" : \"webkitMatchesSelector\" in e.prototype ? \"webkitMatchesSelector\" : \"mozMatchesSelector\" in e.prototype ? \"mozMatchesSelector\" : \"oMatchesSelector\" in e.prototype ? \"oMatchesSelector\" : \"msMatchesSelector\", x.pEventTypes = x.supportsPointerEvent ? h.default.PointerEvent === t.MSPointerEvent ? {\n          up: \"MSPointerUp\",\n          down: \"MSPointerDown\",\n          over: \"mouseover\",\n          out: \"mouseout\",\n          move: \"MSPointerMove\",\n          cancel: \"MSPointerCancel\"\n        } : {\n          up: \"pointerup\",\n          down: \"pointerdown\",\n          over: \"pointerover\",\n          out: \"pointerout\",\n          move: \"pointermove\",\n          cancel: \"pointercancel\"\n        } : null, x.wheelEvent = h.default.document && \"onmousewheel\" in h.default.document ? \"mousewheel\" : \"wheel\";\n      },\n      supportsTouch: null,\n      supportsPointerEvent: null,\n      isIOS7: null,\n      isIOS: null,\n      isIe9: null,\n      isOperaMobile: null,\n      prefixedMatchesSelector: null,\n      pEventTypes: null,\n      wheelEvent: null\n    },\n    w = x;\n  b.default = w;\n  var _ = {};\n  function P(t) {\n    var e = t.parentNode;\n    if (i.default.docFrag(e)) {\n      for (; (e = e.host) && i.default.docFrag(e););\n      return e;\n    }\n    return e;\n  }\n  function O(t, n) {\n    return e.window !== e.realWindow && (n = n.replace(/\\/deep\\//g, \" \")), t[b.default.prefixedMatchesSelector](n);\n  }\n  Object.defineProperty(_, \"__esModule\", {\n    value: !0\n  }), _.closest = function (t, e) {\n    for (; i.default.element(t);) {\n      if (O(t, e)) return t;\n      t = P(t);\n    }\n    return null;\n  }, _.getActualElement = function (t) {\n    return t.correspondingUseElement || t;\n  }, _.getElementClientRect = j, _.getElementRect = function (t) {\n    var n = j(t);\n    if (!b.default.isIOS7 && n) {\n      var r = T(e.getWindow(t));\n      n.left += r.x, n.right += r.x, n.top += r.y, n.bottom += r.y;\n    }\n    return n;\n  }, _.getPath = function (t) {\n    for (var e = []; t;) e.push(t), t = P(t);\n    return e;\n  }, _.getScrollXY = T, _.indexOfDeepestElement = function (t) {\n    for (var n, r = [], o = 0; o < t.length; o++) {\n      var i = t[o],\n        a = t[n];\n      if (i && o !== n) if (a) {\n        var s = E(i),\n          l = E(a);\n        if (s !== i.ownerDocument) if (l !== i.ownerDocument) {\n          if (s !== l) {\n            r = r.length ? r : S(a);\n            var u = void 0;\n            if (a instanceof h.default.HTMLElement && i instanceof h.default.SVGElement && !(i instanceof h.default.SVGSVGElement)) {\n              if (i === l) continue;\n              u = i.ownerSVGElement;\n            } else u = i;\n            for (var c = S(u, a.ownerDocument), f = 0; c[f] && c[f] === r[f];) f++;\n            var d = [c[f - 1], c[f], r[f]];\n            if (d[0]) for (var p = d[0].lastChild; p;) {\n              if (p === d[1]) {\n                n = o, r = c;\n                break;\n              }\n              if (p === d[2]) break;\n              p = p.previousSibling;\n            }\n          } else v = i, g = a, void 0, void 0, (parseInt(e.getWindow(v).getComputedStyle(v).zIndex, 10) || 0) >= (parseInt(e.getWindow(g).getComputedStyle(g).zIndex, 10) || 0) && (n = o);\n        } else n = o;\n      } else n = o;\n    }\n    var v, g;\n    return n;\n  }, _.matchesSelector = O, _.matchesUpTo = function (t, e, n) {\n    for (; i.default.element(t);) {\n      if (O(t, e)) return !0;\n      if ((t = P(t)) === n) return O(t, e);\n    }\n    return !1;\n  }, _.nodeContains = function (t, e) {\n    if (t.contains) return t.contains(e);\n    for (; e;) {\n      if (e === t) return !0;\n      e = e.parentNode;\n    }\n    return !1;\n  }, _.parentNode = P, _.trySelector = function (t) {\n    return !!i.default.string(t) && (h.default.document.querySelector(t), !0);\n  };\n  var E = function (t) {\n    return t.parentNode || t.host;\n  };\n  function S(t, e) {\n    for (var n, r = [], o = t; (n = E(o)) && o !== e && n !== o.ownerDocument;) r.unshift(o), o = n;\n    return r;\n  }\n  function T(t) {\n    return {\n      x: (t = t || e.window).scrollX || t.document.documentElement.scrollLeft,\n      y: t.scrollY || t.document.documentElement.scrollTop\n    };\n  }\n  function j(t) {\n    var e = t instanceof h.default.SVGElement ? t.getBoundingClientRect() : t.getClientRects()[0];\n    return e && {\n      left: e.left,\n      right: e.right,\n      top: e.top,\n      bottom: e.bottom,\n      width: e.width || e.right - e.left,\n      height: e.height || e.bottom - e.top\n    };\n  }\n  var M = {};\n  Object.defineProperty(M, \"__esModule\", {\n    value: !0\n  }), M.default = function (t, e) {\n    for (var n in e) t[n] = e[n];\n    return t;\n  };\n  var k = {};\n  function I(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n    return r;\n  }\n  function D(t, e, n) {\n    return \"parent\" === t ? (0, _.parentNode)(n) : \"self\" === t ? e.getRect(n) : (0, _.closest)(n, t);\n  }\n  Object.defineProperty(k, \"__esModule\", {\n    value: !0\n  }), k.addEdges = function (t, e, n) {\n    t.left && (e.left += n.x), t.right && (e.right += n.x), t.top && (e.top += n.y), t.bottom && (e.bottom += n.y), e.width = e.right - e.left, e.height = e.bottom - e.top;\n  }, k.getStringOptionResult = D, k.rectToXY = function (t) {\n    return t && {\n      x: \"x\" in t ? t.x : t.left,\n      y: \"y\" in t ? t.y : t.top\n    };\n  }, k.resolveRectLike = function (t, e, n, r) {\n    var o,\n      a = t;\n    return i.default.string(a) ? a = D(a, e, n) : i.default.func(a) && (a = a.apply(void 0, function (t) {\n      if (Array.isArray(t)) return I(t);\n    }(o = r) || function (t) {\n      if (\"undefined\" != typeof Symbol && null != t[Symbol.iterator] || null != t[\"@@iterator\"]) return Array.from(t);\n    }(o) || function (t, e) {\n      if (t) {\n        if (\"string\" == typeof t) return I(t, e);\n        var n = Object.prototype.toString.call(t).slice(8, -1);\n        return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(t) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? I(t, e) : void 0;\n      }\n    }(o) || function () {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }())), i.default.element(a) && (a = (0, _.getElementRect)(a)), a;\n  }, k.tlbrToXywh = function (t) {\n    return !t || \"x\" in t && \"y\" in t || ((t = (0, M.default)({}, t)).x = t.left || 0, t.y = t.top || 0, t.width = t.width || (t.right || 0) - t.x, t.height = t.height || (t.bottom || 0) - t.y), t;\n  }, k.xywhToTlbr = function (t) {\n    return !t || \"left\" in t && \"top\" in t || ((t = (0, M.default)({}, t)).left = t.x || 0, t.top = t.y || 0, t.right = t.right || t.left + t.width, t.bottom = t.bottom || t.top + t.height), t;\n  };\n  var A = {};\n  Object.defineProperty(A, \"__esModule\", {\n    value: !0\n  }), A.default = function (t, e, n) {\n    var r = t.options[n],\n      o = r && r.origin || t.options.origin,\n      i = (0, k.resolveRectLike)(o, t, e, [t && e]);\n    return (0, k.rectToXY)(i) || {\n      x: 0,\n      y: 0\n    };\n  };\n  var z = {};\n  function C(t) {\n    return t.trim().split(/ +/);\n  }\n  Object.defineProperty(z, \"__esModule\", {\n    value: !0\n  }), z.default = function t(e, n, r) {\n    if (r = r || {}, i.default.string(e) && -1 !== e.search(\" \") && (e = C(e)), i.default.array(e)) return e.reduce(function (e, o) {\n      return (0, M.default)(e, t(o, n, r));\n    }, r);\n    if (i.default.object(e) && (n = e, e = \"\"), i.default.func(n)) r[e] = r[e] || [], r[e].push(n);else if (i.default.array(n)) for (var o = 0; o < n.length; o++) {\n      var a;\n      a = n[o], t(e, a, r);\n    } else if (i.default.object(n)) for (var s in n) {\n      var l = C(s).map(function (t) {\n        return \"\".concat(e).concat(t);\n      });\n      t(l, n[s], r);\n    }\n    return r;\n  };\n  var R = {};\n  Object.defineProperty(R, \"__esModule\", {\n    value: !0\n  }), R.default = void 0, R.default = function (t, e) {\n    return Math.sqrt(t * t + e * e);\n  };\n  var F = {};\n  Object.defineProperty(F, \"__esModule\", {\n    value: !0\n  }), F.default = function (t, e) {\n    t.__set || (t.__set = {});\n    var n = function (n) {\n      \"function\" != typeof t[n] && \"__set\" !== n && Object.defineProperty(t, n, {\n        get: function () {\n          return n in t.__set ? t.__set[n] : t.__set[n] = e[n];\n        },\n        set: function (e) {\n          t.__set[n] = e;\n        },\n        configurable: !0\n      });\n    };\n    for (var r in e) n(r);\n    return t;\n  };\n  var X = {};\n  function B(t) {\n    return t instanceof h.default.Event || t instanceof h.default.Touch;\n  }\n  function Y(t, e, n) {\n    return t = t || \"page\", (n = n || {}).x = e[t + \"X\"], n.y = e[t + \"Y\"], n;\n  }\n  function W(t, e) {\n    return e = e || {\n      x: 0,\n      y: 0\n    }, b.default.isOperaMobile && B(t) ? (Y(\"screen\", t, e), e.x += window.scrollX, e.y += window.scrollY) : Y(\"page\", t, e), e;\n  }\n  function L(t, e) {\n    return e = e || {}, b.default.isOperaMobile && B(t) ? Y(\"screen\", t, e) : Y(\"client\", t, e), e;\n  }\n  function U(t) {\n    var e = [];\n    return i.default.array(t) ? (e[0] = t[0], e[1] = t[1]) : \"touchend\" === t.type ? 1 === t.touches.length ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : 0 === t.touches.length && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e;\n  }\n  function V(t) {\n    for (var e = {\n        pageX: 0,\n        pageY: 0,\n        clientX: 0,\n        clientY: 0,\n        screenX: 0,\n        screenY: 0\n      }, n = 0; n < t.length; n++) {\n      var r = t[n];\n      for (var o in e) e[o] += r[o];\n    }\n    for (var i in e) e[i] /= t.length;\n    return e;\n  }\n  Object.defineProperty(X, \"__esModule\", {\n    value: !0\n  }), X.coordsToEvent = function (t) {\n    return {\n      coords: t,\n      get page() {\n        return this.coords.page;\n      },\n      get client() {\n        return this.coords.client;\n      },\n      get timeStamp() {\n        return this.coords.timeStamp;\n      },\n      get pageX() {\n        return this.coords.page.x;\n      },\n      get pageY() {\n        return this.coords.page.y;\n      },\n      get clientX() {\n        return this.coords.client.x;\n      },\n      get clientY() {\n        return this.coords.client.y;\n      },\n      get pointerId() {\n        return this.coords.pointerId;\n      },\n      get target() {\n        return this.coords.target;\n      },\n      get type() {\n        return this.coords.type;\n      },\n      get pointerType() {\n        return this.coords.pointerType;\n      },\n      get buttons() {\n        return this.coords.buttons;\n      },\n      preventDefault: function () {}\n    };\n  }, X.copyCoords = function (t, e) {\n    t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp;\n  }, X.getClientXY = L, X.getEventTargets = function (t) {\n    var e = i.default.func(t.composedPath) ? t.composedPath() : t.path;\n    return [_.getActualElement(e ? e[0] : t.target), _.getActualElement(t.currentTarget)];\n  }, X.getPageXY = W, X.getPointerId = function (t) {\n    return i.default.number(t.pointerId) ? t.pointerId : t.identifier;\n  }, X.getPointerType = function (t) {\n    return i.default.string(t.pointerType) ? t.pointerType : i.default.number(t.pointerType) ? [void 0, void 0, \"touch\", \"pen\", \"mouse\"][t.pointerType] : /touch/.test(t.type || \"\") || t instanceof h.default.Touch ? \"touch\" : \"mouse\";\n  }, X.getTouchPair = U, X.getXY = Y, X.isNativePointer = B, X.newCoords = function () {\n    return {\n      page: {\n        x: 0,\n        y: 0\n      },\n      client: {\n        x: 0,\n        y: 0\n      },\n      timeStamp: 0\n    };\n  }, X.pointerAverage = V, Object.defineProperty(X, \"pointerExtend\", {\n    enumerable: !0,\n    get: function () {\n      return F.default;\n    }\n  }), X.setCoordDeltas = function (t, e, n) {\n    t.page.x = n.page.x - e.page.x, t.page.y = n.page.y - e.page.y, t.client.x = n.client.x - e.client.x, t.client.y = n.client.y - e.client.y, t.timeStamp = n.timeStamp - e.timeStamp;\n  }, X.setCoordVelocity = function (t, e) {\n    var n = Math.max(e.timeStamp / 1e3, .001);\n    t.page.x = e.page.x / n, t.page.y = e.page.y / n, t.client.x = e.client.x / n, t.client.y = e.client.y / n, t.timeStamp = n;\n  }, X.setCoords = function (t, e, n) {\n    var r = e.length > 1 ? V(e) : e[0];\n    W(r, t.page), L(r, t.client), t.timeStamp = n;\n  }, X.setZeroCoords = function (t) {\n    t.page.x = 0, t.page.y = 0, t.client.x = 0, t.client.y = 0;\n  }, X.touchAngle = function (t, e) {\n    var n = e + \"X\",\n      r = e + \"Y\",\n      o = U(t),\n      i = o[1][n] - o[0][n],\n      a = o[1][r] - o[0][r];\n    return 180 * Math.atan2(a, i) / Math.PI;\n  }, X.touchBBox = function (t) {\n    if (!t.length) return null;\n    var e = U(t),\n      n = Math.min(e[0].pageX, e[1].pageX),\n      r = Math.min(e[0].pageY, e[1].pageY),\n      o = Math.max(e[0].pageX, e[1].pageX),\n      i = Math.max(e[0].pageY, e[1].pageY);\n    return {\n      x: n,\n      y: r,\n      left: n,\n      top: r,\n      right: o,\n      bottom: i,\n      width: o - n,\n      height: i - r\n    };\n  }, X.touchDistance = function (t, e) {\n    var n = e + \"X\",\n      r = e + \"Y\",\n      o = U(t),\n      i = o[0][n] - o[1][n],\n      a = o[0][r] - o[1][r];\n    return (0, R.default)(i, a);\n  };\n  var N = {};\n  function q(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function G(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(N, \"__esModule\", {\n    value: !0\n  }), N.BaseEvent = void 0;\n  var $ = function () {\n    function t(e) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), G(this, \"immediatePropagationStopped\", !1), G(this, \"propagationStopped\", !1), this._interaction = e;\n    }\n    var e, n;\n    return e = t, (n = [{\n      key: \"preventDefault\",\n      value: function () {}\n    }, {\n      key: \"stopPropagation\",\n      value: function () {\n        this.propagationStopped = !0;\n      }\n    }, {\n      key: \"stopImmediatePropagation\",\n      value: function () {\n        this.immediatePropagationStopped = this.propagationStopped = !0;\n      }\n    }]) && q(e.prototype, n), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), t;\n  }();\n  N.BaseEvent = $, Object.defineProperty($.prototype, \"interaction\", {\n    get: function () {\n      return this._interaction._proxy;\n    },\n    set: function () {}\n  });\n  var H = {};\n  Object.defineProperty(H, \"__esModule\", {\n    value: !0\n  }), H.remove = H.merge = H.from = H.findIndex = H.find = H.contains = void 0, H.contains = function (t, e) {\n    return -1 !== t.indexOf(e);\n  }, H.remove = function (t, e) {\n    return t.splice(t.indexOf(e), 1);\n  };\n  var K = function (t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      t.push(r);\n    }\n    return t;\n  };\n  H.merge = K, H.from = function (t) {\n    return K([], t);\n  };\n  var Z = function (t, e) {\n    for (var n = 0; n < t.length; n++) if (e(t[n], n, t)) return n;\n    return -1;\n  };\n  H.findIndex = Z, H.find = function (t, e) {\n    return t[Z(t, e)];\n  };\n  var J = {};\n  function Q(t) {\n    return Q = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    }, Q(t);\n  }\n  function tt(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function et(t, e) {\n    return et = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, et(t, e);\n  }\n  function nt(t, e) {\n    if (e && (\"object\" === Q(e) || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return rt(t);\n  }\n  function rt(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n  function ot(t) {\n    return ot = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, ot(t);\n  }\n  function it(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(J, \"__esModule\", {\n    value: !0\n  }), J.DropEvent = void 0;\n  var at = function (t) {\n    !function (t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          writable: !0,\n          configurable: !0\n        }\n      }), Object.defineProperty(t, \"prototype\", {\n        writable: !1\n      }), e && et(t, e);\n    }(a, t);\n    var e,\n      n,\n      r,\n      o,\n      i = (r = a, o = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n        } catch (t) {\n          return !1;\n        }\n      }(), function () {\n        var t,\n          e = ot(r);\n        if (o) {\n          var n = ot(this).constructor;\n          t = Reflect.construct(e, arguments, n);\n        } else t = e.apply(this, arguments);\n        return nt(this, t);\n      });\n    function a(t, e, n) {\n      var r;\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, a), it(rt(r = i.call(this, e._interaction)), \"dropzone\", void 0), it(rt(r), \"dragEvent\", void 0), it(rt(r), \"relatedTarget\", void 0), it(rt(r), \"draggable\", void 0), it(rt(r), \"propagationStopped\", !1), it(rt(r), \"immediatePropagationStopped\", !1);\n      var o = \"dragleave\" === n ? t.prev : t.cur,\n        s = o.element,\n        l = o.dropzone;\n      return r.type = n, r.target = s, r.currentTarget = s, r.dropzone = l, r.dragEvent = e, r.relatedTarget = e.target, r.draggable = e.interactable, r.timeStamp = e.timeStamp, r;\n    }\n    return e = a, (n = [{\n      key: \"reject\",\n      value: function () {\n        var t = this,\n          e = this._interaction.dropState;\n        if (\"dropactivate\" === this.type || this.dropzone && e.cur.dropzone === this.dropzone && e.cur.element === this.target) if (e.prev.dropzone = this.dropzone, e.prev.element = this.target, e.rejected = !0, e.events.enter = null, this.stopImmediatePropagation(), \"dropactivate\" === this.type) {\n          var n = e.activeDrops,\n            r = H.findIndex(n, function (e) {\n              var n = e.dropzone,\n                r = e.element;\n              return n === t.dropzone && r === t.target;\n            });\n          e.activeDrops.splice(r, 1);\n          var o = new a(e, this.dragEvent, \"dropdeactivate\");\n          o.dropzone = this.dropzone, o.target = this.target, this.dropzone.fire(o);\n        } else this.dropzone.fire(new a(e, this.dragEvent, \"dragleave\"));\n      }\n    }, {\n      key: \"preventDefault\",\n      value: function () {}\n    }, {\n      key: \"stopPropagation\",\n      value: function () {\n        this.propagationStopped = !0;\n      }\n    }, {\n      key: \"stopImmediatePropagation\",\n      value: function () {\n        this.immediatePropagationStopped = this.propagationStopped = !0;\n      }\n    }]) && tt(e.prototype, n), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), a;\n  }(N.BaseEvent);\n  J.DropEvent = at;\n  var st = {};\n  function lt(t, e) {\n    for (var n = 0; n < t.slice().length; n++) {\n      var r = t.slice()[n],\n        o = r.dropzone,\n        i = r.element;\n      e.dropzone = o, e.target = i, o.fire(e), e.propagationStopped = e.immediatePropagationStopped = !1;\n    }\n  }\n  function ut(t, e) {\n    for (var n = function (t, e) {\n        for (var n = t.interactables, r = [], o = 0; o < n.list.length; o++) {\n          var a = n.list[o];\n          if (a.options.drop.enabled) {\n            var s = a.options.drop.accept;\n            if (!(i.default.element(s) && s !== e || i.default.string(s) && !_.matchesSelector(e, s) || i.default.func(s) && !s({\n              dropzone: a,\n              draggableElement: e\n            }))) for (var l = i.default.string(a.target) ? a._context.querySelectorAll(a.target) : i.default.array(a.target) ? a.target : [a.target], u = 0; u < l.length; u++) {\n              var c = l[u];\n              c !== e && r.push({\n                dropzone: a,\n                element: c,\n                rect: a.getRect(c)\n              });\n            }\n          }\n        }\n        return r;\n      }(t, e), r = 0; r < n.length; r++) {\n      var o = n[r];\n      o.rect = o.dropzone.getRect(o.element);\n    }\n    return n;\n  }\n  function ct(t, e, n) {\n    for (var r = t.dropState, o = t.interactable, i = t.element, a = [], s = 0; s < r.activeDrops.length; s++) {\n      var l = r.activeDrops[s],\n        u = l.dropzone,\n        c = l.element,\n        f = l.rect;\n      a.push(u.dropCheck(e, n, o, i, c, f) ? c : null);\n    }\n    var d = _.indexOfDeepestElement(a);\n    return r.activeDrops[d] || null;\n  }\n  function ft(t, e, n) {\n    var r = t.dropState,\n      o = {\n        enter: null,\n        leave: null,\n        activate: null,\n        deactivate: null,\n        move: null,\n        drop: null\n      };\n    return \"dragstart\" === n.type && (o.activate = new J.DropEvent(r, n, \"dropactivate\"), o.activate.target = null, o.activate.dropzone = null), \"dragend\" === n.type && (o.deactivate = new J.DropEvent(r, n, \"dropdeactivate\"), o.deactivate.target = null, o.deactivate.dropzone = null), r.rejected || (r.cur.element !== r.prev.element && (r.prev.dropzone && (o.leave = new J.DropEvent(r, n, \"dragleave\"), n.dragLeave = o.leave.target = r.prev.element, n.prevDropzone = o.leave.dropzone = r.prev.dropzone), r.cur.dropzone && (o.enter = new J.DropEvent(r, n, \"dragenter\"), n.dragEnter = r.cur.element, n.dropzone = r.cur.dropzone)), \"dragend\" === n.type && r.cur.dropzone && (o.drop = new J.DropEvent(r, n, \"drop\"), n.dropzone = r.cur.dropzone, n.relatedTarget = r.cur.element), \"dragmove\" === n.type && r.cur.dropzone && (o.move = new J.DropEvent(r, n, \"dropmove\"), o.move.dragmove = n, n.dropzone = r.cur.dropzone)), o;\n  }\n  function dt(t, e) {\n    var n = t.dropState,\n      r = n.activeDrops,\n      o = n.cur,\n      i = n.prev;\n    e.leave && i.dropzone.fire(e.leave), e.enter && o.dropzone.fire(e.enter), e.move && o.dropzone.fire(e.move), e.drop && o.dropzone.fire(e.drop), e.deactivate && lt(r, e.deactivate), n.prev.dropzone = o.dropzone, n.prev.element = o.element;\n  }\n  function pt(t, e) {\n    var n = t.interaction,\n      r = t.iEvent,\n      o = t.event;\n    if (\"dragmove\" === r.type || \"dragend\" === r.type) {\n      var i = n.dropState;\n      e.dynamicDrop && (i.activeDrops = ut(e, n.element));\n      var a = r,\n        s = ct(n, a, o);\n      i.rejected = i.rejected && !!s && s.dropzone === i.cur.dropzone && s.element === i.cur.element, i.cur.dropzone = s && s.dropzone, i.cur.element = s && s.element, i.events = ft(n, 0, a);\n    }\n  }\n  Object.defineProperty(st, \"__esModule\", {\n    value: !0\n  }), st.default = void 0;\n  var vt = {\n      id: \"actions/drop\",\n      install: function (t) {\n        var e = t.actions,\n          n = t.interactStatic,\n          r = t.Interactable,\n          o = t.defaults;\n        t.usePlugin(c.default), r.prototype.dropzone = function (t) {\n          return function (t, e) {\n            if (i.default.object(e)) {\n              if (t.options.drop.enabled = !1 !== e.enabled, e.listeners) {\n                var n = (0, z.default)(e.listeners),\n                  r = Object.keys(n).reduce(function (t, e) {\n                    return t[/^(enter|leave)/.test(e) ? \"drag\".concat(e) : /^(activate|deactivate|move)/.test(e) ? \"drop\".concat(e) : e] = n[e], t;\n                  }, {});\n                t.off(t.options.drop.listeners), t.on(r), t.options.drop.listeners = r;\n              }\n              return i.default.func(e.ondrop) && t.on(\"drop\", e.ondrop), i.default.func(e.ondropactivate) && t.on(\"dropactivate\", e.ondropactivate), i.default.func(e.ondropdeactivate) && t.on(\"dropdeactivate\", e.ondropdeactivate), i.default.func(e.ondragenter) && t.on(\"dragenter\", e.ondragenter), i.default.func(e.ondragleave) && t.on(\"dragleave\", e.ondragleave), i.default.func(e.ondropmove) && t.on(\"dropmove\", e.ondropmove), /^(pointer|center)$/.test(e.overlap) ? t.options.drop.overlap = e.overlap : i.default.number(e.overlap) && (t.options.drop.overlap = Math.max(Math.min(1, e.overlap), 0)), \"accept\" in e && (t.options.drop.accept = e.accept), \"checker\" in e && (t.options.drop.checker = e.checker), t;\n            }\n            return i.default.bool(e) ? (t.options.drop.enabled = e, t) : t.options.drop;\n          }(this, t);\n        }, r.prototype.dropCheck = function (t, e, n, r, o, a) {\n          return function (t, e, n, r, o, a, s) {\n            var l = !1;\n            if (!(s = s || t.getRect(a))) return !!t.options.drop.checker && t.options.drop.checker(e, n, l, t, a, r, o);\n            var u = t.options.drop.overlap;\n            if (\"pointer\" === u) {\n              var c = (0, A.default)(r, o, \"drag\"),\n                f = X.getPageXY(e);\n              f.x += c.x, f.y += c.y;\n              var d = f.x > s.left && f.x < s.right,\n                p = f.y > s.top && f.y < s.bottom;\n              l = d && p;\n            }\n            var v = r.getRect(o);\n            if (v && \"center\" === u) {\n              var h = v.left + v.width / 2,\n                g = v.top + v.height / 2;\n              l = h >= s.left && h <= s.right && g >= s.top && g <= s.bottom;\n            }\n            return v && i.default.number(u) && (l = Math.max(0, Math.min(s.right, v.right) - Math.max(s.left, v.left)) * Math.max(0, Math.min(s.bottom, v.bottom) - Math.max(s.top, v.top)) / (v.width * v.height) >= u), t.options.drop.checker && (l = t.options.drop.checker(e, n, l, t, a, r, o)), l;\n          }(this, t, e, n, r, o, a);\n        }, n.dynamicDrop = function (e) {\n          return i.default.bool(e) ? (t.dynamicDrop = e, n) : t.dynamicDrop;\n        }, (0, M.default)(e.phaselessTypes, {\n          dragenter: !0,\n          dragleave: !0,\n          dropactivate: !0,\n          dropdeactivate: !0,\n          dropmove: !0,\n          drop: !0\n        }), e.methodDict.drop = \"dropzone\", t.dynamicDrop = !1, o.actions.drop = vt.defaults;\n      },\n      listeners: {\n        \"interactions:before-action-start\": function (t) {\n          var e = t.interaction;\n          \"drag\" === e.prepared.name && (e.dropState = {\n            cur: {\n              dropzone: null,\n              element: null\n            },\n            prev: {\n              dropzone: null,\n              element: null\n            },\n            rejected: null,\n            events: null,\n            activeDrops: []\n          });\n        },\n        \"interactions:after-action-start\": function (t, e) {\n          var n = t.interaction,\n            r = (t.event, t.iEvent);\n          if (\"drag\" === n.prepared.name) {\n            var o = n.dropState;\n            o.activeDrops = null, o.events = null, o.activeDrops = ut(e, n.element), o.events = ft(n, 0, r), o.events.activate && (lt(o.activeDrops, o.events.activate), e.fire(\"actions/drop:start\", {\n              interaction: n,\n              dragEvent: r\n            }));\n          }\n        },\n        \"interactions:action-move\": pt,\n        \"interactions:after-action-move\": function (t, e) {\n          var n = t.interaction,\n            r = t.iEvent;\n          \"drag\" === n.prepared.name && (dt(n, n.dropState.events), e.fire(\"actions/drop:move\", {\n            interaction: n,\n            dragEvent: r\n          }), n.dropState.events = {});\n        },\n        \"interactions:action-end\": function (t, e) {\n          if (\"drag\" === t.interaction.prepared.name) {\n            var n = t.interaction,\n              r = t.iEvent;\n            pt(t, e), dt(n, n.dropState.events), e.fire(\"actions/drop:end\", {\n              interaction: n,\n              dragEvent: r\n            });\n          }\n        },\n        \"interactions:stop\": function (t) {\n          var e = t.interaction;\n          if (\"drag\" === e.prepared.name) {\n            var n = e.dropState;\n            n && (n.activeDrops = null, n.events = null, n.cur.dropzone = null, n.cur.element = null, n.prev.dropzone = null, n.prev.element = null, n.rejected = !1);\n          }\n        }\n      },\n      getActiveDrops: ut,\n      getDrop: ct,\n      getDropEvents: ft,\n      fireDropEvents: dt,\n      defaults: {\n        enabled: !1,\n        accept: null,\n        overlap: \"pointer\"\n      }\n    },\n    ht = vt;\n  st.default = ht;\n  var gt = {};\n  function yt(t) {\n    var e = t.interaction,\n      n = t.iEvent,\n      r = t.phase;\n    if (\"gesture\" === e.prepared.name) {\n      var o = e.pointers.map(function (t) {\n          return t.pointer;\n        }),\n        a = \"start\" === r,\n        s = \"end\" === r,\n        l = e.interactable.options.deltaSource;\n      if (n.touches = [o[0], o[1]], a) n.distance = X.touchDistance(o, l), n.box = X.touchBBox(o), n.scale = 1, n.ds = 0, n.angle = X.touchAngle(o, l), n.da = 0, e.gesture.startDistance = n.distance, e.gesture.startAngle = n.angle;else if (s) {\n        var u = e.prevEvent;\n        n.distance = u.distance, n.box = u.box, n.scale = u.scale, n.ds = 0, n.angle = u.angle, n.da = 0;\n      } else n.distance = X.touchDistance(o, l), n.box = X.touchBBox(o), n.scale = n.distance / e.gesture.startDistance, n.angle = X.touchAngle(o, l), n.ds = n.scale - e.gesture.scale, n.da = n.angle - e.gesture.angle;\n      e.gesture.distance = n.distance, e.gesture.angle = n.angle, i.default.number(n.scale) && n.scale !== 1 / 0 && !isNaN(n.scale) && (e.gesture.scale = n.scale);\n    }\n  }\n  Object.defineProperty(gt, \"__esModule\", {\n    value: !0\n  }), gt.default = void 0;\n  var mt = {\n      id: \"actions/gesture\",\n      before: [\"actions/drag\", \"actions/resize\"],\n      install: function (t) {\n        var e = t.actions,\n          n = t.Interactable,\n          r = t.defaults;\n        n.prototype.gesturable = function (t) {\n          return i.default.object(t) ? (this.options.gesture.enabled = !1 !== t.enabled, this.setPerAction(\"gesture\", t), this.setOnEvents(\"gesture\", t), this) : i.default.bool(t) ? (this.options.gesture.enabled = t, this) : this.options.gesture;\n        }, e.map.gesture = mt, e.methodDict.gesture = \"gesturable\", r.actions.gesture = mt.defaults;\n      },\n      listeners: {\n        \"interactions:action-start\": yt,\n        \"interactions:action-move\": yt,\n        \"interactions:action-end\": yt,\n        \"interactions:new\": function (t) {\n          t.interaction.gesture = {\n            angle: 0,\n            distance: 0,\n            scale: 1,\n            startAngle: 0,\n            startDistance: 0\n          };\n        },\n        \"auto-start:check\": function (t) {\n          if (!(t.interaction.pointers.length < 2)) {\n            var e = t.interactable.options.gesture;\n            if (e && e.enabled) return t.action = {\n              name: \"gesture\"\n            }, !1;\n          }\n        }\n      },\n      defaults: {},\n      getCursor: function () {\n        return \"\";\n      }\n    },\n    bt = mt;\n  gt.default = bt;\n  var xt = {};\n  function wt(t, e, n, r, o, a, s) {\n    if (!e) return !1;\n    if (!0 === e) {\n      var l = i.default.number(a.width) ? a.width : a.right - a.left,\n        u = i.default.number(a.height) ? a.height : a.bottom - a.top;\n      if (s = Math.min(s, Math.abs((\"left\" === t || \"right\" === t ? l : u) / 2)), l < 0 && (\"left\" === t ? t = \"right\" : \"right\" === t && (t = \"left\")), u < 0 && (\"top\" === t ? t = \"bottom\" : \"bottom\" === t && (t = \"top\")), \"left\" === t) {\n        var c = l >= 0 ? a.left : a.right;\n        return n.x < c + s;\n      }\n      if (\"top\" === t) {\n        var f = u >= 0 ? a.top : a.bottom;\n        return n.y < f + s;\n      }\n      if (\"right\" === t) return n.x > (l >= 0 ? a.right : a.left) - s;\n      if (\"bottom\" === t) return n.y > (u >= 0 ? a.bottom : a.top) - s;\n    }\n    return !!i.default.element(r) && (i.default.element(e) ? e === r : _.matchesUpTo(r, e, o));\n  }\n  function _t(t) {\n    var e = t.iEvent,\n      n = t.interaction;\n    if (\"resize\" === n.prepared.name && n.resizeAxes) {\n      var r = e;\n      n.interactable.options.resize.square ? (\"y\" === n.resizeAxes ? r.delta.x = r.delta.y : r.delta.y = r.delta.x, r.axes = \"xy\") : (r.axes = n.resizeAxes, \"x\" === n.resizeAxes ? r.delta.y = 0 : \"y\" === n.resizeAxes && (r.delta.x = 0));\n    }\n  }\n  Object.defineProperty(xt, \"__esModule\", {\n    value: !0\n  }), xt.default = void 0;\n  var Pt = {\n      id: \"actions/resize\",\n      before: [\"actions/drag\"],\n      install: function (t) {\n        var e = t.actions,\n          n = t.browser,\n          r = t.Interactable,\n          o = t.defaults;\n        Pt.cursors = function (t) {\n          return t.isIe9 ? {\n            x: \"e-resize\",\n            y: \"s-resize\",\n            xy: \"se-resize\",\n            top: \"n-resize\",\n            left: \"w-resize\",\n            bottom: \"s-resize\",\n            right: \"e-resize\",\n            topleft: \"se-resize\",\n            bottomright: \"se-resize\",\n            topright: \"ne-resize\",\n            bottomleft: \"ne-resize\"\n          } : {\n            x: \"ew-resize\",\n            y: \"ns-resize\",\n            xy: \"nwse-resize\",\n            top: \"ns-resize\",\n            left: \"ew-resize\",\n            bottom: \"ns-resize\",\n            right: \"ew-resize\",\n            topleft: \"nwse-resize\",\n            bottomright: \"nwse-resize\",\n            topright: \"nesw-resize\",\n            bottomleft: \"nesw-resize\"\n          };\n        }(n), Pt.defaultMargin = n.supportsTouch || n.supportsPointerEvent ? 20 : 10, r.prototype.resizable = function (e) {\n          return function (t, e, n) {\n            return i.default.object(e) ? (t.options.resize.enabled = !1 !== e.enabled, t.setPerAction(\"resize\", e), t.setOnEvents(\"resize\", e), i.default.string(e.axis) && /^x$|^y$|^xy$/.test(e.axis) ? t.options.resize.axis = e.axis : null === e.axis && (t.options.resize.axis = n.defaults.actions.resize.axis), i.default.bool(e.preserveAspectRatio) ? t.options.resize.preserveAspectRatio = e.preserveAspectRatio : i.default.bool(e.square) && (t.options.resize.square = e.square), t) : i.default.bool(e) ? (t.options.resize.enabled = e, t) : t.options.resize;\n          }(this, e, t);\n        }, e.map.resize = Pt, e.methodDict.resize = \"resizable\", o.actions.resize = Pt.defaults;\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          t.interaction.resizeAxes = \"xy\";\n        },\n        \"interactions:action-start\": function (t) {\n          !function (t) {\n            var e = t.iEvent,\n              n = t.interaction;\n            if (\"resize\" === n.prepared.name && n.prepared.edges) {\n              var r = e,\n                o = n.rect;\n              n._rects = {\n                start: (0, M.default)({}, o),\n                corrected: (0, M.default)({}, o),\n                previous: (0, M.default)({}, o),\n                delta: {\n                  left: 0,\n                  right: 0,\n                  width: 0,\n                  top: 0,\n                  bottom: 0,\n                  height: 0\n                }\n              }, r.edges = n.prepared.edges, r.rect = n._rects.corrected, r.deltaRect = n._rects.delta;\n            }\n          }(t), _t(t);\n        },\n        \"interactions:action-move\": function (t) {\n          !function (t) {\n            var e = t.iEvent,\n              n = t.interaction;\n            if (\"resize\" === n.prepared.name && n.prepared.edges) {\n              var r = e,\n                o = n.interactable.options.resize.invert,\n                i = \"reposition\" === o || \"negate\" === o,\n                a = n.rect,\n                s = n._rects,\n                l = s.start,\n                u = s.corrected,\n                c = s.delta,\n                f = s.previous;\n              if ((0, M.default)(f, u), i) {\n                if ((0, M.default)(u, a), \"reposition\" === o) {\n                  if (u.top > u.bottom) {\n                    var d = u.top;\n                    u.top = u.bottom, u.bottom = d;\n                  }\n                  if (u.left > u.right) {\n                    var p = u.left;\n                    u.left = u.right, u.right = p;\n                  }\n                }\n              } else u.top = Math.min(a.top, l.bottom), u.bottom = Math.max(a.bottom, l.top), u.left = Math.min(a.left, l.right), u.right = Math.max(a.right, l.left);\n              for (var v in u.width = u.right - u.left, u.height = u.bottom - u.top, u) c[v] = u[v] - f[v];\n              r.edges = n.prepared.edges, r.rect = u, r.deltaRect = c;\n            }\n          }(t), _t(t);\n        },\n        \"interactions:action-end\": function (t) {\n          var e = t.iEvent,\n            n = t.interaction;\n          if (\"resize\" === n.prepared.name && n.prepared.edges) {\n            var r = e;\n            r.edges = n.prepared.edges, r.rect = n._rects.corrected, r.deltaRect = n._rects.delta;\n          }\n        },\n        \"auto-start:check\": function (t) {\n          var e = t.interaction,\n            n = t.interactable,\n            r = t.element,\n            o = t.rect,\n            a = t.buttons;\n          if (o) {\n            var s = (0, M.default)({}, e.coords.cur.page),\n              l = n.options.resize;\n            if (l && l.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || 0 != (a & l.mouseButtons))) {\n              if (i.default.object(l.edges)) {\n                var u = {\n                  left: !1,\n                  right: !1,\n                  top: !1,\n                  bottom: !1\n                };\n                for (var c in u) u[c] = wt(c, l.edges[c], s, e._latestPointer.eventTarget, r, o, l.margin || Pt.defaultMargin);\n                u.left = u.left && !u.right, u.top = u.top && !u.bottom, (u.left || u.right || u.top || u.bottom) && (t.action = {\n                  name: \"resize\",\n                  edges: u\n                });\n              } else {\n                var f = \"y\" !== l.axis && s.x > o.right - Pt.defaultMargin,\n                  d = \"x\" !== l.axis && s.y > o.bottom - Pt.defaultMargin;\n                (f || d) && (t.action = {\n                  name: \"resize\",\n                  axes: (f ? \"x\" : \"\") + (d ? \"y\" : \"\")\n                });\n              }\n              return !t.action && void 0;\n            }\n          }\n        }\n      },\n      defaults: {\n        square: !1,\n        preserveAspectRatio: !1,\n        axis: \"xy\",\n        margin: NaN,\n        edges: null,\n        invert: \"none\"\n      },\n      cursors: null,\n      getCursor: function (t) {\n        var e = t.edges,\n          n = t.axis,\n          r = t.name,\n          o = Pt.cursors,\n          i = null;\n        if (n) i = o[r + n];else if (e) {\n          for (var a = \"\", s = [\"top\", \"bottom\", \"left\", \"right\"], l = 0; l < s.length; l++) {\n            var u = s[l];\n            e[u] && (a += u);\n          }\n          i = o[a];\n        }\n        return i;\n      },\n      defaultMargin: null\n    },\n    Ot = Pt;\n  xt.default = Ot;\n  var Et = {};\n  Object.defineProperty(Et, \"__esModule\", {\n    value: !0\n  }), Et.default = void 0;\n  var St = {\n    id: \"actions\",\n    install: function (t) {\n      t.usePlugin(gt.default), t.usePlugin(xt.default), t.usePlugin(c.default), t.usePlugin(st.default);\n    }\n  };\n  Et.default = St;\n  var Tt = {};\n  Object.defineProperty(Tt, \"__esModule\", {\n    value: !0\n  }), Tt.default = void 0;\n  var jt,\n    Mt,\n    kt = 0,\n    It = {\n      request: function (t) {\n        return jt(t);\n      },\n      cancel: function (t) {\n        return Mt(t);\n      },\n      init: function (t) {\n        if (jt = t.requestAnimationFrame, Mt = t.cancelAnimationFrame, !jt) for (var e = [\"ms\", \"moz\", \"webkit\", \"o\"], n = 0; n < e.length; n++) {\n          var r = e[n];\n          jt = t[\"\".concat(r, \"RequestAnimationFrame\")], Mt = t[\"\".concat(r, \"CancelAnimationFrame\")] || t[\"\".concat(r, \"CancelRequestAnimationFrame\")];\n        }\n        jt = jt && jt.bind(t), Mt = Mt && Mt.bind(t), jt || (jt = function (e) {\n          var n = Date.now(),\n            r = Math.max(0, 16 - (n - kt)),\n            o = t.setTimeout(function () {\n              e(n + r);\n            }, r);\n          return kt = n + r, o;\n        }, Mt = function (t) {\n          return clearTimeout(t);\n        });\n      }\n    };\n  Tt.default = It;\n  var Dt = {};\n  Object.defineProperty(Dt, \"__esModule\", {\n    value: !0\n  }), Dt.default = void 0, Dt.getContainer = zt, Dt.getScroll = Ct, Dt.getScrollSize = function (t) {\n    return i.default.window(t) && (t = window.document.body), {\n      x: t.scrollWidth,\n      y: t.scrollHeight\n    };\n  }, Dt.getScrollSizeDelta = function (t, e) {\n    var n = t.interaction,\n      r = t.element,\n      o = n && n.interactable.options[n.prepared.name].autoScroll;\n    if (!o || !o.enabled) return e(), {\n      x: 0,\n      y: 0\n    };\n    var i = zt(o.container, n.interactable, r),\n      a = Ct(i);\n    e();\n    var s = Ct(i);\n    return {\n      x: s.x - a.x,\n      y: s.y - a.y\n    };\n  };\n  var At = {\n    defaults: {\n      enabled: !1,\n      margin: 60,\n      container: null,\n      speed: 300\n    },\n    now: Date.now,\n    interaction: null,\n    i: 0,\n    x: 0,\n    y: 0,\n    isScrolling: !1,\n    prevTime: 0,\n    margin: 0,\n    speed: 0,\n    start: function (t) {\n      At.isScrolling = !0, Tt.default.cancel(At.i), t.autoScroll = At, At.interaction = t, At.prevTime = At.now(), At.i = Tt.default.request(At.scroll);\n    },\n    stop: function () {\n      At.isScrolling = !1, At.interaction && (At.interaction.autoScroll = null), Tt.default.cancel(At.i);\n    },\n    scroll: function () {\n      var t = At.interaction,\n        e = t.interactable,\n        n = t.element,\n        r = t.prepared.name,\n        o = e.options[r].autoScroll,\n        a = zt(o.container, e, n),\n        s = At.now(),\n        l = (s - At.prevTime) / 1e3,\n        u = o.speed * l;\n      if (u >= 1) {\n        var c = {\n          x: At.x * u,\n          y: At.y * u\n        };\n        if (c.x || c.y) {\n          var f = Ct(a);\n          i.default.window(a) ? a.scrollBy(c.x, c.y) : a && (a.scrollLeft += c.x, a.scrollTop += c.y);\n          var d = Ct(a),\n            p = {\n              x: d.x - f.x,\n              y: d.y - f.y\n            };\n          (p.x || p.y) && e.fire({\n            type: \"autoscroll\",\n            target: n,\n            interactable: e,\n            delta: p,\n            interaction: t,\n            container: a\n          });\n        }\n        At.prevTime = s;\n      }\n      At.isScrolling && (Tt.default.cancel(At.i), At.i = Tt.default.request(At.scroll));\n    },\n    check: function (t, e) {\n      var n;\n      return null == (n = t.options[e].autoScroll) ? void 0 : n.enabled;\n    },\n    onInteractionMove: function (t) {\n      var e = t.interaction,\n        n = t.pointer;\n      if (e.interacting() && At.check(e.interactable, e.prepared.name)) if (e.simulation) At.x = At.y = 0;else {\n        var r,\n          o,\n          a,\n          s,\n          l = e.interactable,\n          u = e.element,\n          c = e.prepared.name,\n          f = l.options[c].autoScroll,\n          d = zt(f.container, l, u);\n        if (i.default.window(d)) s = n.clientX < At.margin, r = n.clientY < At.margin, o = n.clientX > d.innerWidth - At.margin, a = n.clientY > d.innerHeight - At.margin;else {\n          var p = _.getElementClientRect(d);\n          s = n.clientX < p.left + At.margin, r = n.clientY < p.top + At.margin, o = n.clientX > p.right - At.margin, a = n.clientY > p.bottom - At.margin;\n        }\n        At.x = o ? 1 : s ? -1 : 0, At.y = a ? 1 : r ? -1 : 0, At.isScrolling || (At.margin = f.margin, At.speed = f.speed, At.start(e));\n      }\n    }\n  };\n  function zt(t, n, r) {\n    return (i.default.string(t) ? (0, k.getStringOptionResult)(t, n, r) : t) || (0, e.getWindow)(r);\n  }\n  function Ct(t) {\n    return i.default.window(t) && (t = window.document.body), {\n      x: t.scrollLeft,\n      y: t.scrollTop\n    };\n  }\n  var Rt = {\n      id: \"auto-scroll\",\n      install: function (t) {\n        var e = t.defaults,\n          n = t.actions;\n        t.autoScroll = At, At.now = function () {\n          return t.now();\n        }, n.phaselessTypes.autoscroll = !0, e.perAction.autoScroll = At.defaults;\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          t.interaction.autoScroll = null;\n        },\n        \"interactions:destroy\": function (t) {\n          t.interaction.autoScroll = null, At.stop(), At.interaction && (At.interaction = null);\n        },\n        \"interactions:stop\": At.stop,\n        \"interactions:action-move\": function (t) {\n          return At.onInteractionMove(t);\n        }\n      }\n    },\n    Ft = Rt;\n  Dt.default = Ft;\n  var Xt = {};\n  Object.defineProperty(Xt, \"__esModule\", {\n    value: !0\n  }), Xt.copyAction = function (t, e) {\n    return t.name = e.name, t.axis = e.axis, t.edges = e.edges, t;\n  }, Xt.sign = void 0, Xt.warnOnce = function (t, n) {\n    var r = !1;\n    return function () {\n      return r || (e.window.console.warn(n), r = !0), t.apply(this, arguments);\n    };\n  }, Xt.sign = function (t) {\n    return t >= 0 ? 1 : -1;\n  };\n  var Bt = {};\n  function Yt(t) {\n    return i.default.bool(t) ? (this.options.styleCursor = t, this) : null === t ? (delete this.options.styleCursor, this) : this.options.styleCursor;\n  }\n  function Wt(t) {\n    return i.default.func(t) ? (this.options.actionChecker = t, this) : null === t ? (delete this.options.actionChecker, this) : this.options.actionChecker;\n  }\n  Object.defineProperty(Bt, \"__esModule\", {\n    value: !0\n  }), Bt.default = void 0;\n  var Lt = {\n    id: \"auto-start/interactableMethods\",\n    install: function (t) {\n      var e = t.Interactable;\n      e.prototype.getAction = function (e, n, r, o) {\n        var i = function (t, e, n, r, o) {\n          var i = t.getRect(r),\n            a = {\n              action: null,\n              interactable: t,\n              interaction: n,\n              element: r,\n              rect: i,\n              buttons: e.buttons || {\n                0: 1,\n                1: 4,\n                3: 8,\n                4: 16\n              }[e.button]\n            };\n          return o.fire(\"auto-start:check\", a), a.action;\n        }(this, n, r, o, t);\n        return this.options.actionChecker ? this.options.actionChecker(e, n, i, this, o, r) : i;\n      }, e.prototype.ignoreFrom = (0, Xt.warnOnce)(function (t) {\n        return this._backCompatOption(\"ignoreFrom\", t);\n      }, \"Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).\"), e.prototype.allowFrom = (0, Xt.warnOnce)(function (t) {\n        return this._backCompatOption(\"allowFrom\", t);\n      }, \"Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).\"), e.prototype.actionChecker = Wt, e.prototype.styleCursor = Yt;\n    }\n  };\n  Bt.default = Lt;\n  var Ut = {};\n  function Vt(t, e, n, r, o) {\n    return e.testIgnoreAllow(e.options[t.name], n, r) && e.options[t.name].enabled && $t(e, n, t, o) ? t : null;\n  }\n  function Nt(t, e, n, r, o, i, a) {\n    for (var s = 0, l = r.length; s < l; s++) {\n      var u = r[s],\n        c = o[s],\n        f = u.getAction(e, n, t, c);\n      if (f) {\n        var d = Vt(f, u, c, i, a);\n        if (d) return {\n          action: d,\n          interactable: u,\n          element: c\n        };\n      }\n    }\n    return {\n      action: null,\n      interactable: null,\n      element: null\n    };\n  }\n  function qt(t, e, n, r, o) {\n    var a = [],\n      s = [],\n      l = r;\n    function u(t) {\n      a.push(t), s.push(l);\n    }\n    for (; i.default.element(l);) {\n      a = [], s = [], o.interactables.forEachMatch(l, u);\n      var c = Nt(t, e, n, a, s, r, o);\n      if (c.action && !c.interactable.options[c.action.name].manualStart) return c;\n      l = _.parentNode(l);\n    }\n    return {\n      action: null,\n      interactable: null,\n      element: null\n    };\n  }\n  function Gt(t, e, n) {\n    var r = e.action,\n      o = e.interactable,\n      i = e.element;\n    r = r || {\n      name: null\n    }, t.interactable = o, t.element = i, (0, Xt.copyAction)(t.prepared, r), t.rect = o && r.name ? o.getRect(i) : null, Zt(t, n), n.fire(\"autoStart:prepared\", {\n      interaction: t\n    });\n  }\n  function $t(t, e, n, r) {\n    var o = t.options,\n      i = o[n.name].max,\n      a = o[n.name].maxPerElement,\n      s = r.autoStart.maxInteractions,\n      l = 0,\n      u = 0,\n      c = 0;\n    if (!(i && a && s)) return !1;\n    for (var f = 0; f < r.interactions.list.length; f++) {\n      var d = r.interactions.list[f],\n        p = d.prepared.name;\n      if (d.interacting()) {\n        if (++l >= s) return !1;\n        if (d.interactable === t) {\n          if ((u += p === n.name ? 1 : 0) >= i) return !1;\n          if (d.element === e && (c++, p === n.name && c >= a)) return !1;\n        }\n      }\n    }\n    return s > 0;\n  }\n  function Ht(t, e) {\n    return i.default.number(t) ? (e.autoStart.maxInteractions = t, this) : e.autoStart.maxInteractions;\n  }\n  function Kt(t, e, n) {\n    var r = n.autoStart.cursorElement;\n    r && r !== t && (r.style.cursor = \"\"), t.ownerDocument.documentElement.style.cursor = e, t.style.cursor = e, n.autoStart.cursorElement = e ? t : null;\n  }\n  function Zt(t, e) {\n    var n = t.interactable,\n      r = t.element,\n      o = t.prepared;\n    if (\"mouse\" === t.pointerType && n && n.options.styleCursor) {\n      var a = \"\";\n      if (o.name) {\n        var s = n.options[o.name].cursorChecker;\n        a = i.default.func(s) ? s(o, n, r, t._interacting) : e.actions.map[o.name].getCursor(o);\n      }\n      Kt(t.element, a || \"\", e);\n    } else e.autoStart.cursorElement && Kt(e.autoStart.cursorElement, \"\", e);\n  }\n  Object.defineProperty(Ut, \"__esModule\", {\n    value: !0\n  }), Ut.default = void 0;\n  var Jt = {\n      id: \"auto-start/base\",\n      before: [\"actions\"],\n      install: function (t) {\n        var e = t.interactStatic,\n          n = t.defaults;\n        t.usePlugin(Bt.default), n.base.actionChecker = null, n.base.styleCursor = !0, (0, M.default)(n.perAction, {\n          manualStart: !1,\n          max: 1 / 0,\n          maxPerElement: 1,\n          allowFrom: null,\n          ignoreFrom: null,\n          mouseButtons: 1\n        }), e.maxInteractions = function (e) {\n          return Ht(e, t);\n        }, t.autoStart = {\n          maxInteractions: 1 / 0,\n          withinInteractionLimit: $t,\n          cursorElement: null\n        };\n      },\n      listeners: {\n        \"interactions:down\": function (t, e) {\n          var n = t.interaction,\n            r = t.pointer,\n            o = t.event,\n            i = t.eventTarget;\n          n.interacting() || Gt(n, qt(n, r, o, i, e), e);\n        },\n        \"interactions:move\": function (t, e) {\n          !function (t, e) {\n            var n = t.interaction,\n              r = t.pointer,\n              o = t.event,\n              i = t.eventTarget;\n            \"mouse\" !== n.pointerType || n.pointerIsDown || n.interacting() || Gt(n, qt(n, r, o, i, e), e);\n          }(t, e), function (t, e) {\n            var n = t.interaction;\n            if (n.pointerIsDown && !n.interacting() && n.pointerWasMoved && n.prepared.name) {\n              e.fire(\"autoStart:before-start\", t);\n              var r = n.interactable,\n                o = n.prepared.name;\n              o && r && (r.options[o].manualStart || !$t(r, n.element, n.prepared, e) ? n.stop() : (n.start(n.prepared, r, n.element), Zt(n, e)));\n            }\n          }(t, e);\n        },\n        \"interactions:stop\": function (t, e) {\n          var n = t.interaction,\n            r = n.interactable;\n          r && r.options.styleCursor && Kt(n.element, \"\", e);\n        }\n      },\n      maxInteractions: Ht,\n      withinInteractionLimit: $t,\n      validateAction: Vt\n    },\n    Qt = Jt;\n  Ut.default = Qt;\n  var te = {};\n  Object.defineProperty(te, \"__esModule\", {\n    value: !0\n  }), te.default = void 0;\n  var ee = {\n    id: \"auto-start/dragAxis\",\n    listeners: {\n      \"autoStart:before-start\": function (t, e) {\n        var n = t.interaction,\n          r = t.eventTarget,\n          o = t.dx,\n          a = t.dy;\n        if (\"drag\" === n.prepared.name) {\n          var s = Math.abs(o),\n            l = Math.abs(a),\n            u = n.interactable.options.drag,\n            c = u.startAxis,\n            f = s > l ? \"x\" : s < l ? \"y\" : \"xy\";\n          if (n.prepared.axis = \"start\" === u.lockAxis ? f[0] : u.lockAxis, \"xy\" !== f && \"xy\" !== c && c !== f) {\n            n.prepared.name = null;\n            for (var d = r, p = function (t) {\n                if (t !== n.interactable) {\n                  var o = n.interactable.options.drag;\n                  if (!o.manualStart && t.testIgnoreAllow(o, d, r)) {\n                    var i = t.getAction(n.downPointer, n.downEvent, n, d);\n                    if (i && \"drag\" === i.name && function (t, e) {\n                      if (!e) return !1;\n                      var n = e.options.drag.startAxis;\n                      return \"xy\" === t || \"xy\" === n || n === t;\n                    }(f, t) && Ut.default.validateAction(i, t, d, r, e)) return t;\n                  }\n                }\n              }; i.default.element(d);) {\n              var v = e.interactables.forEachMatch(d, p);\n              if (v) {\n                n.prepared.name = \"drag\", n.interactable = v, n.element = d;\n                break;\n              }\n              d = (0, _.parentNode)(d);\n            }\n          }\n        }\n      }\n    }\n  };\n  te.default = ee;\n  var ne = {};\n  function re(t) {\n    var e = t.prepared && t.prepared.name;\n    if (!e) return null;\n    var n = t.interactable.options;\n    return n[e].hold || n[e].delay;\n  }\n  Object.defineProperty(ne, \"__esModule\", {\n    value: !0\n  }), ne.default = void 0;\n  var oe = {\n      id: \"auto-start/hold\",\n      install: function (t) {\n        var e = t.defaults;\n        t.usePlugin(Ut.default), e.perAction.hold = 0, e.perAction.delay = 0;\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          t.interaction.autoStartHoldTimer = null;\n        },\n        \"autoStart:prepared\": function (t) {\n          var e = t.interaction,\n            n = re(e);\n          n > 0 && (e.autoStartHoldTimer = setTimeout(function () {\n            e.start(e.prepared, e.interactable, e.element);\n          }, n));\n        },\n        \"interactions:move\": function (t) {\n          var e = t.interaction,\n            n = t.duplicate;\n          e.autoStartHoldTimer && e.pointerWasMoved && !n && (clearTimeout(e.autoStartHoldTimer), e.autoStartHoldTimer = null);\n        },\n        \"autoStart:before-start\": function (t) {\n          var e = t.interaction;\n          re(e) > 0 && (e.prepared.name = null);\n        }\n      },\n      getHoldDuration: re\n    },\n    ie = oe;\n  ne.default = ie;\n  var ae = {};\n  Object.defineProperty(ae, \"__esModule\", {\n    value: !0\n  }), ae.default = void 0;\n  var se = {\n    id: \"auto-start\",\n    install: function (t) {\n      t.usePlugin(Ut.default), t.usePlugin(ne.default), t.usePlugin(te.default);\n    }\n  };\n  ae.default = se;\n  var le = {};\n  function ue(t) {\n    return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : i.default.bool(t) ? (this.options.preventDefault = t ? \"always\" : \"never\", this) : this.options.preventDefault;\n  }\n  function ce(t) {\n    var e = t.interaction,\n      n = t.event;\n    e.interactable && e.interactable.checkAndPreventDefault(n);\n  }\n  function fe(t) {\n    var n = t.Interactable;\n    n.prototype.preventDefault = ue, n.prototype.checkAndPreventDefault = function (n) {\n      return function (t, n, r) {\n        var o = t.options.preventDefault;\n        if (\"never\" !== o) if (\"always\" !== o) {\n          if (n.events.supportsPassive && /^touch(start|move)$/.test(r.type)) {\n            var a = (0, e.getWindow)(r.target).document,\n              s = n.getDocOptions(a);\n            if (!s || !s.events || !1 !== s.events.passive) return;\n          }\n          /^(mouse|pointer|touch)*(down|start)/i.test(r.type) || i.default.element(r.target) && (0, _.matchesSelector)(r.target, \"input,select,textarea,[contenteditable=true],[contenteditable=true] *\") || r.preventDefault();\n        } else r.preventDefault();\n      }(this, t, n);\n    }, t.interactions.docEvents.push({\n      type: \"dragstart\",\n      listener: function (e) {\n        for (var n = 0; n < t.interactions.list.length; n++) {\n          var r = t.interactions.list[n];\n          if (r.element && (r.element === e.target || (0, _.nodeContains)(r.element, e.target))) return void r.interactable.checkAndPreventDefault(e);\n        }\n      }\n    });\n  }\n  Object.defineProperty(le, \"__esModule\", {\n    value: !0\n  }), le.default = void 0, le.install = fe;\n  var de = {\n    id: \"core/interactablePreventDefault\",\n    install: fe,\n    listeners: [\"down\", \"move\", \"up\", \"cancel\"].reduce(function (t, e) {\n      return t[\"interactions:\".concat(e)] = ce, t;\n    }, {})\n  };\n  le.default = de;\n  var pe = {};\n  Object.defineProperty(pe, \"__esModule\", {\n    value: !0\n  }), pe.default = void 0, pe.default = {};\n  var ve,\n    he = {};\n  Object.defineProperty(he, \"__esModule\", {\n    value: !0\n  }), he.default = void 0, function (t) {\n    t.touchAction = \"touchAction\", t.boxSizing = \"boxSizing\", t.noListeners = \"noListeners\";\n  }(ve || (ve = {}));\n  ve.touchAction, ve.boxSizing, ve.noListeners;\n  var ge = {\n    id: \"dev-tools\",\n    install: function () {}\n  };\n  he.default = ge;\n  var ye = {};\n  Object.defineProperty(ye, \"__esModule\", {\n    value: !0\n  }), ye.default = function t(e) {\n    var n = {};\n    for (var r in e) {\n      var o = e[r];\n      i.default.plainObject(o) ? n[r] = t(o) : i.default.array(o) ? n[r] = H.from(o) : n[r] = o;\n    }\n    return n;\n  };\n  var me = {};\n  function be(t, e) {\n    return function (t) {\n      if (Array.isArray(t)) return t;\n    }(t) || function (t, e) {\n      var n = null == t ? null : \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n      if (null != n) {\n        var r,\n          o,\n          i = [],\n          a = !0,\n          s = !1;\n        try {\n          for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0);\n        } catch (t) {\n          s = !0, o = t;\n        } finally {\n          try {\n            a || null == n.return || n.return();\n          } finally {\n            if (s) throw o;\n          }\n        }\n        return i;\n      }\n    }(t, e) || function (t, e) {\n      if (t) {\n        if (\"string\" == typeof t) return xe(t, e);\n        var n = Object.prototype.toString.call(t).slice(8, -1);\n        return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(t) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? xe(t, e) : void 0;\n      }\n    }(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n  function xe(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n    return r;\n  }\n  function we(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function _e(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(me, \"__esModule\", {\n    value: !0\n  }), me.default = void 0, me.getRectOffset = Ee;\n  var Pe = function () {\n    function t(e) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), _e(this, \"states\", []), _e(this, \"startOffset\", {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }), _e(this, \"startDelta\", void 0), _e(this, \"result\", void 0), _e(this, \"endResult\", void 0), _e(this, \"edges\", void 0), _e(this, \"interaction\", void 0), this.interaction = e, this.result = Oe();\n    }\n    var e, n;\n    return e = t, (n = [{\n      key: \"start\",\n      value: function (t, e) {\n        var n = t.phase,\n          r = this.interaction,\n          o = function (t) {\n            var e = t.interactable.options[t.prepared.name],\n              n = e.modifiers;\n            return n && n.length ? n : [\"snap\", \"snapSize\", \"snapEdges\", \"restrict\", \"restrictEdges\", \"restrictSize\"].map(function (t) {\n              var n = e[t];\n              return n && n.enabled && {\n                options: n,\n                methods: n._methods\n              };\n            }).filter(function (t) {\n              return !!t;\n            });\n          }(r);\n        this.prepareStates(o), this.edges = (0, M.default)({}, r.edges), this.startOffset = Ee(r.rect, e), this.startDelta = {\n          x: 0,\n          y: 0\n        };\n        var i = this.fillArg({\n          phase: n,\n          pageCoords: e,\n          preEnd: !1\n        });\n        return this.result = Oe(), this.startAll(i), this.result = this.setAll(i);\n      }\n    }, {\n      key: \"fillArg\",\n      value: function (t) {\n        var e = this.interaction;\n        return t.interaction = e, t.interactable = e.interactable, t.element = e.element, t.rect = t.rect || e.rect, t.edges = this.edges, t.startOffset = this.startOffset, t;\n      }\n    }, {\n      key: \"startAll\",\n      value: function (t) {\n        for (var e = 0; e < this.states.length; e++) {\n          var n = this.states[e];\n          n.methods.start && (t.state = n, n.methods.start(t));\n        }\n      }\n    }, {\n      key: \"setAll\",\n      value: function (t) {\n        var e = t.phase,\n          n = t.preEnd,\n          r = t.skipModifiers,\n          o = t.rect;\n        t.coords = (0, M.default)({}, t.pageCoords), t.rect = (0, M.default)({}, o);\n        for (var i = r ? this.states.slice(r) : this.states, a = Oe(t.coords, t.rect), s = 0; s < i.length; s++) {\n          var l,\n            u = i[s],\n            c = u.options,\n            f = (0, M.default)({}, t.coords),\n            d = null;\n          null != (l = u.methods) && l.set && this.shouldDo(c, n, e) && (t.state = u, d = u.methods.set(t), k.addEdges(this.interaction.edges, t.rect, {\n            x: t.coords.x - f.x,\n            y: t.coords.y - f.y\n          })), a.eventProps.push(d);\n        }\n        a.delta.x = t.coords.x - t.pageCoords.x, a.delta.y = t.coords.y - t.pageCoords.y, a.rectDelta.left = t.rect.left - o.left, a.rectDelta.right = t.rect.right - o.right, a.rectDelta.top = t.rect.top - o.top, a.rectDelta.bottom = t.rect.bottom - o.bottom;\n        var p = this.result.coords,\n          v = this.result.rect;\n        if (p && v) {\n          var h = a.rect.left !== v.left || a.rect.right !== v.right || a.rect.top !== v.top || a.rect.bottom !== v.bottom;\n          a.changed = h || p.x !== a.coords.x || p.y !== a.coords.y;\n        }\n        return a;\n      }\n    }, {\n      key: \"applyToInteraction\",\n      value: function (t) {\n        var e = this.interaction,\n          n = t.phase,\n          r = e.coords.cur,\n          o = e.coords.start,\n          i = this.result,\n          a = this.startDelta,\n          s = i.delta;\n        \"start\" === n && (0, M.default)(this.startDelta, i.delta);\n        for (var l = 0; l < [[o, a], [r, s]].length; l++) {\n          var u = be([[o, a], [r, s]][l], 2),\n            c = u[0],\n            f = u[1];\n          c.page.x += f.x, c.page.y += f.y, c.client.x += f.x, c.client.y += f.y;\n        }\n        var d = this.result.rectDelta,\n          p = t.rect || e.rect;\n        p.left += d.left, p.right += d.right, p.top += d.top, p.bottom += d.bottom, p.width = p.right - p.left, p.height = p.bottom - p.top;\n      }\n    }, {\n      key: \"setAndApply\",\n      value: function (t) {\n        var e = this.interaction,\n          n = t.phase,\n          r = t.preEnd,\n          o = t.skipModifiers,\n          i = this.setAll(this.fillArg({\n            preEnd: r,\n            phase: n,\n            pageCoords: t.modifiedCoords || e.coords.cur.page\n          }));\n        if (this.result = i, !i.changed && (!o || o < this.states.length) && e.interacting()) return !1;\n        if (t.modifiedCoords) {\n          var a = e.coords.cur.page,\n            s = {\n              x: t.modifiedCoords.x - a.x,\n              y: t.modifiedCoords.y - a.y\n            };\n          i.coords.x += s.x, i.coords.y += s.y, i.delta.x += s.x, i.delta.y += s.y;\n        }\n        this.applyToInteraction(t);\n      }\n    }, {\n      key: \"beforeEnd\",\n      value: function (t) {\n        var e = t.interaction,\n          n = t.event,\n          r = this.states;\n        if (r && r.length) {\n          for (var o = !1, i = 0; i < r.length; i++) {\n            var a = r[i];\n            t.state = a;\n            var s = a.options,\n              l = a.methods,\n              u = l.beforeEnd && l.beforeEnd(t);\n            if (u) return this.endResult = u, !1;\n            o = o || !o && this.shouldDo(s, !0, t.phase, !0);\n          }\n          o && e.move({\n            event: n,\n            preEnd: !0\n          });\n        }\n      }\n    }, {\n      key: \"stop\",\n      value: function (t) {\n        var e = t.interaction;\n        if (this.states && this.states.length) {\n          var n = (0, M.default)({\n            states: this.states,\n            interactable: e.interactable,\n            element: e.element,\n            rect: null\n          }, t);\n          this.fillArg(n);\n          for (var r = 0; r < this.states.length; r++) {\n            var o = this.states[r];\n            n.state = o, o.methods.stop && o.methods.stop(n);\n          }\n          this.states = null, this.endResult = null;\n        }\n      }\n    }, {\n      key: \"prepareStates\",\n      value: function (t) {\n        this.states = [];\n        for (var e = 0; e < t.length; e++) {\n          var n = t[e],\n            r = n.options,\n            o = n.methods,\n            i = n.name;\n          this.states.push({\n            options: r,\n            methods: o,\n            index: e,\n            name: i\n          });\n        }\n        return this.states;\n      }\n    }, {\n      key: \"restoreInteractionCoords\",\n      value: function (t) {\n        var e = t.interaction,\n          n = e.coords,\n          r = e.rect,\n          o = e.modification;\n        if (o.result) {\n          for (var i = o.startDelta, a = o.result, s = a.delta, l = a.rectDelta, u = [[n.start, i], [n.cur, s]], c = 0; c < u.length; c++) {\n            var f = be(u[c], 2),\n              d = f[0],\n              p = f[1];\n            d.page.x -= p.x, d.page.y -= p.y, d.client.x -= p.x, d.client.y -= p.y;\n          }\n          r.left -= l.left, r.right -= l.right, r.top -= l.top, r.bottom -= l.bottom;\n        }\n      }\n    }, {\n      key: \"shouldDo\",\n      value: function (t, e, n, r) {\n        return !(!t || !1 === t.enabled || r && !t.endOnly || t.endOnly && !e || \"start\" === n && !t.setStart);\n      }\n    }, {\n      key: \"copyFrom\",\n      value: function (t) {\n        this.startOffset = t.startOffset, this.startDelta = t.startDelta, this.edges = t.edges, this.states = t.states.map(function (t) {\n          return (0, ye.default)(t);\n        }), this.result = Oe((0, M.default)({}, t.result.coords), (0, M.default)({}, t.result.rect));\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        for (var t in this) this[t] = null;\n      }\n    }]) && we(e.prototype, n), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), t;\n  }();\n  function Oe(t, e) {\n    return {\n      rect: e,\n      coords: t,\n      delta: {\n        x: 0,\n        y: 0\n      },\n      rectDelta: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      },\n      eventProps: [],\n      changed: !0\n    };\n  }\n  function Ee(t, e) {\n    return t ? {\n      left: e.x - t.left,\n      top: e.y - t.top,\n      right: t.right - e.x,\n      bottom: t.bottom - e.y\n    } : {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n  me.default = Pe;\n  var Se = {};\n  function Te(t) {\n    var e = t.iEvent,\n      n = t.interaction.modification.result;\n    n && (e.modifiers = n.eventProps);\n  }\n  Object.defineProperty(Se, \"__esModule\", {\n    value: !0\n  }), Se.addEventModifiers = Te, Se.default = void 0, Se.makeModifier = function (t, e) {\n    var n = t.defaults,\n      r = {\n        start: t.start,\n        set: t.set,\n        beforeEnd: t.beforeEnd,\n        stop: t.stop\n      },\n      o = function (t) {\n        var o = t || {};\n        for (var i in o.enabled = !1 !== o.enabled, n) i in o || (o[i] = n[i]);\n        var a = {\n          options: o,\n          methods: r,\n          name: e,\n          enable: function () {\n            return o.enabled = !0, a;\n          },\n          disable: function () {\n            return o.enabled = !1, a;\n          }\n        };\n        return a;\n      };\n    return e && \"string\" == typeof e && (o._defaults = n, o._methods = r), o;\n  };\n  var je = {\n      id: \"modifiers/base\",\n      before: [\"actions\"],\n      install: function (t) {\n        t.defaults.perAction.modifiers = [];\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          var e = t.interaction;\n          e.modification = new me.default(e);\n        },\n        \"interactions:before-action-start\": function (t) {\n          var e = t.interaction.modification;\n          e.start(t, t.interaction.coords.start.page), t.interaction.edges = e.edges, e.applyToInteraction(t);\n        },\n        \"interactions:before-action-move\": function (t) {\n          return t.interaction.modification.setAndApply(t);\n        },\n        \"interactions:before-action-end\": function (t) {\n          return t.interaction.modification.beforeEnd(t);\n        },\n        \"interactions:action-start\": Te,\n        \"interactions:action-move\": Te,\n        \"interactions:action-end\": Te,\n        \"interactions:after-action-start\": function (t) {\n          return t.interaction.modification.restoreInteractionCoords(t);\n        },\n        \"interactions:after-action-move\": function (t) {\n          return t.interaction.modification.restoreInteractionCoords(t);\n        },\n        \"interactions:stop\": function (t) {\n          return t.interaction.modification.stop(t);\n        }\n      }\n    },\n    Me = je;\n  Se.default = Me;\n  var ke = {};\n  Object.defineProperty(ke, \"__esModule\", {\n    value: !0\n  }), ke.defaults = void 0, ke.defaults = {\n    base: {\n      preventDefault: \"auto\",\n      deltaSource: \"page\"\n    },\n    perAction: {\n      enabled: !1,\n      origin: {\n        x: 0,\n        y: 0\n      }\n    },\n    actions: {}\n  };\n  var Ie = {};\n  function De(t) {\n    return De = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    }, De(t);\n  }\n  function Ae(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function ze(t, e) {\n    return ze = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, ze(t, e);\n  }\n  function Ce(t, e) {\n    if (e && (\"object\" === De(e) || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return Re(t);\n  }\n  function Re(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n  function Fe(t) {\n    return Fe = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, Fe(t);\n  }\n  function Xe(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(Ie, \"__esModule\", {\n    value: !0\n  }), Ie.InteractEvent = void 0;\n  var Be = function (t) {\n    !function (t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          writable: !0,\n          configurable: !0\n        }\n      }), Object.defineProperty(t, \"prototype\", {\n        writable: !1\n      }), e && ze(t, e);\n    }(a, t);\n    var e,\n      n,\n      r,\n      o,\n      i = (r = a, o = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n        } catch (t) {\n          return !1;\n        }\n      }(), function () {\n        var t,\n          e = Fe(r);\n        if (o) {\n          var n = Fe(this).constructor;\n          t = Reflect.construct(e, arguments, n);\n        } else t = e.apply(this, arguments);\n        return Ce(this, t);\n      });\n    function a(t, e, n, r, o, s, l) {\n      var u;\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, a), Xe(Re(u = i.call(this, t)), \"relatedTarget\", null), Xe(Re(u), \"screenX\", void 0), Xe(Re(u), \"screenY\", void 0), Xe(Re(u), \"button\", void 0), Xe(Re(u), \"buttons\", void 0), Xe(Re(u), \"ctrlKey\", void 0), Xe(Re(u), \"shiftKey\", void 0), Xe(Re(u), \"altKey\", void 0), Xe(Re(u), \"metaKey\", void 0), Xe(Re(u), \"page\", void 0), Xe(Re(u), \"client\", void 0), Xe(Re(u), \"delta\", void 0), Xe(Re(u), \"rect\", void 0), Xe(Re(u), \"x0\", void 0), Xe(Re(u), \"y0\", void 0), Xe(Re(u), \"t0\", void 0), Xe(Re(u), \"dt\", void 0), Xe(Re(u), \"duration\", void 0), Xe(Re(u), \"clientX0\", void 0), Xe(Re(u), \"clientY0\", void 0), Xe(Re(u), \"velocity\", void 0), Xe(Re(u), \"speed\", void 0), Xe(Re(u), \"swipe\", void 0), Xe(Re(u), \"axes\", void 0), Xe(Re(u), \"preEnd\", void 0), o = o || t.element;\n      var c = t.interactable,\n        f = (c && c.options || ke.defaults).deltaSource,\n        d = (0, A.default)(c, o, n),\n        p = \"start\" === r,\n        v = \"end\" === r,\n        h = p ? Re(u) : t.prevEvent,\n        g = p ? t.coords.start : v ? {\n          page: h.page,\n          client: h.client,\n          timeStamp: t.coords.cur.timeStamp\n        } : t.coords.cur;\n      return u.page = (0, M.default)({}, g.page), u.client = (0, M.default)({}, g.client), u.rect = (0, M.default)({}, t.rect), u.timeStamp = g.timeStamp, v || (u.page.x -= d.x, u.page.y -= d.y, u.client.x -= d.x, u.client.y -= d.y), u.ctrlKey = e.ctrlKey, u.altKey = e.altKey, u.shiftKey = e.shiftKey, u.metaKey = e.metaKey, u.button = e.button, u.buttons = e.buttons, u.target = o, u.currentTarget = o, u.preEnd = s, u.type = l || n + (r || \"\"), u.interactable = c, u.t0 = p ? t.pointers[t.pointers.length - 1].downTime : h.t0, u.x0 = t.coords.start.page.x - d.x, u.y0 = t.coords.start.page.y - d.y, u.clientX0 = t.coords.start.client.x - d.x, u.clientY0 = t.coords.start.client.y - d.y, u.delta = p || v ? {\n        x: 0,\n        y: 0\n      } : {\n        x: u[f].x - h[f].x,\n        y: u[f].y - h[f].y\n      }, u.dt = t.coords.delta.timeStamp, u.duration = u.timeStamp - u.t0, u.velocity = (0, M.default)({}, t.coords.velocity[f]), u.speed = (0, R.default)(u.velocity.x, u.velocity.y), u.swipe = v || \"inertiastart\" === r ? u.getSwipe() : null, u;\n    }\n    return e = a, (n = [{\n      key: \"getSwipe\",\n      value: function () {\n        var t = this._interaction;\n        if (t.prevEvent.speed < 600 || this.timeStamp - t.prevEvent.timeStamp > 150) return null;\n        var e = 180 * Math.atan2(t.prevEvent.velocityY, t.prevEvent.velocityX) / Math.PI;\n        e < 0 && (e += 360);\n        var n = 112.5 <= e && e < 247.5,\n          r = 202.5 <= e && e < 337.5;\n        return {\n          up: r,\n          down: !r && 22.5 <= e && e < 157.5,\n          left: n,\n          right: !n && (292.5 <= e || e < 67.5),\n          angle: e,\n          speed: t.prevEvent.speed,\n          velocity: {\n            x: t.prevEvent.velocityX,\n            y: t.prevEvent.velocityY\n          }\n        };\n      }\n    }, {\n      key: \"preventDefault\",\n      value: function () {}\n    }, {\n      key: \"stopImmediatePropagation\",\n      value: function () {\n        this.immediatePropagationStopped = this.propagationStopped = !0;\n      }\n    }, {\n      key: \"stopPropagation\",\n      value: function () {\n        this.propagationStopped = !0;\n      }\n    }]) && Ae(e.prototype, n), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), a;\n  }(N.BaseEvent);\n  Ie.InteractEvent = Be, Object.defineProperties(Be.prototype, {\n    pageX: {\n      get: function () {\n        return this.page.x;\n      },\n      set: function (t) {\n        this.page.x = t;\n      }\n    },\n    pageY: {\n      get: function () {\n        return this.page.y;\n      },\n      set: function (t) {\n        this.page.y = t;\n      }\n    },\n    clientX: {\n      get: function () {\n        return this.client.x;\n      },\n      set: function (t) {\n        this.client.x = t;\n      }\n    },\n    clientY: {\n      get: function () {\n        return this.client.y;\n      },\n      set: function (t) {\n        this.client.y = t;\n      }\n    },\n    dx: {\n      get: function () {\n        return this.delta.x;\n      },\n      set: function (t) {\n        this.delta.x = t;\n      }\n    },\n    dy: {\n      get: function () {\n        return this.delta.y;\n      },\n      set: function (t) {\n        this.delta.y = t;\n      }\n    },\n    velocityX: {\n      get: function () {\n        return this.velocity.x;\n      },\n      set: function (t) {\n        this.velocity.x = t;\n      }\n    },\n    velocityY: {\n      get: function () {\n        return this.velocity.y;\n      },\n      set: function (t) {\n        this.velocity.y = t;\n      }\n    }\n  });\n  var Ye = {};\n  function We(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function Le(t, e, n) {\n    return e && We(t.prototype, e), n && We(t, n), Object.defineProperty(t, \"prototype\", {\n      writable: !1\n    }), t;\n  }\n  function Ue(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(Ye, \"__esModule\", {\n    value: !0\n  }), Ye.PointerInfo = void 0;\n  var Ve = Le(function t(e, n, r, o, i) {\n    !function (t, e) {\n      if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }(this, t), Ue(this, \"id\", void 0), Ue(this, \"pointer\", void 0), Ue(this, \"event\", void 0), Ue(this, \"downTime\", void 0), Ue(this, \"downTarget\", void 0), this.id = e, this.pointer = n, this.event = r, this.downTime = o, this.downTarget = i;\n  });\n  Ye.PointerInfo = Ve;\n  var Ne,\n    qe,\n    Ge = {};\n  function $e(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function He(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(Ge, \"__esModule\", {\n    value: !0\n  }), Ge.Interaction = void 0, Object.defineProperty(Ge, \"PointerInfo\", {\n    enumerable: !0,\n    get: function () {\n      return Ye.PointerInfo;\n    }\n  }), Ge.default = Ge._ProxyValues = Ge._ProxyMethods = void 0, Ge._ProxyValues = Ne, function (t) {\n    t.interactable = \"\", t.element = \"\", t.prepared = \"\", t.pointerIsDown = \"\", t.pointerWasMoved = \"\", t._proxy = \"\";\n  }(Ne || (Ge._ProxyValues = Ne = {})), Ge._ProxyMethods = qe, function (t) {\n    t.start = \"\", t.move = \"\", t.end = \"\", t.stop = \"\", t.interacting = \"\";\n  }(qe || (Ge._ProxyMethods = qe = {}));\n  var Ke = 0,\n    Ze = function () {\n      function t(e) {\n        var n = this,\n          r = e.pointerType,\n          o = e.scopeFire;\n        !function (t, e) {\n          if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n        }(this, t), He(this, \"interactable\", null), He(this, \"element\", null), He(this, \"rect\", null), He(this, \"_rects\", void 0), He(this, \"edges\", null), He(this, \"_scopeFire\", void 0), He(this, \"prepared\", {\n          name: null,\n          axis: null,\n          edges: null\n        }), He(this, \"pointerType\", void 0), He(this, \"pointers\", []), He(this, \"downEvent\", null), He(this, \"downPointer\", {}), He(this, \"_latestPointer\", {\n          pointer: null,\n          event: null,\n          eventTarget: null\n        }), He(this, \"prevEvent\", null), He(this, \"pointerIsDown\", !1), He(this, \"pointerWasMoved\", !1), He(this, \"_interacting\", !1), He(this, \"_ending\", !1), He(this, \"_stopped\", !0), He(this, \"_proxy\", null), He(this, \"simulation\", null), He(this, \"doMove\", (0, Xt.warnOnce)(function (t) {\n          this.move(t);\n        }, \"The interaction.doMove() method has been renamed to interaction.move()\")), He(this, \"coords\", {\n          start: X.newCoords(),\n          prev: X.newCoords(),\n          cur: X.newCoords(),\n          delta: X.newCoords(),\n          velocity: X.newCoords()\n        }), He(this, \"_id\", Ke++), this._scopeFire = o, this.pointerType = r;\n        var i = this;\n        this._proxy = {};\n        var a = function (t) {\n          Object.defineProperty(n._proxy, t, {\n            get: function () {\n              return i[t];\n            }\n          });\n        };\n        for (var s in Ne) a(s);\n        var l = function (t) {\n          Object.defineProperty(n._proxy, t, {\n            value: function () {\n              return i[t].apply(i, arguments);\n            }\n          });\n        };\n        for (var u in qe) l(u);\n        this._scopeFire(\"interactions:new\", {\n          interaction: this\n        });\n      }\n      var e, n;\n      return e = t, n = [{\n        key: \"pointerMoveTolerance\",\n        get: function () {\n          return 1;\n        }\n      }, {\n        key: \"pointerDown\",\n        value: function (t, e, n) {\n          var r = this.updatePointer(t, e, n, !0),\n            o = this.pointers[r];\n          this._scopeFire(\"interactions:down\", {\n            pointer: t,\n            event: e,\n            eventTarget: n,\n            pointerIndex: r,\n            pointerInfo: o,\n            type: \"down\",\n            interaction: this\n          });\n        }\n      }, {\n        key: \"start\",\n        value: function (t, e, n) {\n          return !(this.interacting() || !this.pointerIsDown || this.pointers.length < (\"gesture\" === t.name ? 2 : 1) || !e.options[t.name].enabled) && ((0, Xt.copyAction)(this.prepared, t), this.interactable = e, this.element = n, this.rect = e.getRect(n), this.edges = this.prepared.edges ? (0, M.default)({}, this.prepared.edges) : {\n            left: !0,\n            right: !0,\n            top: !0,\n            bottom: !0\n          }, this._stopped = !1, this._interacting = this._doPhase({\n            interaction: this,\n            event: this.downEvent,\n            phase: \"start\"\n          }) && !this._stopped, this._interacting);\n        }\n      }, {\n        key: \"pointerMove\",\n        value: function (t, e, n) {\n          this.simulation || this.modification && this.modification.endResult || this.updatePointer(t, e, n, !1);\n          var r,\n            o,\n            i = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;\n          this.pointerIsDown && !this.pointerWasMoved && (r = this.coords.cur.client.x - this.coords.start.client.x, o = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = (0, R.default)(r, o) > this.pointerMoveTolerance);\n          var a = this.getPointerIndex(t),\n            s = {\n              pointer: t,\n              pointerIndex: a,\n              pointerInfo: this.pointers[a],\n              event: e,\n              type: \"move\",\n              eventTarget: n,\n              dx: r,\n              dy: o,\n              duplicate: i,\n              interaction: this\n            };\n          i || X.setCoordVelocity(this.coords.velocity, this.coords.delta), this._scopeFire(\"interactions:move\", s), i || this.simulation || (this.interacting() && (s.type = null, this.move(s)), this.pointerWasMoved && X.copyCoords(this.coords.prev, this.coords.cur));\n        }\n      }, {\n        key: \"move\",\n        value: function (t) {\n          t && t.event || X.setZeroCoords(this.coords.delta), (t = (0, M.default)({\n            pointer: this._latestPointer.pointer,\n            event: this._latestPointer.event,\n            eventTarget: this._latestPointer.eventTarget,\n            interaction: this\n          }, t || {})).phase = \"move\", this._doPhase(t);\n        }\n      }, {\n        key: \"pointerUp\",\n        value: function (t, e, n, r) {\n          var o = this.getPointerIndex(t);\n          -1 === o && (o = this.updatePointer(t, e, n, !1));\n          var i = /cancel$/i.test(e.type) ? \"cancel\" : \"up\";\n          this._scopeFire(\"interactions:\".concat(i), {\n            pointer: t,\n            pointerIndex: o,\n            pointerInfo: this.pointers[o],\n            event: e,\n            eventTarget: n,\n            type: i,\n            curEventTarget: r,\n            interaction: this\n          }), this.simulation || this.end(e), this.removePointer(t, e);\n        }\n      }, {\n        key: \"documentBlur\",\n        value: function (t) {\n          this.end(t), this._scopeFire(\"interactions:blur\", {\n            event: t,\n            type: \"blur\",\n            interaction: this\n          });\n        }\n      }, {\n        key: \"end\",\n        value: function (t) {\n          var e;\n          this._ending = !0, t = t || this._latestPointer.event, this.interacting() && (e = this._doPhase({\n            event: t,\n            interaction: this,\n            phase: \"end\"\n          })), this._ending = !1, !0 === e && this.stop();\n        }\n      }, {\n        key: \"currentAction\",\n        value: function () {\n          return this._interacting ? this.prepared.name : null;\n        }\n      }, {\n        key: \"interacting\",\n        value: function () {\n          return this._interacting;\n        }\n      }, {\n        key: \"stop\",\n        value: function () {\n          this._scopeFire(\"interactions:stop\", {\n            interaction: this\n          }), this.interactable = this.element = null, this._interacting = !1, this._stopped = !0, this.prepared.name = this.prevEvent = null;\n        }\n      }, {\n        key: \"getPointerIndex\",\n        value: function (t) {\n          var e = X.getPointerId(t);\n          return \"mouse\" === this.pointerType || \"pen\" === this.pointerType ? this.pointers.length - 1 : H.findIndex(this.pointers, function (t) {\n            return t.id === e;\n          });\n        }\n      }, {\n        key: \"getPointerInfo\",\n        value: function (t) {\n          return this.pointers[this.getPointerIndex(t)];\n        }\n      }, {\n        key: \"updatePointer\",\n        value: function (t, e, n, r) {\n          var o = X.getPointerId(t),\n            i = this.getPointerIndex(t),\n            a = this.pointers[i];\n          return r = !1 !== r && (r || /(down|start)$/i.test(e.type)), a ? a.pointer = t : (a = new Ye.PointerInfo(o, t, e, null, null), i = this.pointers.length, this.pointers.push(a)), X.setCoords(this.coords.cur, this.pointers.map(function (t) {\n            return t.pointer;\n          }), this._now()), X.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur), r && (this.pointerIsDown = !0, a.downTime = this.coords.cur.timeStamp, a.downTarget = n, X.pointerExtend(this.downPointer, t), this.interacting() || (X.copyCoords(this.coords.start, this.coords.cur), X.copyCoords(this.coords.prev, this.coords.cur), this.downEvent = e, this.pointerWasMoved = !1)), this._updateLatestPointer(t, e, n), this._scopeFire(\"interactions:update-pointer\", {\n            pointer: t,\n            event: e,\n            eventTarget: n,\n            down: r,\n            pointerInfo: a,\n            pointerIndex: i,\n            interaction: this\n          }), i;\n        }\n      }, {\n        key: \"removePointer\",\n        value: function (t, e) {\n          var n = this.getPointerIndex(t);\n          if (-1 !== n) {\n            var r = this.pointers[n];\n            this._scopeFire(\"interactions:remove-pointer\", {\n              pointer: t,\n              event: e,\n              eventTarget: null,\n              pointerIndex: n,\n              pointerInfo: r,\n              interaction: this\n            }), this.pointers.splice(n, 1), this.pointerIsDown = !1;\n          }\n        }\n      }, {\n        key: \"_updateLatestPointer\",\n        value: function (t, e, n) {\n          this._latestPointer.pointer = t, this._latestPointer.event = e, this._latestPointer.eventTarget = n;\n        }\n      }, {\n        key: \"destroy\",\n        value: function () {\n          this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null;\n        }\n      }, {\n        key: \"_createPreparedEvent\",\n        value: function (t, e, n, r) {\n          return new Ie.InteractEvent(this, t, this.prepared.name, e, this.element, n, r);\n        }\n      }, {\n        key: \"_fireEvent\",\n        value: function (t) {\n          var e;\n          null == (e = this.interactable) || e.fire(t), (!this.prevEvent || t.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = t);\n        }\n      }, {\n        key: \"_doPhase\",\n        value: function (t) {\n          var e = t.event,\n            n = t.phase,\n            r = t.preEnd,\n            o = t.type,\n            i = this.rect;\n          if (i && \"move\" === n && (k.addEdges(this.edges, i, this.coords.delta[this.interactable.options.deltaSource]), i.width = i.right - i.left, i.height = i.bottom - i.top), !1 === this._scopeFire(\"interactions:before-action-\".concat(n), t)) return !1;\n          var a = t.iEvent = this._createPreparedEvent(e, n, r, o);\n          return this._scopeFire(\"interactions:action-\".concat(n), t), \"start\" === n && (this.prevEvent = a), this._fireEvent(a), this._scopeFire(\"interactions:after-action-\".concat(n), t), !0;\n        }\n      }, {\n        key: \"_now\",\n        value: function () {\n          return Date.now();\n        }\n      }], n && $e(e.prototype, n), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n      }), t;\n    }();\n  Ge.Interaction = Ze;\n  var Je = Ze;\n  Ge.default = Je;\n  var Qe = {};\n  function tn(t) {\n    t.pointerIsDown && (on(t.coords.cur, t.offset.total), t.offset.pending.x = 0, t.offset.pending.y = 0);\n  }\n  function en(t) {\n    nn(t.interaction);\n  }\n  function nn(t) {\n    if (!function (t) {\n      return !(!t.offset.pending.x && !t.offset.pending.y);\n    }(t)) return !1;\n    var e = t.offset.pending;\n    return on(t.coords.cur, e), on(t.coords.delta, e), k.addEdges(t.edges, t.rect, e), e.x = 0, e.y = 0, !0;\n  }\n  function rn(t) {\n    var e = t.x,\n      n = t.y;\n    this.offset.pending.x += e, this.offset.pending.y += n, this.offset.total.x += e, this.offset.total.y += n;\n  }\n  function on(t, e) {\n    var n = t.page,\n      r = t.client,\n      o = e.x,\n      i = e.y;\n    n.x += o, n.y += i, r.x += o, r.y += i;\n  }\n  Object.defineProperty(Qe, \"__esModule\", {\n    value: !0\n  }), Qe.addTotal = tn, Qe.applyPending = nn, Qe.default = void 0, Ge._ProxyMethods.offsetBy = \"\";\n  var an = {\n      id: \"offset\",\n      before: [\"modifiers\", \"pointer-events\", \"actions\", \"inertia\"],\n      install: function (t) {\n        t.Interaction.prototype.offsetBy = rn;\n      },\n      listeners: {\n        \"interactions:new\": function (t) {\n          t.interaction.offset = {\n            total: {\n              x: 0,\n              y: 0\n            },\n            pending: {\n              x: 0,\n              y: 0\n            }\n          };\n        },\n        \"interactions:update-pointer\": function (t) {\n          return tn(t.interaction);\n        },\n        \"interactions:before-action-start\": en,\n        \"interactions:before-action-move\": en,\n        \"interactions:before-action-end\": function (t) {\n          var e = t.interaction;\n          if (nn(e)) return e.move({\n            offset: !0\n          }), e.end(), !1;\n        },\n        \"interactions:stop\": function (t) {\n          var e = t.interaction;\n          e.offset.total.x = 0, e.offset.total.y = 0, e.offset.pending.x = 0, e.offset.pending.y = 0;\n        }\n      }\n    },\n    sn = an;\n  Qe.default = sn;\n  var ln = {};\n  function un(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function cn(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(ln, \"__esModule\", {\n    value: !0\n  }), ln.default = ln.InertiaState = void 0;\n  var fn = function () {\n    function t(e) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), cn(this, \"active\", !1), cn(this, \"isModified\", !1), cn(this, \"smoothEnd\", !1), cn(this, \"allowResume\", !1), cn(this, \"modification\", void 0), cn(this, \"modifierCount\", 0), cn(this, \"modifierArg\", void 0), cn(this, \"startCoords\", void 0), cn(this, \"t0\", 0), cn(this, \"v0\", 0), cn(this, \"te\", 0), cn(this, \"targetOffset\", void 0), cn(this, \"modifiedOffset\", void 0), cn(this, \"currentOffset\", void 0), cn(this, \"lambda_v0\", 0), cn(this, \"one_ve_v0\", 0), cn(this, \"timeout\", void 0), cn(this, \"interaction\", void 0), this.interaction = e;\n    }\n    var e, n;\n    return e = t, (n = [{\n      key: \"start\",\n      value: function (t) {\n        var e = this.interaction,\n          n = dn(e);\n        if (!n || !n.enabled) return !1;\n        var r = e.coords.velocity.client,\n          o = (0, R.default)(r.x, r.y),\n          i = this.modification || (this.modification = new me.default(e));\n        if (i.copyFrom(e.modification), this.t0 = e._now(), this.allowResume = n.allowResume, this.v0 = o, this.currentOffset = {\n          x: 0,\n          y: 0\n        }, this.startCoords = e.coords.cur.page, this.modifierArg = i.fillArg({\n          pageCoords: this.startCoords,\n          preEnd: !0,\n          phase: \"inertiastart\"\n        }), this.t0 - e.coords.cur.timeStamp < 50 && o > n.minSpeed && o > n.endSpeed) this.startInertia();else {\n          if (i.result = i.setAll(this.modifierArg), !i.result.changed) return !1;\n          this.startSmoothEnd();\n        }\n        return e.modification.result.rect = null, e.offsetBy(this.targetOffset), e._doPhase({\n          interaction: e,\n          event: t,\n          phase: \"inertiastart\"\n        }), e.offsetBy({\n          x: -this.targetOffset.x,\n          y: -this.targetOffset.y\n        }), e.modification.result.rect = null, this.active = !0, e.simulation = this, !0;\n      }\n    }, {\n      key: \"startInertia\",\n      value: function () {\n        var t = this,\n          e = this.interaction.coords.velocity.client,\n          n = dn(this.interaction),\n          r = n.resistance,\n          o = -Math.log(n.endSpeed / this.v0) / r;\n        this.targetOffset = {\n          x: (e.x - o) / r,\n          y: (e.y - o) / r\n        }, this.te = o, this.lambda_v0 = r / this.v0, this.one_ve_v0 = 1 - n.endSpeed / this.v0;\n        var i = this.modification,\n          a = this.modifierArg;\n        a.pageCoords = {\n          x: this.startCoords.x + this.targetOffset.x,\n          y: this.startCoords.y + this.targetOffset.y\n        }, i.result = i.setAll(a), i.result.changed && (this.isModified = !0, this.modifiedOffset = {\n          x: this.targetOffset.x + i.result.delta.x,\n          y: this.targetOffset.y + i.result.delta.y\n        }), this.onNextFrame(function () {\n          return t.inertiaTick();\n        });\n      }\n    }, {\n      key: \"startSmoothEnd\",\n      value: function () {\n        var t = this;\n        this.smoothEnd = !0, this.isModified = !0, this.targetOffset = {\n          x: this.modification.result.delta.x,\n          y: this.modification.result.delta.y\n        }, this.onNextFrame(function () {\n          return t.smoothEndTick();\n        });\n      }\n    }, {\n      key: \"onNextFrame\",\n      value: function (t) {\n        var e = this;\n        this.timeout = Tt.default.request(function () {\n          e.active && t();\n        });\n      }\n    }, {\n      key: \"inertiaTick\",\n      value: function () {\n        var t,\n          e,\n          n,\n          r,\n          o,\n          i = this,\n          a = this.interaction,\n          s = dn(a).resistance,\n          l = (a._now() - this.t0) / 1e3;\n        if (l < this.te) {\n          var u,\n            c = 1 - (Math.exp(-s * l) - this.lambda_v0) / this.one_ve_v0;\n          this.isModified ? (0, 0, t = this.targetOffset.x, e = this.targetOffset.y, n = this.modifiedOffset.x, r = this.modifiedOffset.y, u = {\n            x: vn(o = c, 0, t, n),\n            y: vn(o, 0, e, r)\n          }) : u = {\n            x: this.targetOffset.x * c,\n            y: this.targetOffset.y * c\n          };\n          var f = {\n            x: u.x - this.currentOffset.x,\n            y: u.y - this.currentOffset.y\n          };\n          this.currentOffset.x += f.x, this.currentOffset.y += f.y, a.offsetBy(f), a.move(), this.onNextFrame(function () {\n            return i.inertiaTick();\n          });\n        } else a.offsetBy({\n          x: this.modifiedOffset.x - this.currentOffset.x,\n          y: this.modifiedOffset.y - this.currentOffset.y\n        }), this.end();\n      }\n    }, {\n      key: \"smoothEndTick\",\n      value: function () {\n        var t = this,\n          e = this.interaction,\n          n = e._now() - this.t0,\n          r = dn(e).smoothEndDuration;\n        if (n < r) {\n          var o = {\n              x: hn(n, 0, this.targetOffset.x, r),\n              y: hn(n, 0, this.targetOffset.y, r)\n            },\n            i = {\n              x: o.x - this.currentOffset.x,\n              y: o.y - this.currentOffset.y\n            };\n          this.currentOffset.x += i.x, this.currentOffset.y += i.y, e.offsetBy(i), e.move({\n            skipModifiers: this.modifierCount\n          }), this.onNextFrame(function () {\n            return t.smoothEndTick();\n          });\n        } else e.offsetBy({\n          x: this.targetOffset.x - this.currentOffset.x,\n          y: this.targetOffset.y - this.currentOffset.y\n        }), this.end();\n      }\n    }, {\n      key: \"resume\",\n      value: function (t) {\n        var e = t.pointer,\n          n = t.event,\n          r = t.eventTarget,\n          o = this.interaction;\n        o.offsetBy({\n          x: -this.currentOffset.x,\n          y: -this.currentOffset.y\n        }), o.updatePointer(e, n, r, !0), o._doPhase({\n          interaction: o,\n          event: n,\n          phase: \"resume\"\n        }), (0, X.copyCoords)(o.coords.prev, o.coords.cur), this.stop();\n      }\n    }, {\n      key: \"end\",\n      value: function () {\n        this.interaction.move(), this.interaction.end(), this.stop();\n      }\n    }, {\n      key: \"stop\",\n      value: function () {\n        this.active = this.smoothEnd = !1, this.interaction.simulation = null, Tt.default.cancel(this.timeout);\n      }\n    }]) && un(e.prototype, n), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), t;\n  }();\n  function dn(t) {\n    var e = t.interactable,\n      n = t.prepared;\n    return e && e.options && n.name && e.options[n.name].inertia;\n  }\n  ln.InertiaState = fn;\n  var pn = {\n    id: \"inertia\",\n    before: [\"modifiers\", \"actions\"],\n    install: function (t) {\n      var e = t.defaults;\n      t.usePlugin(Qe.default), t.usePlugin(Se.default), t.actions.phases.inertiastart = !0, t.actions.phases.resume = !0, e.perAction.inertia = {\n        enabled: !1,\n        resistance: 10,\n        minSpeed: 100,\n        endSpeed: 10,\n        allowResume: !0,\n        smoothEndDuration: 300\n      };\n    },\n    listeners: {\n      \"interactions:new\": function (t) {\n        var e = t.interaction;\n        e.inertia = new fn(e);\n      },\n      \"interactions:before-action-end\": function (t) {\n        var e = t.interaction,\n          n = t.event;\n        return (!e._interacting || e.simulation || !e.inertia.start(n)) && null;\n      },\n      \"interactions:down\": function (t) {\n        var e = t.interaction,\n          n = t.eventTarget,\n          r = e.inertia;\n        if (r.active) for (var o = n; i.default.element(o);) {\n          if (o === e.element) {\n            r.resume(t);\n            break;\n          }\n          o = _.parentNode(o);\n        }\n      },\n      \"interactions:stop\": function (t) {\n        var e = t.interaction.inertia;\n        e.active && e.stop();\n      },\n      \"interactions:before-action-resume\": function (t) {\n        var e = t.interaction.modification;\n        e.stop(t), e.start(t, t.interaction.coords.cur.page), e.applyToInteraction(t);\n      },\n      \"interactions:before-action-inertiastart\": function (t) {\n        return t.interaction.modification.setAndApply(t);\n      },\n      \"interactions:action-resume\": Se.addEventModifiers,\n      \"interactions:action-inertiastart\": Se.addEventModifiers,\n      \"interactions:after-action-inertiastart\": function (t) {\n        return t.interaction.modification.restoreInteractionCoords(t);\n      },\n      \"interactions:after-action-resume\": function (t) {\n        return t.interaction.modification.restoreInteractionCoords(t);\n      }\n    }\n  };\n  function vn(t, e, n, r) {\n    var o = 1 - t;\n    return o * o * e + 2 * o * t * n + t * t * r;\n  }\n  function hn(t, e, n, r) {\n    return -n * (t /= r) * (t - 2) + e;\n  }\n  var gn = pn;\n  ln.default = gn;\n  var yn = {};\n  function mn(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function bn(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  function xn(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      if (t.immediatePropagationStopped) break;\n      r(t);\n    }\n  }\n  Object.defineProperty(yn, \"__esModule\", {\n    value: !0\n  }), yn.Eventable = void 0;\n  var wn = function () {\n    function t(e) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), bn(this, \"options\", void 0), bn(this, \"types\", {}), bn(this, \"propagationStopped\", !1), bn(this, \"immediatePropagationStopped\", !1), bn(this, \"global\", void 0), this.options = (0, M.default)({}, e || {});\n    }\n    var e, n;\n    return e = t, (n = [{\n      key: \"fire\",\n      value: function (t) {\n        var e,\n          n = this.global;\n        (e = this.types[t.type]) && xn(t, e), !t.propagationStopped && n && (e = n[t.type]) && xn(t, e);\n      }\n    }, {\n      key: \"on\",\n      value: function (t, e) {\n        var n = (0, z.default)(t, e);\n        for (t in n) this.types[t] = H.merge(this.types[t] || [], n[t]);\n      }\n    }, {\n      key: \"off\",\n      value: function (t, e) {\n        var n = (0, z.default)(t, e);\n        for (t in n) {\n          var r = this.types[t];\n          if (r && r.length) for (var o = 0; o < n[t].length; o++) {\n            var i = n[t][o],\n              a = r.indexOf(i);\n            -1 !== a && r.splice(a, 1);\n          }\n        }\n      }\n    }, {\n      key: \"getRect\",\n      value: function (t) {\n        return null;\n      }\n    }]) && mn(e.prototype, n), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), t;\n  }();\n  yn.Eventable = wn;\n  var _n = {};\n  Object.defineProperty(_n, \"__esModule\", {\n    value: !0\n  }), _n.default = function (t, e) {\n    if (e.phaselessTypes[t]) return !0;\n    for (var n in e.map) if (0 === t.indexOf(n) && t.substr(n.length) in e.phases) return !0;\n    return !1;\n  };\n  var Pn = {};\n  Object.defineProperty(Pn, \"__esModule\", {\n    value: !0\n  }), Pn.createInteractStatic = function (t) {\n    var e = function e(n, r) {\n      var o = t.interactables.get(n, r);\n      return o || ((o = t.interactables.new(n, r)).events.global = e.globalEvents), o;\n    };\n    return e.getPointerAverage = X.pointerAverage, e.getTouchBBox = X.touchBBox, e.getTouchDistance = X.touchDistance, e.getTouchAngle = X.touchAngle, e.getElementRect = _.getElementRect, e.getElementClientRect = _.getElementClientRect, e.matchesSelector = _.matchesSelector, e.closest = _.closest, e.globalEvents = {}, e.version = \"1.10.17\", e.scope = t, e.use = function (t, e) {\n      return this.scope.usePlugin(t, e), this;\n    }, e.isSet = function (t, e) {\n      return !!this.scope.interactables.get(t, e && e.context);\n    }, e.on = (0, Xt.warnOnce)(function (t, e, n) {\n      if (i.default.string(t) && -1 !== t.search(\" \") && (t = t.trim().split(/ +/)), i.default.array(t)) {\n        for (var r = 0; r < t.length; r++) {\n          var o = t[r];\n          this.on(o, e, n);\n        }\n        return this;\n      }\n      if (i.default.object(t)) {\n        for (var a in t) this.on(a, t[a], e);\n        return this;\n      }\n      return (0, _n.default)(t, this.scope.actions) ? this.globalEvents[t] ? this.globalEvents[t].push(e) : this.globalEvents[t] = [e] : this.scope.events.add(this.scope.document, t, e, {\n        options: n\n      }), this;\n    }, \"The interact.on() method is being deprecated\"), e.off = (0, Xt.warnOnce)(function (t, e, n) {\n      if (i.default.string(t) && -1 !== t.search(\" \") && (t = t.trim().split(/ +/)), i.default.array(t)) {\n        for (var r = 0; r < t.length; r++) {\n          var o = t[r];\n          this.off(o, e, n);\n        }\n        return this;\n      }\n      if (i.default.object(t)) {\n        for (var a in t) this.off(a, t[a], e);\n        return this;\n      }\n      var s;\n      return (0, _n.default)(t, this.scope.actions) ? t in this.globalEvents && -1 !== (s = this.globalEvents[t].indexOf(e)) && this.globalEvents[t].splice(s, 1) : this.scope.events.remove(this.scope.document, t, e, n), this;\n    }, \"The interact.off() method is being deprecated\"), e.debug = function () {\n      return this.scope;\n    }, e.supportsTouch = function () {\n      return b.default.supportsTouch;\n    }, e.supportsPointerEvent = function () {\n      return b.default.supportsPointerEvent;\n    }, e.stop = function () {\n      for (var t = 0; t < this.scope.interactions.list.length; t++) this.scope.interactions.list[t].stop();\n      return this;\n    }, e.pointerMoveTolerance = function (t) {\n      return i.default.number(t) ? (this.scope.interactions.pointerMoveTolerance = t, this) : this.scope.interactions.pointerMoveTolerance;\n    }, e.addDocument = function (t, e) {\n      this.scope.addDocument(t, e);\n    }, e.removeDocument = function (t) {\n      this.scope.removeDocument(t);\n    }, e;\n  };\n  var On = {};\n  function En(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function Sn(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(On, \"__esModule\", {\n    value: !0\n  }), On.Interactable = void 0;\n  var Tn = function () {\n    function t(n, r, o, i) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), Sn(this, \"options\", void 0), Sn(this, \"_actions\", void 0), Sn(this, \"target\", void 0), Sn(this, \"events\", new yn.Eventable()), Sn(this, \"_context\", void 0), Sn(this, \"_win\", void 0), Sn(this, \"_doc\", void 0), Sn(this, \"_scopeEvents\", void 0), Sn(this, \"_rectChecker\", void 0), this._actions = r.actions, this.target = n, this._context = r.context || o, this._win = (0, e.getWindow)((0, _.trySelector)(n) ? this._context : n), this._doc = this._win.document, this._scopeEvents = i, this.set(r);\n    }\n    var n, r;\n    return n = t, (r = [{\n      key: \"_defaults\",\n      get: function () {\n        return {\n          base: {},\n          perAction: {},\n          actions: {}\n        };\n      }\n    }, {\n      key: \"setOnEvents\",\n      value: function (t, e) {\n        return i.default.func(e.onstart) && this.on(\"\".concat(t, \"start\"), e.onstart), i.default.func(e.onmove) && this.on(\"\".concat(t, \"move\"), e.onmove), i.default.func(e.onend) && this.on(\"\".concat(t, \"end\"), e.onend), i.default.func(e.oninertiastart) && this.on(\"\".concat(t, \"inertiastart\"), e.oninertiastart), this;\n      }\n    }, {\n      key: \"updatePerActionListeners\",\n      value: function (t, e, n) {\n        (i.default.array(e) || i.default.object(e)) && this.off(t, e), (i.default.array(n) || i.default.object(n)) && this.on(t, n);\n      }\n    }, {\n      key: \"setPerAction\",\n      value: function (t, e) {\n        var n = this._defaults;\n        for (var r in e) {\n          var o = r,\n            a = this.options[t],\n            s = e[o];\n          \"listeners\" === o && this.updatePerActionListeners(t, a.listeners, s), i.default.array(s) ? a[o] = H.from(s) : i.default.plainObject(s) ? (a[o] = (0, M.default)(a[o] || {}, (0, ye.default)(s)), i.default.object(n.perAction[o]) && \"enabled\" in n.perAction[o] && (a[o].enabled = !1 !== s.enabled)) : i.default.bool(s) && i.default.object(n.perAction[o]) ? a[o].enabled = s : a[o] = s;\n        }\n      }\n    }, {\n      key: \"getRect\",\n      value: function (t) {\n        return t = t || (i.default.element(this.target) ? this.target : null), i.default.string(this.target) && (t = t || this._context.querySelector(this.target)), (0, _.getElementRect)(t);\n      }\n    }, {\n      key: \"rectChecker\",\n      value: function (t) {\n        var e = this;\n        return i.default.func(t) ? (this._rectChecker = t, this.getRect = function (t) {\n          var n = (0, M.default)({}, e._rectChecker(t));\n          return \"width\" in n || (n.width = n.right - n.left, n.height = n.bottom - n.top), n;\n        }, this) : null === t ? (delete this.getRect, delete this._rectChecker, this) : this.getRect;\n      }\n    }, {\n      key: \"_backCompatOption\",\n      value: function (t, e) {\n        if ((0, _.trySelector)(e) || i.default.object(e)) {\n          for (var n in this.options[t] = e, this._actions.map) this.options[n][t] = e;\n          return this;\n        }\n        return this.options[t];\n      }\n    }, {\n      key: \"origin\",\n      value: function (t) {\n        return this._backCompatOption(\"origin\", t);\n      }\n    }, {\n      key: \"deltaSource\",\n      value: function (t) {\n        return \"page\" === t || \"client\" === t ? (this.options.deltaSource = t, this) : this.options.deltaSource;\n      }\n    }, {\n      key: \"context\",\n      value: function () {\n        return this._context;\n      }\n    }, {\n      key: \"inContext\",\n      value: function (t) {\n        return this._context === t.ownerDocument || (0, _.nodeContains)(this._context, t);\n      }\n    }, {\n      key: \"testIgnoreAllow\",\n      value: function (t, e, n) {\n        return !this.testIgnore(t.ignoreFrom, e, n) && this.testAllow(t.allowFrom, e, n);\n      }\n    }, {\n      key: \"testAllow\",\n      value: function (t, e, n) {\n        return !t || !!i.default.element(n) && (i.default.string(t) ? (0, _.matchesUpTo)(n, t, e) : !!i.default.element(t) && (0, _.nodeContains)(t, n));\n      }\n    }, {\n      key: \"testIgnore\",\n      value: function (t, e, n) {\n        return !(!t || !i.default.element(n)) && (i.default.string(t) ? (0, _.matchesUpTo)(n, t, e) : !!i.default.element(t) && (0, _.nodeContains)(t, n));\n      }\n    }, {\n      key: \"fire\",\n      value: function (t) {\n        return this.events.fire(t), this;\n      }\n    }, {\n      key: \"_onOff\",\n      value: function (t, e, n, r) {\n        i.default.object(e) && !i.default.array(e) && (r = n, n = null);\n        var o = \"on\" === t ? \"add\" : \"remove\",\n          a = (0, z.default)(e, n);\n        for (var s in a) {\n          \"wheel\" === s && (s = b.default.wheelEvent);\n          for (var l = 0; l < a[s].length; l++) {\n            var u = a[s][l];\n            (0, _n.default)(s, this._actions) ? this.events[t](s, u) : i.default.string(this.target) ? this._scopeEvents[\"\".concat(o, \"Delegate\")](this.target, this._context, s, u, r) : this._scopeEvents[o](this.target, s, u, r);\n          }\n        }\n        return this;\n      }\n    }, {\n      key: \"on\",\n      value: function (t, e, n) {\n        return this._onOff(\"on\", t, e, n);\n      }\n    }, {\n      key: \"off\",\n      value: function (t, e, n) {\n        return this._onOff(\"off\", t, e, n);\n      }\n    }, {\n      key: \"set\",\n      value: function (t) {\n        var e = this._defaults;\n        for (var n in i.default.object(t) || (t = {}), this.options = (0, ye.default)(e.base), this._actions.methodDict) {\n          var r = n,\n            o = this._actions.methodDict[r];\n          this.options[r] = {}, this.setPerAction(r, (0, M.default)((0, M.default)({}, e.perAction), e.actions[r])), this[o](t[r]);\n        }\n        for (var a in t) i.default.func(this[a]) && this[a](t[a]);\n        return this;\n      }\n    }, {\n      key: \"unset\",\n      value: function () {\n        if (i.default.string(this.target)) for (var t in this._scopeEvents.delegatedEvents) for (var e = this._scopeEvents.delegatedEvents[t], n = e.length - 1; n >= 0; n--) {\n          var r = e[n],\n            o = r.selector,\n            a = r.context,\n            s = r.listeners;\n          o === this.target && a === this._context && e.splice(n, 1);\n          for (var l = s.length - 1; l >= 0; l--) this._scopeEvents.removeDelegate(this.target, this._context, t, s[l][0], s[l][1]);\n        } else this._scopeEvents.remove(this.target, \"all\");\n      }\n    }]) && En(n.prototype, r), Object.defineProperty(n, \"prototype\", {\n      writable: !1\n    }), t;\n  }();\n  On.Interactable = Tn;\n  var jn = {};\n  function Mn(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function kn(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(jn, \"__esModule\", {\n    value: !0\n  }), jn.InteractableSet = void 0;\n  var In = function () {\n    function t(e) {\n      var n = this;\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), kn(this, \"list\", []), kn(this, \"selectorMap\", {}), kn(this, \"scope\", void 0), this.scope = e, e.addListeners({\n        \"interactable:unset\": function (t) {\n          var e = t.interactable,\n            r = e.target,\n            o = e._context,\n            a = i.default.string(r) ? n.selectorMap[r] : r[n.scope.id],\n            s = H.findIndex(a, function (t) {\n              return t.context === o;\n            });\n          a[s] && (a[s].context = null, a[s].interactable = null), a.splice(s, 1);\n        }\n      });\n    }\n    var e, n;\n    return e = t, (n = [{\n      key: \"new\",\n      value: function (t, e) {\n        e = (0, M.default)(e || {}, {\n          actions: this.scope.actions\n        });\n        var n = new this.scope.Interactable(t, e, this.scope.document, this.scope.events),\n          r = {\n            context: n._context,\n            interactable: n\n          };\n        return this.scope.addDocument(n._doc), this.list.push(n), i.default.string(t) ? (this.selectorMap[t] || (this.selectorMap[t] = []), this.selectorMap[t].push(r)) : (n.target[this.scope.id] || Object.defineProperty(t, this.scope.id, {\n          value: [],\n          configurable: !0\n        }), t[this.scope.id].push(r)), this.scope.fire(\"interactable:new\", {\n          target: t,\n          options: e,\n          interactable: n,\n          win: this.scope._win\n        }), n;\n      }\n    }, {\n      key: \"get\",\n      value: function (t, e) {\n        var n = e && e.context || this.scope.document,\n          r = i.default.string(t),\n          o = r ? this.selectorMap[t] : t[this.scope.id];\n        if (!o) return null;\n        var a = H.find(o, function (e) {\n          return e.context === n && (r || e.interactable.inContext(t));\n        });\n        return a && a.interactable;\n      }\n    }, {\n      key: \"forEachMatch\",\n      value: function (t, e) {\n        for (var n = 0; n < this.list.length; n++) {\n          var r = this.list[n],\n            o = void 0;\n          if ((i.default.string(r.target) ? i.default.element(t) && _.matchesSelector(t, r.target) : t === r.target) && r.inContext(t) && (o = e(r)), void 0 !== o) return o;\n        }\n      }\n    }]) && Mn(e.prototype, n), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), t;\n  }();\n  jn.InteractableSet = In;\n  var Dn = {};\n  function An(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function zn(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  function Cn(t, e) {\n    return function (t) {\n      if (Array.isArray(t)) return t;\n    }(t) || function (t, e) {\n      var n = null == t ? null : \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n      if (null != n) {\n        var r,\n          o,\n          i = [],\n          a = !0,\n          s = !1;\n        try {\n          for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0);\n        } catch (t) {\n          s = !0, o = t;\n        } finally {\n          try {\n            a || null == n.return || n.return();\n          } finally {\n            if (s) throw o;\n          }\n        }\n        return i;\n      }\n    }(t, e) || function (t, e) {\n      if (t) {\n        if (\"string\" == typeof t) return Rn(t, e);\n        var n = Object.prototype.toString.call(t).slice(8, -1);\n        return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(t) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Rn(t, e) : void 0;\n      }\n    }(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n  function Rn(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n    return r;\n  }\n  Object.defineProperty(Dn, \"__esModule\", {\n    value: !0\n  }), Dn.default = void 0;\n  var Fn = function () {\n    function t(e) {\n      !function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, t), zn(this, \"currentTarget\", void 0), zn(this, \"originalEvent\", void 0), zn(this, \"type\", void 0), this.originalEvent = e, (0, F.default)(this, e);\n    }\n    var e, n;\n    return e = t, (n = [{\n      key: \"preventOriginalDefault\",\n      value: function () {\n        this.originalEvent.preventDefault();\n      }\n    }, {\n      key: \"stopPropagation\",\n      value: function () {\n        this.originalEvent.stopPropagation();\n      }\n    }, {\n      key: \"stopImmediatePropagation\",\n      value: function () {\n        this.originalEvent.stopImmediatePropagation();\n      }\n    }]) && An(e.prototype, n), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), t;\n  }();\n  function Xn(t) {\n    if (!i.default.object(t)) return {\n      capture: !!t,\n      passive: !1\n    };\n    var e = (0, M.default)({}, t);\n    return e.capture = !!t.capture, e.passive = !!t.passive, e;\n  }\n  var Bn = {\n    id: \"events\",\n    install: function (t) {\n      var e,\n        n = [],\n        r = {},\n        o = [],\n        a = {\n          add: s,\n          remove: l,\n          addDelegate: function (t, e, n, i, a) {\n            var l = Xn(a);\n            if (!r[n]) {\n              r[n] = [];\n              for (var f = 0; f < o.length; f++) {\n                var d = o[f];\n                s(d, n, u), s(d, n, c, !0);\n              }\n            }\n            var p = r[n],\n              v = H.find(p, function (n) {\n                return n.selector === t && n.context === e;\n              });\n            v || (v = {\n              selector: t,\n              context: e,\n              listeners: []\n            }, p.push(v)), v.listeners.push([i, l]);\n          },\n          removeDelegate: function (t, e, n, o, i) {\n            var a,\n              s = Xn(i),\n              f = r[n],\n              d = !1;\n            if (f) for (a = f.length - 1; a >= 0; a--) {\n              var p = f[a];\n              if (p.selector === t && p.context === e) {\n                for (var v = p.listeners, h = v.length - 1; h >= 0; h--) {\n                  var g = Cn(v[h], 2),\n                    y = g[0],\n                    m = g[1],\n                    b = m.capture,\n                    x = m.passive;\n                  if (y === o && b === s.capture && x === s.passive) {\n                    v.splice(h, 1), v.length || (f.splice(a, 1), l(e, n, u), l(e, n, c, !0)), d = !0;\n                    break;\n                  }\n                }\n                if (d) break;\n              }\n            }\n          },\n          delegateListener: u,\n          delegateUseCapture: c,\n          delegatedEvents: r,\n          documents: o,\n          targets: n,\n          supportsOptions: !1,\n          supportsPassive: !1\n        };\n      function s(t, e, r, o) {\n        var i = Xn(o),\n          s = H.find(n, function (e) {\n            return e.eventTarget === t;\n          });\n        s || (s = {\n          eventTarget: t,\n          events: {}\n        }, n.push(s)), s.events[e] || (s.events[e] = []), t.addEventListener && !H.contains(s.events[e], r) && (t.addEventListener(e, r, a.supportsOptions ? i : i.capture), s.events[e].push(r));\n      }\n      function l(t, e, r, o) {\n        var i = Xn(o),\n          s = H.findIndex(n, function (e) {\n            return e.eventTarget === t;\n          }),\n          u = n[s];\n        if (u && u.events) if (\"all\" !== e) {\n          var c = !1,\n            f = u.events[e];\n          if (f) {\n            if (\"all\" === r) {\n              for (var d = f.length - 1; d >= 0; d--) l(t, e, f[d], i);\n              return;\n            }\n            for (var p = 0; p < f.length; p++) if (f[p] === r) {\n              t.removeEventListener(e, r, a.supportsOptions ? i : i.capture), f.splice(p, 1), 0 === f.length && (delete u.events[e], c = !0);\n              break;\n            }\n          }\n          c && !Object.keys(u.events).length && n.splice(s, 1);\n        } else for (e in u.events) u.events.hasOwnProperty(e) && l(t, e, \"all\");\n      }\n      function u(t, e) {\n        for (var n = Xn(e), o = new Fn(t), a = r[t.type], s = Cn(X.getEventTargets(t), 1)[0], l = s; i.default.element(l);) {\n          for (var u = 0; u < a.length; u++) {\n            var c = a[u],\n              f = c.selector,\n              d = c.context;\n            if (_.matchesSelector(l, f) && _.nodeContains(d, s) && _.nodeContains(d, l)) {\n              var p = c.listeners;\n              o.currentTarget = l;\n              for (var v = 0; v < p.length; v++) {\n                var h = Cn(p[v], 2),\n                  g = h[0],\n                  y = h[1],\n                  m = y.capture,\n                  b = y.passive;\n                m === n.capture && b === n.passive && g(o);\n              }\n            }\n          }\n          l = _.parentNode(l);\n        }\n      }\n      function c(t) {\n        return u(t, !0);\n      }\n      return null == (e = t.document) || e.createElement(\"div\").addEventListener(\"test\", null, {\n        get capture() {\n          return a.supportsOptions = !0;\n        },\n        get passive() {\n          return a.supportsPassive = !0;\n        }\n      }), t.events = a, a;\n    }\n  };\n  Dn.default = Bn;\n  var Yn = {};\n  Object.defineProperty(Yn, \"__esModule\", {\n    value: !0\n  }), Yn.default = void 0;\n  var Wn = {\n    methodOrder: [\"simulationResume\", \"mouseOrPen\", \"hasPointer\", \"idle\"],\n    search: function (t) {\n      for (var e = 0; e < Wn.methodOrder.length; e++) {\n        var n;\n        n = Wn.methodOrder[e];\n        var r = Wn[n](t);\n        if (r) return r;\n      }\n      return null;\n    },\n    simulationResume: function (t) {\n      var e = t.pointerType,\n        n = t.eventType,\n        r = t.eventTarget,\n        o = t.scope;\n      if (!/down|start/i.test(n)) return null;\n      for (var i = 0; i < o.interactions.list.length; i++) {\n        var a = o.interactions.list[i],\n          s = r;\n        if (a.simulation && a.simulation.allowResume && a.pointerType === e) for (; s;) {\n          if (s === a.element) return a;\n          s = _.parentNode(s);\n        }\n      }\n      return null;\n    },\n    mouseOrPen: function (t) {\n      var e,\n        n = t.pointerId,\n        r = t.pointerType,\n        o = t.eventType,\n        i = t.scope;\n      if (\"mouse\" !== r && \"pen\" !== r) return null;\n      for (var a = 0; a < i.interactions.list.length; a++) {\n        var s = i.interactions.list[a];\n        if (s.pointerType === r) {\n          if (s.simulation && !Ln(s, n)) continue;\n          if (s.interacting()) return s;\n          e || (e = s);\n        }\n      }\n      if (e) return e;\n      for (var l = 0; l < i.interactions.list.length; l++) {\n        var u = i.interactions.list[l];\n        if (!(u.pointerType !== r || /down/i.test(o) && u.simulation)) return u;\n      }\n      return null;\n    },\n    hasPointer: function (t) {\n      for (var e = t.pointerId, n = t.scope, r = 0; r < n.interactions.list.length; r++) {\n        var o = n.interactions.list[r];\n        if (Ln(o, e)) return o;\n      }\n      return null;\n    },\n    idle: function (t) {\n      for (var e = t.pointerType, n = t.scope, r = 0; r < n.interactions.list.length; r++) {\n        var o = n.interactions.list[r];\n        if (1 === o.pointers.length) {\n          var i = o.interactable;\n          if (i && (!i.options.gesture || !i.options.gesture.enabled)) continue;\n        } else if (o.pointers.length >= 2) continue;\n        if (!o.interacting() && e === o.pointerType) return o;\n      }\n      return null;\n    }\n  };\n  function Ln(t, e) {\n    return t.pointers.some(function (t) {\n      return t.id === e;\n    });\n  }\n  var Un = Wn;\n  Yn.default = Un;\n  var Vn = {};\n  function Nn(t) {\n    return Nn = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    }, Nn(t);\n  }\n  function qn(t, e) {\n    return function (t) {\n      if (Array.isArray(t)) return t;\n    }(t) || function (t, e) {\n      var n = null == t ? null : \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n      if (null != n) {\n        var r,\n          o,\n          i = [],\n          a = !0,\n          s = !1;\n        try {\n          for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0);\n        } catch (t) {\n          s = !0, o = t;\n        } finally {\n          try {\n            a || null == n.return || n.return();\n          } finally {\n            if (s) throw o;\n          }\n        }\n        return i;\n      }\n    }(t, e) || function (t, e) {\n      if (t) {\n        if (\"string\" == typeof t) return Gn(t, e);\n        var n = Object.prototype.toString.call(t).slice(8, -1);\n        return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(t) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Gn(t, e) : void 0;\n      }\n    }(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n  function Gn(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n    return r;\n  }\n  function $n(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function Hn(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function Kn(t, e) {\n    return Kn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, Kn(t, e);\n  }\n  function Zn(t, e) {\n    if (e && (\"object\" === Nn(e) || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return function (t) {\n      if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    }(t);\n  }\n  function Jn(t) {\n    return Jn = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, Jn(t);\n  }\n  Object.defineProperty(Vn, \"__esModule\", {\n    value: !0\n  }), Vn.default = void 0;\n  var Qn = [\"pointerDown\", \"pointerMove\", \"pointerUp\", \"updatePointer\", \"removePointer\", \"windowBlur\"];\n  function tr(t, e) {\n    return function (n) {\n      var r = e.interactions.list,\n        o = X.getPointerType(n),\n        i = qn(X.getEventTargets(n), 2),\n        a = i[0],\n        s = i[1],\n        l = [];\n      if (/^touch/.test(n.type)) {\n        e.prevTouchTime = e.now();\n        for (var u = 0; u < n.changedTouches.length; u++) {\n          var c = n.changedTouches[u],\n            f = {\n              pointer: c,\n              pointerId: X.getPointerId(c),\n              pointerType: o,\n              eventType: n.type,\n              eventTarget: a,\n              curEventTarget: s,\n              scope: e\n            },\n            d = er(f);\n          l.push([f.pointer, f.eventTarget, f.curEventTarget, d]);\n        }\n      } else {\n        var p = !1;\n        if (!b.default.supportsPointerEvent && /mouse/.test(n.type)) {\n          for (var v = 0; v < r.length && !p; v++) p = \"mouse\" !== r[v].pointerType && r[v].pointerIsDown;\n          p = p || e.now() - e.prevTouchTime < 500 || 0 === n.timeStamp;\n        }\n        if (!p) {\n          var h = {\n              pointer: n,\n              pointerId: X.getPointerId(n),\n              pointerType: o,\n              eventType: n.type,\n              curEventTarget: s,\n              eventTarget: a,\n              scope: e\n            },\n            g = er(h);\n          l.push([h.pointer, h.eventTarget, h.curEventTarget, g]);\n        }\n      }\n      for (var y = 0; y < l.length; y++) {\n        var m = qn(l[y], 4),\n          x = m[0],\n          w = m[1],\n          _ = m[2];\n        m[3][t](x, n, w, _);\n      }\n    };\n  }\n  function er(t) {\n    var e = t.pointerType,\n      n = t.scope,\n      r = {\n        interaction: Yn.default.search(t),\n        searchDetails: t\n      };\n    return n.fire(\"interactions:find\", r), r.interaction || n.interactions.new({\n      pointerType: e\n    });\n  }\n  function nr(t, e) {\n    var n = t.doc,\n      r = t.scope,\n      o = t.options,\n      i = r.interactions.docEvents,\n      a = r.events,\n      s = a[e];\n    for (var l in r.browser.isIOS && !o.events && (o.events = {\n      passive: !1\n    }), a.delegatedEvents) s(n, l, a.delegateListener), s(n, l, a.delegateUseCapture, !0);\n    for (var u = o && o.events, c = 0; c < i.length; c++) {\n      var f = i[c];\n      s(n, f.type, f.listener, u);\n    }\n  }\n  var rr = {\n      id: \"core/interactions\",\n      install: function (t) {\n        for (var e = {}, n = 0; n < Qn.length; n++) {\n          var r = Qn[n];\n          e[r] = tr(r, t);\n        }\n        var o,\n          i = b.default.pEventTypes;\n        function a() {\n          for (var e = 0; e < t.interactions.list.length; e++) {\n            var n = t.interactions.list[e];\n            if (n.pointerIsDown && \"touch\" === n.pointerType && !n._interacting) for (var r = function () {\n                var e = n.pointers[o];\n                t.documents.some(function (t) {\n                  var n = t.doc;\n                  return (0, _.nodeContains)(n, e.downTarget);\n                }) || n.removePointer(e.pointer, e.event);\n              }, o = 0; o < n.pointers.length; o++) r();\n          }\n        }\n        (o = h.default.PointerEvent ? [{\n          type: i.down,\n          listener: a\n        }, {\n          type: i.down,\n          listener: e.pointerDown\n        }, {\n          type: i.move,\n          listener: e.pointerMove\n        }, {\n          type: i.up,\n          listener: e.pointerUp\n        }, {\n          type: i.cancel,\n          listener: e.pointerUp\n        }] : [{\n          type: \"mousedown\",\n          listener: e.pointerDown\n        }, {\n          type: \"mousemove\",\n          listener: e.pointerMove\n        }, {\n          type: \"mouseup\",\n          listener: e.pointerUp\n        }, {\n          type: \"touchstart\",\n          listener: a\n        }, {\n          type: \"touchstart\",\n          listener: e.pointerDown\n        }, {\n          type: \"touchmove\",\n          listener: e.pointerMove\n        }, {\n          type: \"touchend\",\n          listener: e.pointerUp\n        }, {\n          type: \"touchcancel\",\n          listener: e.pointerUp\n        }]).push({\n          type: \"blur\",\n          listener: function (e) {\n            for (var n = 0; n < t.interactions.list.length; n++) t.interactions.list[n].documentBlur(e);\n          }\n        }), t.prevTouchTime = 0, t.Interaction = function (e) {\n          !function (t, e) {\n            if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n            t.prototype = Object.create(e && e.prototype, {\n              constructor: {\n                value: t,\n                writable: !0,\n                configurable: !0\n              }\n            }), Object.defineProperty(t, \"prototype\", {\n              writable: !1\n            }), e && Kn(t, e);\n          }(s, e);\n          var n,\n            r,\n            o,\n            i,\n            a = (o = s, i = function () {\n              if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n              if (Reflect.construct.sham) return !1;\n              if (\"function\" == typeof Proxy) return !0;\n              try {\n                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n              } catch (t) {\n                return !1;\n              }\n            }(), function () {\n              var t,\n                e = Jn(o);\n              if (i) {\n                var n = Jn(this).constructor;\n                t = Reflect.construct(e, arguments, n);\n              } else t = e.apply(this, arguments);\n              return Zn(this, t);\n            });\n          function s() {\n            return $n(this, s), a.apply(this, arguments);\n          }\n          return n = s, (r = [{\n            key: \"pointerMoveTolerance\",\n            get: function () {\n              return t.interactions.pointerMoveTolerance;\n            },\n            set: function (e) {\n              t.interactions.pointerMoveTolerance = e;\n            }\n          }, {\n            key: \"_now\",\n            value: function () {\n              return t.now();\n            }\n          }]) && Hn(n.prototype, r), Object.defineProperty(n, \"prototype\", {\n            writable: !1\n          }), s;\n        }(Ge.default), t.interactions = {\n          list: [],\n          new: function (e) {\n            e.scopeFire = function (e, n) {\n              return t.fire(e, n);\n            };\n            var n = new t.Interaction(e);\n            return t.interactions.list.push(n), n;\n          },\n          listeners: e,\n          docEvents: o,\n          pointerMoveTolerance: 1\n        }, t.usePlugin(le.default);\n      },\n      listeners: {\n        \"scope:add-document\": function (t) {\n          return nr(t, \"add\");\n        },\n        \"scope:remove-document\": function (t) {\n          return nr(t, \"remove\");\n        },\n        \"interactable:unset\": function (t, e) {\n          for (var n = t.interactable, r = e.interactions.list.length - 1; r >= 0; r--) {\n            var o = e.interactions.list[r];\n            o.interactable === n && (o.stop(), e.fire(\"interactions:destroy\", {\n              interaction: o\n            }), o.destroy(), e.interactions.list.length > 2 && e.interactions.list.splice(r, 1));\n          }\n        }\n      },\n      onDocSignal: nr,\n      doOnInteractions: tr,\n      methodNames: Qn\n    },\n    or = rr;\n  Vn.default = or;\n  var ir = {};\n  function ar(t) {\n    return ar = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    }, ar(t);\n  }\n  function sr() {\n    return sr = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (t, e, n) {\n      var r = lr(t, e);\n      if (r) {\n        var o = Object.getOwnPropertyDescriptor(r, e);\n        return o.get ? o.get.call(arguments.length < 3 ? t : n) : o.value;\n      }\n    }, sr.apply(this, arguments);\n  }\n  function lr(t, e) {\n    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = fr(t)););\n    return t;\n  }\n  function ur(t, e) {\n    return ur = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, ur(t, e);\n  }\n  function cr(t, e) {\n    if (e && (\"object\" === ar(e) || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return function (t) {\n      if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return t;\n    }(t);\n  }\n  function fr(t) {\n    return fr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, fr(t);\n  }\n  function dr(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function pr(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function vr(t, e, n) {\n    return e && pr(t.prototype, e), n && pr(t, n), Object.defineProperty(t, \"prototype\", {\n      writable: !1\n    }), t;\n  }\n  function hr(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(ir, \"__esModule\", {\n    value: !0\n  }), ir.Scope = void 0, ir.initScope = yr;\n  var gr = function () {\n    function t() {\n      var e = this;\n      dr(this, t), hr(this, \"id\", \"__interact_scope_\".concat(Math.floor(100 * Math.random()))), hr(this, \"isInitialized\", !1), hr(this, \"listenerMaps\", []), hr(this, \"browser\", b.default), hr(this, \"defaults\", (0, ye.default)(ke.defaults)), hr(this, \"Eventable\", yn.Eventable), hr(this, \"actions\", {\n        map: {},\n        phases: {\n          start: !0,\n          move: !0,\n          end: !0\n        },\n        methodDict: {},\n        phaselessTypes: {}\n      }), hr(this, \"interactStatic\", (0, Pn.createInteractStatic)(this)), hr(this, \"InteractEvent\", Ie.InteractEvent), hr(this, \"Interactable\", void 0), hr(this, \"interactables\", new jn.InteractableSet(this)), hr(this, \"_win\", void 0), hr(this, \"document\", void 0), hr(this, \"window\", void 0), hr(this, \"documents\", []), hr(this, \"_plugins\", {\n        list: [],\n        map: {}\n      }), hr(this, \"onWindowUnload\", function (t) {\n        return e.removeDocument(t.target);\n      });\n      var n = this;\n      this.Interactable = function (t) {\n        !function (t, e) {\n          if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n          t.prototype = Object.create(e && e.prototype, {\n            constructor: {\n              value: t,\n              writable: !0,\n              configurable: !0\n            }\n          }), Object.defineProperty(t, \"prototype\", {\n            writable: !1\n          }), e && ur(t, e);\n        }(i, t);\n        var e,\n          r,\n          o = (e = i, r = function () {\n            if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n            if (Reflect.construct.sham) return !1;\n            if (\"function\" == typeof Proxy) return !0;\n            try {\n              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n            } catch (t) {\n              return !1;\n            }\n          }(), function () {\n            var t,\n              n = fr(e);\n            if (r) {\n              var o = fr(this).constructor;\n              t = Reflect.construct(n, arguments, o);\n            } else t = n.apply(this, arguments);\n            return cr(this, t);\n          });\n        function i() {\n          return dr(this, i), o.apply(this, arguments);\n        }\n        return vr(i, [{\n          key: \"_defaults\",\n          get: function () {\n            return n.defaults;\n          }\n        }, {\n          key: \"set\",\n          value: function (t) {\n            return sr(fr(i.prototype), \"set\", this).call(this, t), n.fire(\"interactable:set\", {\n              options: t,\n              interactable: this\n            }), this;\n          }\n        }, {\n          key: \"unset\",\n          value: function () {\n            sr(fr(i.prototype), \"unset\", this).call(this);\n            var t = n.interactables.list.indexOf(this);\n            t < 0 || (sr(fr(i.prototype), \"unset\", this).call(this), n.interactables.list.splice(t, 1), n.fire(\"interactable:unset\", {\n              interactable: this\n            }));\n          }\n        }]), i;\n      }(On.Interactable);\n    }\n    return vr(t, [{\n      key: \"addListeners\",\n      value: function (t, e) {\n        this.listenerMaps.push({\n          id: e,\n          map: t\n        });\n      }\n    }, {\n      key: \"fire\",\n      value: function (t, e) {\n        for (var n = 0; n < this.listenerMaps.length; n++) {\n          var r = this.listenerMaps[n].map[t];\n          if (r && !1 === r(e, this, t)) return !1;\n        }\n      }\n    }, {\n      key: \"init\",\n      value: function (t) {\n        return this.isInitialized ? this : yr(this, t);\n      }\n    }, {\n      key: \"pluginIsInstalled\",\n      value: function (t) {\n        return this._plugins.map[t.id] || -1 !== this._plugins.list.indexOf(t);\n      }\n    }, {\n      key: \"usePlugin\",\n      value: function (t, e) {\n        if (!this.isInitialized) return this;\n        if (this.pluginIsInstalled(t)) return this;\n        if (t.id && (this._plugins.map[t.id] = t), this._plugins.list.push(t), t.install && t.install(this, e), t.listeners && t.before) {\n          for (var n = 0, r = this.listenerMaps.length, o = t.before.reduce(function (t, e) {\n              return t[e] = !0, t[mr(e)] = !0, t;\n            }, {}); n < r; n++) {\n            var i = this.listenerMaps[n].id;\n            if (o[i] || o[mr(i)]) break;\n          }\n          this.listenerMaps.splice(n, 0, {\n            id: t.id,\n            map: t.listeners\n          });\n        } else t.listeners && this.listenerMaps.push({\n          id: t.id,\n          map: t.listeners\n        });\n        return this;\n      }\n    }, {\n      key: \"addDocument\",\n      value: function (t, n) {\n        if (-1 !== this.getDocIndex(t)) return !1;\n        var r = e.getWindow(t);\n        n = n ? (0, M.default)({}, n) : {}, this.documents.push({\n          doc: t,\n          options: n\n        }), this.events.documents.push(t), t !== this.document && this.events.add(r, \"unload\", this.onWindowUnload), this.fire(\"scope:add-document\", {\n          doc: t,\n          window: r,\n          scope: this,\n          options: n\n        });\n      }\n    }, {\n      key: \"removeDocument\",\n      value: function (t) {\n        var n = this.getDocIndex(t),\n          r = e.getWindow(t),\n          o = this.documents[n].options;\n        this.events.remove(r, \"unload\", this.onWindowUnload), this.documents.splice(n, 1), this.events.documents.splice(n, 1), this.fire(\"scope:remove-document\", {\n          doc: t,\n          window: r,\n          scope: this,\n          options: o\n        });\n      }\n    }, {\n      key: \"getDocIndex\",\n      value: function (t) {\n        for (var e = 0; e < this.documents.length; e++) if (this.documents[e].doc === t) return e;\n        return -1;\n      }\n    }, {\n      key: \"getDocOptions\",\n      value: function (t) {\n        var e = this.getDocIndex(t);\n        return -1 === e ? null : this.documents[e].options;\n      }\n    }, {\n      key: \"now\",\n      value: function () {\n        return (this.window.Date || Date).now();\n      }\n    }]), t;\n  }();\n  function yr(t, n) {\n    return t.isInitialized = !0, i.default.window(n) && e.init(n), h.default.init(n), b.default.init(n), Tt.default.init(n), t.window = n, t.document = n.document, t.usePlugin(Vn.default), t.usePlugin(Dn.default), t;\n  }\n  function mr(t) {\n    return t && t.replace(/\\/.*$/, \"\");\n  }\n  ir.Scope = gr;\n  var br = {};\n  Object.defineProperty(br, \"__esModule\", {\n    value: !0\n  }), br.default = void 0;\n  var xr = new ir.Scope(),\n    wr = xr.interactStatic;\n  br.default = wr;\n  var _r = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : void 0;\n  xr.init(_r);\n  var Pr = {};\n  Object.defineProperty(Pr, \"__esModule\", {\n    value: !0\n  }), Pr.default = void 0, Pr.default = function () {};\n  var Or = {};\n  Object.defineProperty(Or, \"__esModule\", {\n    value: !0\n  }), Or.default = void 0, Or.default = function () {};\n  var Er = {};\n  function Sr(t, e) {\n    return function (t) {\n      if (Array.isArray(t)) return t;\n    }(t) || function (t, e) {\n      var n = null == t ? null : \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n      if (null != n) {\n        var r,\n          o,\n          i = [],\n          a = !0,\n          s = !1;\n        try {\n          for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0);\n        } catch (t) {\n          s = !0, o = t;\n        } finally {\n          try {\n            a || null == n.return || n.return();\n          } finally {\n            if (s) throw o;\n          }\n        }\n        return i;\n      }\n    }(t, e) || function (t, e) {\n      if (t) {\n        if (\"string\" == typeof t) return Tr(t, e);\n        var n = Object.prototype.toString.call(t).slice(8, -1);\n        return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(t) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Tr(t, e) : void 0;\n      }\n    }(t, e) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }();\n  }\n  function Tr(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n    return r;\n  }\n  Object.defineProperty(Er, \"__esModule\", {\n    value: !0\n  }), Er.default = void 0, Er.default = function (t) {\n    var e = [[\"x\", \"y\"], [\"left\", \"top\"], [\"right\", \"bottom\"], [\"width\", \"height\"]].filter(function (e) {\n        var n = Sr(e, 2),\n          r = n[0],\n          o = n[1];\n        return r in t || o in t;\n      }),\n      n = function (n, r) {\n        for (var o = t.range, i = t.limits, a = void 0 === i ? {\n            left: -1 / 0,\n            right: 1 / 0,\n            top: -1 / 0,\n            bottom: 1 / 0\n          } : i, s = t.offset, l = void 0 === s ? {\n            x: 0,\n            y: 0\n          } : s, u = {\n            range: o,\n            grid: t,\n            x: null,\n            y: null\n          }, c = 0; c < e.length; c++) {\n          var f = Sr(e[c], 2),\n            d = f[0],\n            p = f[1],\n            v = Math.round((n - l.x) / t[d]),\n            h = Math.round((r - l.y) / t[p]);\n          u[d] = Math.max(a.left, Math.min(a.right, v * t[d] + l.x)), u[p] = Math.max(a.top, Math.min(a.bottom, h * t[p] + l.y));\n        }\n        return u;\n      };\n    return n.grid = t, n.coordFields = e, n;\n  };\n  var jr = {};\n  Object.defineProperty(jr, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(jr, \"edgeTarget\", {\n    enumerable: !0,\n    get: function () {\n      return Pr.default;\n    }\n  }), Object.defineProperty(jr, \"elements\", {\n    enumerable: !0,\n    get: function () {\n      return Or.default;\n    }\n  }), Object.defineProperty(jr, \"grid\", {\n    enumerable: !0,\n    get: function () {\n      return Er.default;\n    }\n  });\n  var Mr = {};\n  Object.defineProperty(Mr, \"__esModule\", {\n    value: !0\n  }), Mr.default = void 0;\n  var kr = {\n      id: \"snappers\",\n      install: function (t) {\n        var e = t.interactStatic;\n        e.snappers = (0, M.default)(e.snappers || {}, jr), e.createSnapGrid = e.snappers.grid;\n      }\n    },\n    Ir = kr;\n  Mr.default = Ir;\n  var Dr = {};\n  function Ar(t, e) {\n    var n = Object.keys(t);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(t);\n      e && (r = r.filter(function (e) {\n        return Object.getOwnPropertyDescriptor(t, e).enumerable;\n      })), n.push.apply(n, r);\n    }\n    return n;\n  }\n  function zr(t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = null != arguments[e] ? arguments[e] : {};\n      e % 2 ? Ar(Object(n), !0).forEach(function (e) {\n        Cr(t, e, n[e]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Ar(Object(n)).forEach(function (e) {\n        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e));\n      });\n    }\n    return t;\n  }\n  function Cr(t, e, n) {\n    return e in t ? Object.defineProperty(t, e, {\n      value: n,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : t[e] = n, t;\n  }\n  Object.defineProperty(Dr, \"__esModule\", {\n    value: !0\n  }), Dr.default = Dr.aspectRatio = void 0;\n  var Rr = {\n    start: function (t) {\n      var e = t.state,\n        n = t.rect,\n        r = t.edges,\n        o = t.pageCoords,\n        i = e.options.ratio,\n        a = e.options,\n        s = a.equalDelta,\n        l = a.modifiers;\n      \"preserve\" === i && (i = n.width / n.height), e.startCoords = (0, M.default)({}, o), e.startRect = (0, M.default)({}, n), e.ratio = i, e.equalDelta = s;\n      var u = e.linkedEdges = {\n        top: r.top || r.left && !r.bottom,\n        left: r.left || r.top && !r.right,\n        bottom: r.bottom || r.right && !r.top,\n        right: r.right || r.bottom && !r.left\n      };\n      if (e.xIsPrimaryAxis = !(!r.left && !r.right), e.equalDelta) {\n        var c = (u.left ? 1 : -1) * (u.top ? 1 : -1);\n        e.edgeSign = {\n          x: c,\n          y: c\n        };\n      } else e.edgeSign = {\n        x: u.left ? -1 : 1,\n        y: u.top ? -1 : 1\n      };\n      if ((0, M.default)(t.edges, u), l && l.length) {\n        var f = new me.default(t.interaction);\n        f.copyFrom(t.interaction.modification), f.prepareStates(l), e.subModification = f, f.startAll(zr({}, t));\n      }\n    },\n    set: function (t) {\n      var e = t.state,\n        n = t.rect,\n        r = t.coords,\n        o = (0, M.default)({}, r),\n        i = e.equalDelta ? Fr : Xr;\n      if (i(e, e.xIsPrimaryAxis, r, n), !e.subModification) return null;\n      var a = (0, M.default)({}, n);\n      (0, k.addEdges)(e.linkedEdges, a, {\n        x: r.x - o.x,\n        y: r.y - o.y\n      });\n      var s = e.subModification.setAll(zr(zr({}, t), {}, {\n          rect: a,\n          edges: e.linkedEdges,\n          pageCoords: r,\n          prevCoords: r,\n          prevRect: a\n        })),\n        l = s.delta;\n      return s.changed && (i(e, Math.abs(l.x) > Math.abs(l.y), s.coords, s.rect), (0, M.default)(r, s.coords)), s.eventProps;\n    },\n    defaults: {\n      ratio: \"preserve\",\n      equalDelta: !1,\n      modifiers: [],\n      enabled: !1\n    }\n  };\n  function Fr(t, e, n) {\n    var r = t.startCoords,\n      o = t.edgeSign;\n    e ? n.y = r.y + (n.x - r.x) * o.y : n.x = r.x + (n.y - r.y) * o.x;\n  }\n  function Xr(t, e, n, r) {\n    var o = t.startRect,\n      i = t.startCoords,\n      a = t.ratio,\n      s = t.edgeSign;\n    if (e) {\n      var l = r.width / a;\n      n.y = i.y + (l - o.height) * s.y;\n    } else {\n      var u = r.height * a;\n      n.x = i.x + (u - o.width) * s.x;\n    }\n  }\n  Dr.aspectRatio = Rr;\n  var Br = (0, Se.makeModifier)(Rr, \"aspectRatio\");\n  Dr.default = Br;\n  var Yr = {};\n  Object.defineProperty(Yr, \"__esModule\", {\n    value: !0\n  }), Yr.default = void 0;\n  var Wr = function () {};\n  Wr._defaults = {};\n  var Lr = Wr;\n  Yr.default = Lr;\n  var Ur = {};\n  Object.defineProperty(Ur, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(Ur, \"default\", {\n    enumerable: !0,\n    get: function () {\n      return Yr.default;\n    }\n  });\n  var Vr = {};\n  function Nr(t, e, n) {\n    return i.default.func(t) ? k.resolveRectLike(t, e.interactable, e.element, [n.x, n.y, e]) : k.resolveRectLike(t, e.interactable, e.element);\n  }\n  Object.defineProperty(Vr, \"__esModule\", {\n    value: !0\n  }), Vr.default = void 0, Vr.getRestrictionRect = Nr, Vr.restrict = void 0;\n  var qr = {\n    start: function (t) {\n      var e = t.rect,\n        n = t.startOffset,\n        r = t.state,\n        o = t.interaction,\n        i = t.pageCoords,\n        a = r.options,\n        s = a.elementRect,\n        l = (0, M.default)({\n          left: 0,\n          top: 0,\n          right: 0,\n          bottom: 0\n        }, a.offset || {});\n      if (e && s) {\n        var u = Nr(a.restriction, o, i);\n        if (u) {\n          var c = u.right - u.left - e.width,\n            f = u.bottom - u.top - e.height;\n          c < 0 && (l.left += c, l.right += c), f < 0 && (l.top += f, l.bottom += f);\n        }\n        l.left += n.left - e.width * s.left, l.top += n.top - e.height * s.top, l.right += n.right - e.width * (1 - s.right), l.bottom += n.bottom - e.height * (1 - s.bottom);\n      }\n      r.offset = l;\n    },\n    set: function (t) {\n      var e = t.coords,\n        n = t.interaction,\n        r = t.state,\n        o = r.options,\n        i = r.offset,\n        a = Nr(o.restriction, n, e);\n      if (a) {\n        var s = k.xywhToTlbr(a);\n        e.x = Math.max(Math.min(s.right - i.right, e.x), s.left + i.left), e.y = Math.max(Math.min(s.bottom - i.bottom, e.y), s.top + i.top);\n      }\n    },\n    defaults: {\n      restriction: null,\n      elementRect: null,\n      offset: null,\n      endOnly: !1,\n      enabled: !1\n    }\n  };\n  Vr.restrict = qr;\n  var Gr = (0, Se.makeModifier)(qr, \"restrict\");\n  Vr.default = Gr;\n  var $r = {};\n  Object.defineProperty($r, \"__esModule\", {\n    value: !0\n  }), $r.restrictEdges = $r.default = void 0;\n  var Hr = {\n      top: 1 / 0,\n      left: 1 / 0,\n      bottom: -1 / 0,\n      right: -1 / 0\n    },\n    Kr = {\n      top: -1 / 0,\n      left: -1 / 0,\n      bottom: 1 / 0,\n      right: 1 / 0\n    };\n  function Zr(t, e) {\n    for (var n = [\"top\", \"left\", \"bottom\", \"right\"], r = 0; r < n.length; r++) {\n      var o = n[r];\n      o in t || (t[o] = e[o]);\n    }\n    return t;\n  }\n  var Jr = {\n    noInner: Hr,\n    noOuter: Kr,\n    start: function (t) {\n      var e,\n        n = t.interaction,\n        r = t.startOffset,\n        o = t.state,\n        i = o.options;\n      if (i) {\n        var a = (0, Vr.getRestrictionRect)(i.offset, n, n.coords.start.page);\n        e = k.rectToXY(a);\n      }\n      e = e || {\n        x: 0,\n        y: 0\n      }, o.offset = {\n        top: e.y + r.top,\n        left: e.x + r.left,\n        bottom: e.y - r.bottom,\n        right: e.x - r.right\n      };\n    },\n    set: function (t) {\n      var e = t.coords,\n        n = t.edges,\n        r = t.interaction,\n        o = t.state,\n        i = o.offset,\n        a = o.options;\n      if (n) {\n        var s = (0, M.default)({}, e),\n          l = (0, Vr.getRestrictionRect)(a.inner, r, s) || {},\n          u = (0, Vr.getRestrictionRect)(a.outer, r, s) || {};\n        Zr(l, Hr), Zr(u, Kr), n.top ? e.y = Math.min(Math.max(u.top + i.top, s.y), l.top + i.top) : n.bottom && (e.y = Math.max(Math.min(u.bottom + i.bottom, s.y), l.bottom + i.bottom)), n.left ? e.x = Math.min(Math.max(u.left + i.left, s.x), l.left + i.left) : n.right && (e.x = Math.max(Math.min(u.right + i.right, s.x), l.right + i.right));\n      }\n    },\n    defaults: {\n      inner: null,\n      outer: null,\n      offset: null,\n      endOnly: !1,\n      enabled: !1\n    }\n  };\n  $r.restrictEdges = Jr;\n  var Qr = (0, Se.makeModifier)(Jr, \"restrictEdges\");\n  $r.default = Qr;\n  var to = {};\n  Object.defineProperty(to, \"__esModule\", {\n    value: !0\n  }), to.restrictRect = to.default = void 0;\n  var eo = (0, M.default)({\n      get elementRect() {\n        return {\n          top: 0,\n          left: 0,\n          bottom: 1,\n          right: 1\n        };\n      },\n      set elementRect(t) {}\n    }, Vr.restrict.defaults),\n    no = {\n      start: Vr.restrict.start,\n      set: Vr.restrict.set,\n      defaults: eo\n    };\n  to.restrictRect = no;\n  var ro = (0, Se.makeModifier)(no, \"restrictRect\");\n  to.default = ro;\n  var oo = {};\n  Object.defineProperty(oo, \"__esModule\", {\n    value: !0\n  }), oo.restrictSize = oo.default = void 0;\n  var io = {\n      width: -1 / 0,\n      height: -1 / 0\n    },\n    ao = {\n      width: 1 / 0,\n      height: 1 / 0\n    },\n    so = {\n      start: function (t) {\n        return $r.restrictEdges.start(t);\n      },\n      set: function (t) {\n        var e = t.interaction,\n          n = t.state,\n          r = t.rect,\n          o = t.edges,\n          i = n.options;\n        if (o) {\n          var a = k.tlbrToXywh((0, Vr.getRestrictionRect)(i.min, e, t.coords)) || io,\n            s = k.tlbrToXywh((0, Vr.getRestrictionRect)(i.max, e, t.coords)) || ao;\n          n.options = {\n            endOnly: i.endOnly,\n            inner: (0, M.default)({}, $r.restrictEdges.noInner),\n            outer: (0, M.default)({}, $r.restrictEdges.noOuter)\n          }, o.top ? (n.options.inner.top = r.bottom - a.height, n.options.outer.top = r.bottom - s.height) : o.bottom && (n.options.inner.bottom = r.top + a.height, n.options.outer.bottom = r.top + s.height), o.left ? (n.options.inner.left = r.right - a.width, n.options.outer.left = r.right - s.width) : o.right && (n.options.inner.right = r.left + a.width, n.options.outer.right = r.left + s.width), $r.restrictEdges.set(t), n.options = i;\n        }\n      },\n      defaults: {\n        min: null,\n        max: null,\n        endOnly: !1,\n        enabled: !1\n      }\n    };\n  oo.restrictSize = so;\n  var lo = (0, Se.makeModifier)(so, \"restrictSize\");\n  oo.default = lo;\n  var uo = {};\n  Object.defineProperty(uo, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(uo, \"default\", {\n    enumerable: !0,\n    get: function () {\n      return Yr.default;\n    }\n  });\n  var co = {};\n  Object.defineProperty(co, \"__esModule\", {\n    value: !0\n  }), co.snap = co.default = void 0;\n  var fo = {\n    start: function (t) {\n      var e,\n        n = t.interaction,\n        r = t.interactable,\n        o = t.element,\n        i = t.rect,\n        a = t.state,\n        s = t.startOffset,\n        l = a.options,\n        u = l.offsetWithOrigin ? function (t) {\n          var e = t.interaction.element;\n          return (0, k.rectToXY)((0, k.resolveRectLike)(t.state.options.origin, null, null, [e])) || (0, A.default)(t.interactable, e, t.interaction.prepared.name);\n        }(t) : {\n          x: 0,\n          y: 0\n        };\n      if (\"startCoords\" === l.offset) e = {\n        x: n.coords.start.page.x,\n        y: n.coords.start.page.y\n      };else {\n        var c = (0, k.resolveRectLike)(l.offset, r, o, [n]);\n        (e = (0, k.rectToXY)(c) || {\n          x: 0,\n          y: 0\n        }).x += u.x, e.y += u.y;\n      }\n      var f = l.relativePoints;\n      a.offsets = i && f && f.length ? f.map(function (t, n) {\n        return {\n          index: n,\n          relativePoint: t,\n          x: s.left - i.width * t.x + e.x,\n          y: s.top - i.height * t.y + e.y\n        };\n      }) : [{\n        index: 0,\n        relativePoint: null,\n        x: e.x,\n        y: e.y\n      }];\n    },\n    set: function (t) {\n      var e = t.interaction,\n        n = t.coords,\n        r = t.state,\n        o = r.options,\n        a = r.offsets,\n        s = (0, A.default)(e.interactable, e.element, e.prepared.name),\n        l = (0, M.default)({}, n),\n        u = [];\n      o.offsetWithOrigin || (l.x -= s.x, l.y -= s.y);\n      for (var c = 0; c < a.length; c++) for (var f = a[c], d = l.x - f.x, p = l.y - f.y, v = 0, h = o.targets.length; v < h; v++) {\n        var g,\n          y = o.targets[v];\n        (g = i.default.func(y) ? y(d, p, e._proxy, f, v) : y) && u.push({\n          x: (i.default.number(g.x) ? g.x : d) + f.x,\n          y: (i.default.number(g.y) ? g.y : p) + f.y,\n          range: i.default.number(g.range) ? g.range : o.range,\n          source: y,\n          index: v,\n          offset: f\n        });\n      }\n      for (var m = {\n          target: null,\n          inRange: !1,\n          distance: 0,\n          range: 0,\n          delta: {\n            x: 0,\n            y: 0\n          }\n        }, b = 0; b < u.length; b++) {\n        var x = u[b],\n          w = x.range,\n          _ = x.x - l.x,\n          P = x.y - l.y,\n          O = (0, R.default)(_, P),\n          E = O <= w;\n        w === 1 / 0 && m.inRange && m.range !== 1 / 0 && (E = !1), m.target && !(E ? m.inRange && w !== 1 / 0 ? O / w < m.distance / m.range : w === 1 / 0 && m.range !== 1 / 0 || O < m.distance : !m.inRange && O < m.distance) || (m.target = x, m.distance = O, m.range = w, m.inRange = E, m.delta.x = _, m.delta.y = P);\n      }\n      return m.inRange && (n.x = m.target.x, n.y = m.target.y), r.closest = m, m;\n    },\n    defaults: {\n      range: 1 / 0,\n      targets: null,\n      offset: null,\n      offsetWithOrigin: !0,\n      origin: null,\n      relativePoints: null,\n      endOnly: !1,\n      enabled: !1\n    }\n  };\n  co.snap = fo;\n  var po = (0, Se.makeModifier)(fo, \"snap\");\n  co.default = po;\n  var vo = {};\n  function ho(t, e) {\n    (null == e || e > t.length) && (e = t.length);\n    for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];\n    return r;\n  }\n  Object.defineProperty(vo, \"__esModule\", {\n    value: !0\n  }), vo.snapSize = vo.default = void 0;\n  var go = {\n    start: function (t) {\n      var e = t.state,\n        n = t.edges,\n        r = e.options;\n      if (!n) return null;\n      t.state = {\n        options: {\n          targets: null,\n          relativePoints: [{\n            x: n.left ? 0 : 1,\n            y: n.top ? 0 : 1\n          }],\n          offset: r.offset || \"self\",\n          origin: {\n            x: 0,\n            y: 0\n          },\n          range: r.range\n        }\n      }, e.targetFields = e.targetFields || [[\"width\", \"height\"], [\"x\", \"y\"]], co.snap.start(t), e.offsets = t.state.offsets, t.state = e;\n    },\n    set: function (t) {\n      var e,\n        n,\n        r = t.interaction,\n        o = t.state,\n        a = t.coords,\n        s = o.options,\n        l = o.offsets,\n        u = {\n          x: a.x - l[0].x,\n          y: a.y - l[0].y\n        };\n      o.options = (0, M.default)({}, s), o.options.targets = [];\n      for (var c = 0; c < (s.targets || []).length; c++) {\n        var f = (s.targets || [])[c],\n          d = void 0;\n        if (d = i.default.func(f) ? f(u.x, u.y, r) : f) {\n          for (var p = 0; p < o.targetFields.length; p++) {\n            var v = (e = o.targetFields[p], n = 2, function (t) {\n                if (Array.isArray(t)) return t;\n              }(e) || function (t, e) {\n                var n = null == t ? null : \"undefined\" != typeof Symbol && t[Symbol.iterator] || t[\"@@iterator\"];\n                if (null != n) {\n                  var r,\n                    o,\n                    i = [],\n                    a = !0,\n                    s = !1;\n                  try {\n                    for (n = n.call(t); !(a = (r = n.next()).done) && (i.push(r.value), !e || i.length !== e); a = !0);\n                  } catch (t) {\n                    s = !0, o = t;\n                  } finally {\n                    try {\n                      a || null == n.return || n.return();\n                    } finally {\n                      if (s) throw o;\n                    }\n                  }\n                  return i;\n                }\n              }(e, n) || function (t, e) {\n                if (t) {\n                  if (\"string\" == typeof t) return ho(t, e);\n                  var n = Object.prototype.toString.call(t).slice(8, -1);\n                  return \"Object\" === n && t.constructor && (n = t.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(t) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ho(t, e) : void 0;\n                }\n              }(e, n) || function () {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n              }()),\n              h = v[0],\n              g = v[1];\n            if (h in d || g in d) {\n              d.x = d[h], d.y = d[g];\n              break;\n            }\n          }\n          o.options.targets.push(d);\n        }\n      }\n      var y = co.snap.set(t);\n      return o.options = s, y;\n    },\n    defaults: {\n      range: 1 / 0,\n      targets: null,\n      offset: null,\n      endOnly: !1,\n      enabled: !1\n    }\n  };\n  vo.snapSize = go;\n  var yo = (0, Se.makeModifier)(go, \"snapSize\");\n  vo.default = yo;\n  var mo = {};\n  Object.defineProperty(mo, \"__esModule\", {\n    value: !0\n  }), mo.snapEdges = mo.default = void 0;\n  var bo = {\n    start: function (t) {\n      var e = t.edges;\n      return e ? (t.state.targetFields = t.state.targetFields || [[e.left ? \"left\" : \"right\", e.top ? \"top\" : \"bottom\"]], vo.snapSize.start(t)) : null;\n    },\n    set: vo.snapSize.set,\n    defaults: (0, M.default)((0, ye.default)(vo.snapSize.defaults), {\n      targets: null,\n      range: null,\n      offset: {\n        x: 0,\n        y: 0\n      }\n    })\n  };\n  mo.snapEdges = bo;\n  var xo = (0, Se.makeModifier)(bo, \"snapEdges\");\n  mo.default = xo;\n  var wo = {};\n  Object.defineProperty(wo, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(wo, \"default\", {\n    enumerable: !0,\n    get: function () {\n      return Yr.default;\n    }\n  });\n  var _o = {};\n  Object.defineProperty(_o, \"__esModule\", {\n    value: !0\n  }), Object.defineProperty(_o, \"default\", {\n    enumerable: !0,\n    get: function () {\n      return Yr.default;\n    }\n  });\n  var Po = {};\n  Object.defineProperty(Po, \"__esModule\", {\n    value: !0\n  }), Po.default = void 0;\n  var Oo = {\n    aspectRatio: Dr.default,\n    restrictEdges: $r.default,\n    restrict: Vr.default,\n    restrictRect: to.default,\n    restrictSize: oo.default,\n    snapEdges: mo.default,\n    snap: co.default,\n    snapSize: vo.default,\n    spring: wo.default,\n    avoid: Ur.default,\n    transform: _o.default,\n    rubberband: uo.default\n  };\n  Po.default = Oo;\n  var Eo = {};\n  Object.defineProperty(Eo, \"__esModule\", {\n    value: !0\n  }), Eo.default = void 0;\n  var So = {\n      id: \"modifiers\",\n      install: function (t) {\n        var e = t.interactStatic;\n        for (var n in t.usePlugin(Se.default), t.usePlugin(Mr.default), e.modifiers = Po.default, Po.default) {\n          var r = Po.default[n],\n            o = r._defaults,\n            i = r._methods;\n          o._methods = i, t.defaults.perAction[n] = o;\n        }\n      }\n    },\n    To = So;\n  Eo.default = To;\n  var jo = {};\n  function Mo(t) {\n    return Mo = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    }, Mo(t);\n  }\n  function ko(t, e) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n];\n      r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, r.key, r);\n    }\n  }\n  function Io(t, e) {\n    return Io = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n      return t.__proto__ = e, t;\n    }, Io(t, e);\n  }\n  function Do(t, e) {\n    if (e && (\"object\" === Mo(e) || \"function\" == typeof e)) return e;\n    if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n    return Ao(t);\n  }\n  function Ao(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n  function zo(t) {\n    return zo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n      return t.__proto__ || Object.getPrototypeOf(t);\n    }, zo(t);\n  }\n  Object.defineProperty(jo, \"__esModule\", {\n    value: !0\n  }), jo.default = jo.PointerEvent = void 0;\n  var Co = function (t) {\n    !function (t, e) {\n      if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n      t.prototype = Object.create(e && e.prototype, {\n        constructor: {\n          value: t,\n          writable: !0,\n          configurable: !0\n        }\n      }), Object.defineProperty(t, \"prototype\", {\n        writable: !1\n      }), e && Io(t, e);\n    }(a, t);\n    var e,\n      n,\n      r,\n      o,\n      i = (r = a, o = function () {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n        if (Reflect.construct.sham) return !1;\n        if (\"function\" == typeof Proxy) return !0;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n        } catch (t) {\n          return !1;\n        }\n      }(), function () {\n        var t,\n          e = zo(r);\n        if (o) {\n          var n = zo(this).constructor;\n          t = Reflect.construct(e, arguments, n);\n        } else t = e.apply(this, arguments);\n        return Do(this, t);\n      });\n    function a(t, e, n, r, o, s) {\n      var l;\n      if (function (t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n      }(this, a), l = i.call(this, o), X.pointerExtend(Ao(l), n), n !== e && X.pointerExtend(Ao(l), e), l.timeStamp = s, l.originalEvent = n, l.type = t, l.pointerId = X.getPointerId(e), l.pointerType = X.getPointerType(e), l.target = r, l.currentTarget = null, \"tap\" === t) {\n        var u = o.getPointerIndex(e);\n        l.dt = l.timeStamp - o.pointers[u].downTime;\n        var c = l.timeStamp - o.tapTime;\n        l.double = !!o.prevTap && \"doubletap\" !== o.prevTap.type && o.prevTap.target === l.target && c < 500;\n      } else \"doubletap\" === t && (l.dt = e.timeStamp - o.tapTime, l.double = !0);\n      return l;\n    }\n    return e = a, (n = [{\n      key: \"_subtractOrigin\",\n      value: function (t) {\n        var e = t.x,\n          n = t.y;\n        return this.pageX -= e, this.pageY -= n, this.clientX -= e, this.clientY -= n, this;\n      }\n    }, {\n      key: \"_addOrigin\",\n      value: function (t) {\n        var e = t.x,\n          n = t.y;\n        return this.pageX += e, this.pageY += n, this.clientX += e, this.clientY += n, this;\n      }\n    }, {\n      key: \"preventDefault\",\n      value: function () {\n        this.originalEvent.preventDefault();\n      }\n    }]) && ko(e.prototype, n), Object.defineProperty(e, \"prototype\", {\n      writable: !1\n    }), a;\n  }(N.BaseEvent);\n  jo.PointerEvent = jo.default = Co;\n  var Ro = {};\n  Object.defineProperty(Ro, \"__esModule\", {\n    value: !0\n  }), Ro.default = void 0;\n  var Fo = {\n    id: \"pointer-events/base\",\n    before: [\"inertia\", \"modifiers\", \"auto-start\", \"actions\"],\n    install: function (t) {\n      t.pointerEvents = Fo, t.defaults.actions.pointerEvents = Fo.defaults, (0, M.default)(t.actions.phaselessTypes, Fo.types);\n    },\n    listeners: {\n      \"interactions:new\": function (t) {\n        var e = t.interaction;\n        e.prevTap = null, e.tapTime = 0;\n      },\n      \"interactions:update-pointer\": function (t) {\n        var e = t.down,\n          n = t.pointerInfo;\n        !e && n.hold || (n.hold = {\n          duration: 1 / 0,\n          timeout: null\n        });\n      },\n      \"interactions:move\": function (t, e) {\n        var n = t.interaction,\n          r = t.pointer,\n          o = t.event,\n          i = t.eventTarget;\n        t.duplicate || n.pointerIsDown && !n.pointerWasMoved || (n.pointerIsDown && Yo(t), Xo({\n          interaction: n,\n          pointer: r,\n          event: o,\n          eventTarget: i,\n          type: \"move\"\n        }, e));\n      },\n      \"interactions:down\": function (t, e) {\n        !function (t, e) {\n          for (var n = t.interaction, r = t.pointer, o = t.event, i = t.eventTarget, a = t.pointerIndex, s = n.pointers[a].hold, l = _.getPath(i), u = {\n              interaction: n,\n              pointer: r,\n              event: o,\n              eventTarget: i,\n              type: \"hold\",\n              targets: [],\n              path: l,\n              node: null\n            }, c = 0; c < l.length; c++) {\n            var f = l[c];\n            u.node = f, e.fire(\"pointerEvents:collect-targets\", u);\n          }\n          if (u.targets.length) {\n            for (var d = 1 / 0, p = 0; p < u.targets.length; p++) {\n              var v = u.targets[p].eventable.options.holdDuration;\n              v < d && (d = v);\n            }\n            s.duration = d, s.timeout = setTimeout(function () {\n              Xo({\n                interaction: n,\n                eventTarget: i,\n                pointer: r,\n                event: o,\n                type: \"hold\"\n              }, e);\n            }, d);\n          }\n        }(t, e), Xo(t, e);\n      },\n      \"interactions:up\": function (t, e) {\n        Yo(t), Xo(t, e), function (t, e) {\n          var n = t.interaction,\n            r = t.pointer,\n            o = t.event,\n            i = t.eventTarget;\n          n.pointerWasMoved || Xo({\n            interaction: n,\n            eventTarget: i,\n            pointer: r,\n            event: o,\n            type: \"tap\"\n          }, e);\n        }(t, e);\n      },\n      \"interactions:cancel\": function (t, e) {\n        Yo(t), Xo(t, e);\n      }\n    },\n    PointerEvent: jo.PointerEvent,\n    fire: Xo,\n    collectEventTargets: Bo,\n    defaults: {\n      holdDuration: 600,\n      ignoreFrom: null,\n      allowFrom: null,\n      origin: {\n        x: 0,\n        y: 0\n      }\n    },\n    types: {\n      down: !0,\n      move: !0,\n      up: !0,\n      cancel: !0,\n      tap: !0,\n      doubletap: !0,\n      hold: !0\n    }\n  };\n  function Xo(t, e) {\n    var n = t.interaction,\n      r = t.pointer,\n      o = t.event,\n      i = t.eventTarget,\n      a = t.type,\n      s = t.targets,\n      l = void 0 === s ? Bo(t, e) : s,\n      u = new jo.PointerEvent(a, r, o, i, n, e.now());\n    e.fire(\"pointerEvents:new\", {\n      pointerEvent: u\n    });\n    for (var c = {\n        interaction: n,\n        pointer: r,\n        event: o,\n        eventTarget: i,\n        targets: l,\n        type: a,\n        pointerEvent: u\n      }, f = 0; f < l.length; f++) {\n      var d = l[f];\n      for (var p in d.props || {}) u[p] = d.props[p];\n      var v = (0, A.default)(d.eventable, d.node);\n      if (u._subtractOrigin(v), u.eventable = d.eventable, u.currentTarget = d.node, d.eventable.fire(u), u._addOrigin(v), u.immediatePropagationStopped || u.propagationStopped && f + 1 < l.length && l[f + 1].node !== u.currentTarget) break;\n    }\n    if (e.fire(\"pointerEvents:fired\", c), \"tap\" === a) {\n      var h = u.double ? Xo({\n        interaction: n,\n        pointer: r,\n        event: o,\n        eventTarget: i,\n        type: \"doubletap\"\n      }, e) : u;\n      n.prevTap = h, n.tapTime = h.timeStamp;\n    }\n    return u;\n  }\n  function Bo(t, e) {\n    var n = t.interaction,\n      r = t.pointer,\n      o = t.event,\n      i = t.eventTarget,\n      a = t.type,\n      s = n.getPointerIndex(r),\n      l = n.pointers[s];\n    if (\"tap\" === a && (n.pointerWasMoved || !l || l.downTarget !== i)) return [];\n    for (var u = _.getPath(i), c = {\n        interaction: n,\n        pointer: r,\n        event: o,\n        eventTarget: i,\n        type: a,\n        path: u,\n        targets: [],\n        node: null\n      }, f = 0; f < u.length; f++) {\n      var d = u[f];\n      c.node = d, e.fire(\"pointerEvents:collect-targets\", c);\n    }\n    return \"hold\" === a && (c.targets = c.targets.filter(function (t) {\n      var e;\n      return t.eventable.options.holdDuration === (null == (e = n.pointers[s]) ? void 0 : e.hold.duration);\n    })), c.targets;\n  }\n  function Yo(t) {\n    var e = t.interaction,\n      n = t.pointerIndex,\n      r = e.pointers[n].hold;\n    r && r.timeout && (clearTimeout(r.timeout), r.timeout = null);\n  }\n  var Wo = Fo;\n  Ro.default = Wo;\n  var Lo = {};\n  function Uo(t) {\n    var e = t.interaction;\n    e.holdIntervalHandle && (clearInterval(e.holdIntervalHandle), e.holdIntervalHandle = null);\n  }\n  Object.defineProperty(Lo, \"__esModule\", {\n    value: !0\n  }), Lo.default = void 0;\n  var Vo = {\n      id: \"pointer-events/holdRepeat\",\n      install: function (t) {\n        t.usePlugin(Ro.default);\n        var e = t.pointerEvents;\n        e.defaults.holdRepeatInterval = 0, e.types.holdrepeat = t.actions.phaselessTypes.holdrepeat = !0;\n      },\n      listeners: [\"move\", \"up\", \"cancel\", \"endall\"].reduce(function (t, e) {\n        return t[\"pointerEvents:\".concat(e)] = Uo, t;\n      }, {\n        \"pointerEvents:new\": function (t) {\n          var e = t.pointerEvent;\n          \"hold\" === e.type && (e.count = (e.count || 0) + 1);\n        },\n        \"pointerEvents:fired\": function (t, e) {\n          var n = t.interaction,\n            r = t.pointerEvent,\n            o = t.eventTarget,\n            i = t.targets;\n          if (\"hold\" === r.type && i.length) {\n            var a = i[0].eventable.options.holdRepeatInterval;\n            a <= 0 || (n.holdIntervalHandle = setTimeout(function () {\n              e.pointerEvents.fire({\n                interaction: n,\n                eventTarget: o,\n                type: \"hold\",\n                pointer: r,\n                event: r\n              }, e);\n            }, a));\n          }\n        }\n      })\n    },\n    No = Vo;\n  Lo.default = No;\n  var qo = {};\n  function Go(t) {\n    return (0, M.default)(this.events.options, t), this;\n  }\n  Object.defineProperty(qo, \"__esModule\", {\n    value: !0\n  }), qo.default = void 0;\n  var $o = {\n      id: \"pointer-events/interactableTargets\",\n      install: function (t) {\n        var e = t.Interactable;\n        e.prototype.pointerEvents = Go;\n        var n = e.prototype._backCompatOption;\n        e.prototype._backCompatOption = function (t, e) {\n          var r = n.call(this, t, e);\n          return r === this && (this.events.options[t] = e), r;\n        };\n      },\n      listeners: {\n        \"pointerEvents:collect-targets\": function (t, e) {\n          var n = t.targets,\n            r = t.node,\n            o = t.type,\n            i = t.eventTarget;\n          e.interactables.forEachMatch(r, function (t) {\n            var e = t.events,\n              a = e.options;\n            e.types[o] && e.types[o].length && t.testIgnoreAllow(a, r, i) && n.push({\n              node: r,\n              eventable: e,\n              props: {\n                interactable: t\n              }\n            });\n          });\n        },\n        \"interactable:new\": function (t) {\n          var e = t.interactable;\n          e.events.getRect = function (t) {\n            return e.getRect(t);\n          };\n        },\n        \"interactable:set\": function (t, e) {\n          var n = t.interactable,\n            r = t.options;\n          (0, M.default)(n.events.options, e.pointerEvents.defaults), (0, M.default)(n.events.options, r.pointerEvents || {});\n        }\n      }\n    },\n    Ho = $o;\n  qo.default = Ho;\n  var Ko = {};\n  Object.defineProperty(Ko, \"__esModule\", {\n    value: !0\n  }), Ko.default = void 0;\n  var Zo = {\n      id: \"pointer-events\",\n      install: function (t) {\n        t.usePlugin(Ro), t.usePlugin(Lo.default), t.usePlugin(qo.default);\n      }\n    },\n    Jo = Zo;\n  Ko.default = Jo;\n  var Qo = {};\n  function ti(t) {\n    var e = t.Interactable;\n    t.actions.phases.reflow = !0, e.prototype.reflow = function (e) {\n      return function (t, e, n) {\n        for (var r = i.default.string(t.target) ? H.from(t._context.querySelectorAll(t.target)) : [t.target], o = n.window.Promise, a = o ? [] : null, s = function () {\n            var i = r[l],\n              s = t.getRect(i);\n            if (!s) return \"break\";\n            var u = H.find(n.interactions.list, function (n) {\n                return n.interacting() && n.interactable === t && n.element === i && n.prepared.name === e.name;\n              }),\n              c = void 0;\n            if (u) u.move(), a && (c = u._reflowPromise || new o(function (t) {\n              u._reflowResolve = t;\n            }));else {\n              var f = (0, k.tlbrToXywh)(s),\n                d = {\n                  page: {\n                    x: f.x,\n                    y: f.y\n                  },\n                  client: {\n                    x: f.x,\n                    y: f.y\n                  },\n                  timeStamp: n.now()\n                },\n                p = X.coordsToEvent(d);\n              c = function (t, e, n, r, o) {\n                var i = t.interactions.new({\n                    pointerType: \"reflow\"\n                  }),\n                  a = {\n                    interaction: i,\n                    event: o,\n                    pointer: o,\n                    eventTarget: n,\n                    phase: \"reflow\"\n                  };\n                i.interactable = e, i.element = n, i.prevEvent = o, i.updatePointer(o, o, n, !0), X.setZeroCoords(i.coords.delta), (0, Xt.copyAction)(i.prepared, r), i._doPhase(a);\n                var s = t.window.Promise,\n                  l = s ? new s(function (t) {\n                    i._reflowResolve = t;\n                  }) : void 0;\n                return i._reflowPromise = l, i.start(r, e, n), i._interacting ? (i.move(a), i.end(o)) : (i.stop(), i._reflowResolve()), i.removePointer(o, o), l;\n              }(n, t, i, e, p);\n            }\n            a && a.push(c);\n          }, l = 0; l < r.length && \"break\" !== s(); l++);\n        return a && o.all(a).then(function () {\n          return t;\n        });\n      }(this, e, t);\n    };\n  }\n  Object.defineProperty(Qo, \"__esModule\", {\n    value: !0\n  }), Qo.default = void 0, Qo.install = ti;\n  var ei = {\n      id: \"reflow\",\n      install: ti,\n      listeners: {\n        \"interactions:stop\": function (t, e) {\n          var n = t.interaction;\n          \"reflow\" === n.pointerType && (n._reflowResolve && n._reflowResolve(), H.remove(e.interactions.list, n));\n        }\n      }\n    },\n    ni = ei;\n  Qo.default = ni;\n  var ri = {\n    exports: {}\n  };\n  function oi(t) {\n    return oi = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    }, oi(t);\n  }\n  Object.defineProperty(ri.exports, \"__esModule\", {\n    value: !0\n  }), ri.exports.default = void 0, br.default.use(le.default), br.default.use(Qe.default), br.default.use(Ko.default), br.default.use(ln.default), br.default.use(Eo.default), br.default.use(ae.default), br.default.use(Et.default), br.default.use(Dt.default), br.default.use(Qo.default);\n  var ii = br.default;\n  if (ri.exports.default = ii, \"object\" === oi(ri) && ri) try {\n    ri.exports = br.default;\n  } catch (t) {}\n  br.default.default = br.default, Et.default, Dt.default, ae.default, le.default, he.default, ln.default, br.default, Eo.default, Qe.default, Ko.default, Qo.default, ri = ri.exports;\n  var ai = {\n    exports: {}\n  };\n  function si(t) {\n    return si = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n      return typeof t;\n    } : function (t) {\n      return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n    }, si(t);\n  }\n  Object.defineProperty(ai.exports, \"__esModule\", {\n    value: !0\n  }), ai.exports.default = void 0;\n  var li = ri.default;\n  if (ai.exports.default = li, \"object\" === si(ai) && ai) try {\n    ai.exports = ri.default;\n  } catch (t) {}\n  return ri.default.default = ri.default, ai.exports;\n});","map":{"version":3,"names":["t","exports","module","define","amd","window","global","self","interact","Window","e","default","ownerDocument","defaultView","r","n","o","realWindow","document","createTextNode","wrap","s","a","l","docFrag","nodeType","object","func","number","bool","string","element","getWindow","test","Element","nodeName","plainObject","constructor","toString","array","length","splice","f","interaction","prepared","name","axis","coords","cur","page","y","start","client","velocity","x","d","iEvent","delta","p","id","install","actions","Interactable","defaults","prototype","draggable","map","drag","methodDict","listeners","auto-start:check","interactable","buttons","options","enabled","pointerIsDown","pointerType","mouseButtons","action","lockAxis","startAxis","i","setPerAction","setOnEvents","beforeMove","move","getCursor","g","init","DocumentFragment","SVGElement","SVGSVGElement","SVGElementInstance","HTMLElement","Event","Touch","PointerEvent","MSPointerEvent","h","navigator","supportsTouch","DocumentTouch","supportsPointerEvent","pointerEnabled","isIOS","platform","isIOS7","appVersion","isIe9","userAgent","isOperaMobile","appName","prefixedMatchesSelector","pEventTypes","up","down","over","out","cancel","wheelEvent","P","parentNode","host","O","replace","b","correspondingUseElement","j","T","left","right","top","bottom","push","E","S","u","ownerSVGElement","c","lastChild","previousSibling","v","parseInt","getComputedStyle","zIndex","contains","querySelector","unshift","scrollX","documentElement","scrollLeft","scrollY","scrollTop","getBoundingClientRect","getClientRects","width","height","D","_","getRect","closest","apply","getElementRect","M","origin","k","resolveRectLike","rectToXY","C","trim","split","search","reduce","concat","Math","sqrt","__set","Object","defineProperty","get","set","configurable","B","Y","W","L","U","type","touches","changedTouches","V","pageX","pageY","clientX","clientY","screenX","screenY","timeStamp","pointerId","target","preventDefault","composedPath","path","getActualElement","currentTarget","identifier","max","atan2","PI","min","R","$","G","_interaction","value","propagationStopped","immediatePropagationStopped","_proxy","indexOf","K","Z","at","it","rt","call","prev","dropzone","dragEvent","relatedTarget","dropState","rejected","events","enter","stopImmediatePropagation","activeDrops","H","findIndex","fire","N","BaseEvent","lt","slice","ut","interactables","list","drop","accept","matchesSelector","draggableElement","_context","querySelectorAll","rect","ct","dropCheck","indexOfDeepestElement","ft","leave","activate","deactivate","J","DropEvent","dragLeave","prevDropzone","dragEnter","dragmove","dt","pt","event","dynamicDrop","vt","interactStatic","usePlugin","z","keys","off","on","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","overlap","checker","A","X","getPageXY","phaselessTypes","dragenter","dragleave","dropactivate","dropdeactivate","dropmove","interactions:before-action-start","interactions:after-action-start","interactions:after-action-move","interactions:action-end","interactions:stop","getActiveDrops","getDrop","getDropEvents","fireDropEvents","yt","phase","pointers","pointer","deltaSource","distance","touchDistance","box","touchBBox","scale","ds","angle","touchAngle","da","gesture","startDistance","startAngle","prevEvent","isNaN","mt","before","gesturable","interactions:new","wt","abs","matchesUpTo","_t","resizeAxes","resize","square","axes","Pt","browser","cursors","xy","topleft","bottomright","topright","bottomleft","defaultMargin","resizable","preserveAspectRatio","interactions:action-start","edges","_rects","corrected","previous","deltaRect","interactions:action-move","invert","_latestPointer","eventTarget","margin","NaN","gt","xt","st","jt","Mt","kt","request","requestAnimationFrame","cancelAnimationFrame","bind","Date","now","setTimeout","clearTimeout","body","scrollWidth","scrollHeight","autoScroll","zt","container","Ct","At","speed","isScrolling","prevTime","Tt","scroll","stop","scrollBy","check","onInteractionMove","interacting","simulation","innerWidth","innerHeight","getElementClientRect","getStringOptionResult","Rt","autoscroll","perAction","interactions:destroy","console","warn","arguments","Yt","styleCursor","Wt","actionChecker","getAction","button","ignoreFrom","Xt","warnOnce","_backCompatOption","allowFrom","Vt","testIgnoreAllow","$t","Nt","qt","forEachMatch","manualStart","Gt","copyAction","Zt","maxPerElement","autoStart","maxInteractions","interactions","Ht","Kt","cursorElement","style","cursor","cursorChecker","_interacting","Jt","Bt","base","withinInteractionLimit","interactions:down","interactions:move","pointerWasMoved","validateAction","autoStart:before-start","dx","dy","downPointer","downEvent","Ut","re","hold","delay","oe","autoStartHoldTimer","autoStart:prepared","duplicate","getHoldDuration","ne","te","ue","ce","checkAndPreventDefault","fe","supportsPassive","getDocOptions","passive","docEvents","listener","nodeContains","ve","touchAction","boxSizing","noListeners","from","Pe","_e","result","Oe","modifiers","methods","_methods","filter","prepareStates","startOffset","Ee","startDelta","fillArg","pageCoords","preEnd","startAll","setAll","states","state","skipModifiers","shouldDo","addEdges","eventProps","rectDelta","changed","be","modifiedCoords","applyToInteraction","beforeEnd","endResult","index","modification","endOnly","setStart","ye","Te","enable","disable","_defaults","je","me","interactions:before-action-move","setAndApply","interactions:before-action-end","restoreInteractionCoords","Be","Xe","Re","ke","ctrlKey","altKey","shiftKey","metaKey","t0","downTime","x0","y0","clientX0","clientY0","duration","swipe","getSwipe","velocityY","velocityX","defineProperties","Ve","Le","Ue","downTarget","Ne","qe","Ge","_ProxyValues","end","_ProxyMethods","Ke","Ze","scopeFire","He","newCoords","_scopeFire","updatePointer","pointerIndex","pointerInfo","_stopped","_doPhase","pointerMoveTolerance","getPointerIndex","setCoordVelocity","copyCoords","setZeroCoords","curEventTarget","removePointer","_ending","getPointerId","Ye","PointerInfo","setCoords","_now","setCoordDeltas","pointerExtend","_updateLatestPointer","Ie","InteractEvent","_createPreparedEvent","_fireEvent","tn","offset","total","pending","en","nn","rn","offsetBy","an","Interaction","interactions:update-pointer","fn","cn","dn","copyFrom","allowResume","v0","currentOffset","startCoords","modifierArg","minSpeed","endSpeed","startInertia","startSmoothEnd","targetOffset","active","resistance","log","lambda_v0","one_ve_v0","isModified","modifiedOffset","onNextFrame","inertiaTick","smoothEnd","smoothEndTick","timeout","exp","vn","smoothEndDuration","hn","modifierCount","inertia","pn","Qe","Se","phases","inertiastart","resume","interactions:before-action-resume","interactions:before-action-inertiastart","addEventModifiers","interactions:after-action-inertiastart","interactions:after-action-resume","xn","wn","bn","types","merge","substr","new","globalEvents","getPointerAverage","pointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","version","scope","use","isSet","context","_n","add","remove","debug","addDocument","removeDocument","Tn","Sn","yn","Eventable","_actions","_win","trySelector","_doc","_scopeEvents","onstart","onmove","onend","oninertiastart","updatePerActionListeners","_rectChecker","testIgnore","testAllow","_onOff","delegatedEvents","selector","removeDelegate","In","kn","addListeners","interactable:unset","selectorMap","win","find","inContext","Fn","zn","originalEvent","F","stopPropagation","Xn","capture","addDelegate","Cn","m","delegateListener","delegateUseCapture","documents","targets","supportsOptions","addEventListener","removeEventListener","hasOwnProperty","getEventTargets","createElement","Wn","methodOrder","simulationResume","eventType","mouseOrPen","Ln","hasPointer","idle","some","Qn","tr","getPointerType","qn","prevTouchTime","er","w","Yn","searchDetails","nr","doc","rr","pointerDown","pointerMove","pointerUp","documentBlur","$n","key","le","scope:add-document","scope:remove-document","destroy","onDocSignal","doOnInteractions","methodNames","gr","dr","hr","floor","random","Pn","createInteractStatic","jn","InteractableSet","vr","sr","fr","On","listenerMaps","isInitialized","yr","_plugins","pluginIsInstalled","mr","getDocIndex","onWindowUnload","Vn","Dn","xr","ir","Scope","_r","globalThis","Sr","range","limits","grid","round","coordFields","kr","snappers","jr","createSnapGrid","Rr","ratio","equalDelta","startRect","linkedEdges","xIsPrimaryAxis","edgeSign","subModification","zr","Fr","Xr","prevCoords","prevRect","makeModifier","Wr","Nr","qr","elementRect","restriction","xywhToTlbr","Hr","Kr","Zr","Jr","noInner","noOuter","Vr","getRestrictionRect","inner","outer","eo","restrict","no","io","ao","so","$r","restrictEdges","tlbrToXywh","fo","offsetWithOrigin","relativePoints","offsets","relativePoint","source","inRange","go","targetFields","co","snap","bo","vo","snapSize","aspectRatio","Dr","restrictRect","to","restrictSize","oo","snapEdges","mo","spring","wo","avoid","Ur","transform","_o","rubberband","uo","So","Mr","Po","Co","Ao","tapTime","double","prevTap","Fo","pointerEvents","Yo","Xo","getPath","node","eventable","holdDuration","interactions:up","interactions:cancel","jo","collectEventTargets","Bo","tap","doubletap","pointerEvent","props","_subtractOrigin","_addOrigin","Uo","holdIntervalHandle","clearInterval","Vo","Ro","holdRepeatInterval","holdrepeat","pointerEvents:new","count","pointerEvents:fired","Go","$o","pointerEvents:collect-targets","interactable:new","interactable:set","Zo","Lo","qo","ti","reflow","Promise","_reflowPromise","_reflowResolve","coordsToEvent","all","then","ei","br","Ko","ln","Eo","ae","Et","Dt","Qo","oi","ri","he","si","ai"],"sources":["_header.js","node_modules/browser-pack-flat/_prelude","packages/@interactjs/utils/isWindow.ts","packages/@interactjs/utils/window.ts","packages/@interactjs/utils/is.ts","packages/@interactjs/actions/drag/plugin.ts","packages/@interactjs/utils/domObjects.ts","packages/@interactjs/utils/browser.ts","packages/@interactjs/utils/domUtils.ts","packages/@interactjs/utils/extend.ts","packages/@interactjs/utils/rect.ts","packages/@interactjs/utils/getOriginXY.ts","packages/@interactjs/utils/normalizeListeners.ts","packages/@interactjs/utils/hypot.ts","packages/@interactjs/utils/pointerExtend.ts","packages/@interactjs/utils/pointerUtils.ts","packages/@interactjs/core/BaseEvent.ts","packages/@interactjs/utils/arr.ts","packages/@interactjs/actions/drop/DropEvent.ts","packages/@interactjs/actions/drop/plugin.ts","packages/@interactjs/actions/gesture/plugin.ts","packages/@interactjs/actions/resize/plugin.ts","packages/@interactjs/actions/plugin.ts","packages/@interactjs/utils/raf.ts","packages/@interactjs/auto-scroll/plugin.ts","packages/@interactjs/utils/misc.ts","packages/@interactjs/auto-start/InteractableMethods.ts","packages/@interactjs/auto-start/base.ts","packages/@interactjs/auto-start/dragAxis.ts","packages/@interactjs/auto-start/hold.ts","packages/@interactjs/auto-start/plugin.ts","packages/@interactjs/core/interactablePreventDefault.ts","packages/@interactjs/dev-tools/visualizer/plugin.ts","packages/@interactjs/dev-tools/plugin.ts","packages/@interactjs/utils/clone.ts","packages/@interactjs/modifiers/Modification.ts","packages/@interactjs/modifiers/base.ts","packages/@interactjs/core/options.ts","packages/@interactjs/core/InteractEvent.ts","packages/@interactjs/core/PointerInfo.ts","packages/@interactjs/core/Interaction.ts","packages/@interactjs/offset/plugin.ts","packages/@interactjs/inertia/plugin.ts","packages/@interactjs/core/Eventable.ts","packages/@interactjs/core/isNonNativeEvent.ts","packages/@interactjs/core/InteractStatic.ts","packages/@interactjs/core/Interactable.ts","packages/@interactjs/core/InteractableSet.ts","packages/@interactjs/core/events.ts","packages/@interactjs/core/interactionFinder.ts","packages/@interactjs/core/interactions.ts","packages/@interactjs/core/scope.ts","packages/@interactjs/interact/index.ts","packages/@interactjs/snappers/edgeTarget.ts","packages/@interactjs/snappers/elements.ts","packages/@interactjs/snappers/grid.ts","packages/@interactjs/snappers/plugin.ts","packages/@interactjs/modifiers/aspectRatio.ts","packages/@interactjs/modifiers/noop.ts","packages/@interactjs/modifiers/restrict/pointer.ts","packages/@interactjs/modifiers/restrict/edges.ts","packages/@interactjs/modifiers/restrict/rect.ts","packages/@interactjs/modifiers/restrict/size.ts","packages/@interactjs/modifiers/snap/pointer.ts","packages/@interactjs/modifiers/snap/size.ts","packages/@interactjs/modifiers/snap/edges.ts","packages/@interactjs/modifiers/all.ts","packages/@interactjs/modifiers/plugin.ts","packages/@interactjs/pointer-events/PointerEvent.ts","packages/@interactjs/pointer-events/base.ts","packages/@interactjs/pointer-events/holdRepeat.ts","packages/@interactjs/pointer-events/interactableTargets.ts","packages/@interactjs/pointer-events/plugin.ts","packages/@interactjs/reflow/plugin.ts","packages/@interactjs/interactjs/index.ts","packages/interactjs/index.ts","node_modules/browser-pack-flat/_postlude"],"sourcesContent":["/**\n * interact.js 1.10.17\n *\n * Copyright (c) 2012-present Taye Adeyemi <dev@taye.me>\n * https://interactjs.io/license\n */\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.interact = f()}})(function(){var define,module,exports;\n","export default (thing: any) => !!(thing && thing.Window) && thing instanceof thing.Window\n","import isWindow from './isWindow'\n\nexport let realWindow = undefined as Window\n\nlet win = undefined as Window\nexport { win as window }\n\nexport function init (window: Window & { wrap?: (...args: any[]) => any }) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  realWindow = window\n\n  // create a TextNode\n  const el = window.document.createTextNode('')\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window)\n  }\n\n  win = window\n}\n\nif (typeof window !== 'undefined' && !!window) {\n  init(window)\n}\n\nexport function getWindow (node: any) {\n  if (isWindow(node)) {\n    return node\n  }\n\n  const rootNode = node.ownerDocument || node\n\n  return rootNode.defaultView || win.window\n}\n","import isWindow from './isWindow'\nimport * as win from './window'\n\nconst window = (thing: any): thing is Window => thing === win.window || isWindow(thing)\n\nconst docFrag = (thing: any): thing is DocumentFragment => object(thing) && thing.nodeType === 11\n\nconst object = (thing: any): thing is { [index: string]: any } => !!thing && typeof thing === 'object'\n\nconst func = (thing: any): thing is (...args: any[]) => any => typeof thing === 'function'\n\nconst number = (thing: any): thing is number => typeof thing === 'number'\n\nconst bool = (thing: any): thing is boolean => typeof thing === 'boolean'\n\nconst string = (thing: any): thing is string => typeof thing === 'string'\n\nconst element = (thing: any): thing is HTMLElement | SVGElement => {\n  if (!thing || typeof thing !== 'object') {\n    return false\n  }\n\n  const _window = win.getWindow(thing) || win.window\n\n  return /object|function/.test(typeof Element)\n    ? thing instanceof Element || thing instanceof _window.Element\n    : thing.nodeType === 1 && typeof thing.nodeName === 'string'\n}\n\nconst plainObject: typeof object = (thing: any): thing is { [index: string]: any } =>\n  object(thing) && !!thing.constructor && /function Object\\b/.test(thing.constructor.toString())\n\nconst array = <T extends unknown>(thing: any): thing is T[] =>\n  object(thing) && typeof thing.length !== 'undefined' && func(thing.splice)\n\nexport default {\n  window,\n  docFrag,\n  object,\n  func,\n  number,\n  bool,\n  string,\n  element,\n  plainObject,\n  array,\n}\n","import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, ListenersArg } from '@interactjs/core/types'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    draggable: DraggableMethod\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    drag: DraggableOptions\n  }\n}\n\ndeclare module '@interactjs/core/types' {\n  interface ActionMap {\n    drag?: typeof drag\n  }\n}\n\nexport type DragEvent = InteractEvent<'drag'>\n\nexport type DraggableMethod = ActionMethod<DraggableOptions>\n\nexport interface DraggableOptions extends PerActionDefaults {\n  startAxis?: 'x' | 'y' | 'xy'\n  lockAxis?: 'x' | 'y' | 'xy' | 'start'\n  oninertiastart?: ListenersArg\n  onstart?: ListenersArg\n  onmove?: ListenersArg\n  onend?: ListenersArg\n}\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  Interactable.prototype.draggable = drag.draggable\n\n  actions.map.drag = drag\n  actions.methodDict.drag = 'draggable'\n\n  defaults.actions.drag = drag.defaults\n}\n\nfunction beforeMove ({ interaction }) {\n  if (interaction.prepared.name !== 'drag') return\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x') {\n    interaction.coords.cur.page.y = interaction.coords.start.page.y\n    interaction.coords.cur.client.y = interaction.coords.start.client.y\n\n    interaction.coords.velocity.client.y = 0\n    interaction.coords.velocity.page.y = 0\n  } else if (axis === 'y') {\n    interaction.coords.cur.page.x = interaction.coords.start.page.x\n    interaction.coords.cur.client.x = interaction.coords.start.client.x\n\n    interaction.coords.velocity.client.x = 0\n    interaction.coords.velocity.page.x = 0\n  }\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== 'drag') return\n\n  const axis = interaction.prepared.axis\n\n  if (axis === 'x' || axis === 'y') {\n    const opposite = axis === 'x' ? 'y' : 'x'\n\n    iEvent.page[opposite] = interaction.coords.start.page[opposite]\n    iEvent.client[opposite] = interaction.coords.start.client[opposite]\n    iEvent.delta[opposite] = 0\n  }\n}\n\n/**\n * ```js\n * interact(element).draggable({\n *     onstart: function (event) {},\n *     onmove : function (event) {},\n *     onend  : function (event) {},\n *\n *     // the axis in which the first movement must be\n *     // for the drag sequence to start\n *     // 'xy' by default - any direction\n *     startAxis: 'x' || 'y' || 'xy',\n *\n *     // 'xy' by default - don't restrict to one axis (move in any direction)\n *     // 'x' or 'y' to restrict movement to either axis\n *     // 'start' to restrict movement to the axis the drag started in\n *     lockAxis: 'x' || 'y' || 'xy' || 'start',\n *\n *     // max number of drags that can happen concurrently\n *     // with elements of this Interactable. Infinity by default\n *     max: Infinity,\n *\n *     // max number of drags that can target the same element+Interactable\n *     // 1 by default\n *     maxPerElement: 2\n * })\n *\n * var isDraggable = interact('element').draggable(); // true\n * ```\n *\n * Get or set whether drag actions can be performed on the target\n *\n * @alias Interactable.prototype.draggable\n *\n * @param {boolean | object} [options] true/false or An object with event\n * listeners to be fired on drag events (object makes the Interactable\n * draggable)\n * @return {boolean | Interactable} boolean indicating if this can be the\n * target of drag events, or this Interctable\n */\nconst draggable: DraggableMethod = function draggable (\n  this: Interactable,\n  options?: DraggableOptions | boolean,\n): any {\n  if (is.object(options)) {\n    this.options.drag.enabled = options.enabled !== false\n    this.setPerAction('drag', options)\n    this.setOnEvents('drag', options)\n\n    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {\n      this.options.drag.lockAxis = options.lockAxis\n    }\n    if (/^(xy|x|y)$/.test(options.startAxis)) {\n      this.options.drag.startAxis = options.startAxis\n    }\n\n    return this\n  }\n\n  if (is.bool(options)) {\n    this.options.drag.enabled = options\n\n    return this\n  }\n\n  return this.options.drag as DraggableOptions\n}\n\nconst drag: Plugin = {\n  id: 'actions/drag',\n  install,\n  listeners: {\n    'interactions:before-action-move': beforeMove,\n    'interactions:action-resume': beforeMove,\n\n    // dragmove\n    'interactions:action-move': move,\n    'auto-start:check': (arg) => {\n      const { interaction, interactable, buttons } = arg\n      const dragOptions = interactable.options.drag\n\n      if (\n        !(dragOptions && dragOptions.enabled) ||\n        // check mouseButton setting if the pointer is down\n        (interaction.pointerIsDown &&\n          /mouse|pointer/.test(interaction.pointerType) &&\n          (buttons & interactable.options.drag.mouseButtons) === 0)\n      ) {\n        return undefined\n      }\n\n      arg.action = {\n        name: 'drag',\n        axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis,\n      }\n\n      return false\n    },\n  },\n  draggable,\n  beforeMove,\n  move,\n  defaults: {\n    startAxis: 'xy',\n    lockAxis: 'xy',\n  } as DraggableOptions,\n\n  getCursor () {\n    return 'move'\n  },\n}\n\nexport default drag\n","const domObjects: {\n  init: any\n  document: Document\n  DocumentFragment: typeof DocumentFragment\n  SVGElement: typeof SVGElement\n  SVGSVGElement: typeof SVGSVGElement\n  SVGElementInstance: any\n  Element: typeof Element\n  HTMLElement: typeof HTMLElement\n  Event: typeof Event\n  Touch: typeof Touch\n  PointerEvent: typeof PointerEvent\n} = {\n  init,\n  document: null,\n  DocumentFragment: null,\n  SVGElement: null,\n  SVGSVGElement: null,\n  SVGElementInstance: null,\n  Element: null,\n  HTMLElement: null,\n  Event: null,\n  Touch: null,\n  PointerEvent: null,\n}\n\nfunction blank () {}\n\nexport default domObjects\n\nfunction init (window: Window) {\n  const win = window as any\n\n  domObjects.document = win.document\n  domObjects.DocumentFragment = win.DocumentFragment || blank\n  domObjects.SVGElement = win.SVGElement || blank\n  domObjects.SVGSVGElement = win.SVGSVGElement || blank\n  domObjects.SVGElementInstance = win.SVGElementInstance || blank\n  domObjects.Element = win.Element || blank\n  domObjects.HTMLElement = win.HTMLElement || domObjects.Element\n\n  domObjects.Event = win.Event\n  domObjects.Touch = win.Touch || blank\n  domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent\n}\n","import domObjects from './domObjects'\nimport is from './is'\n\nconst browser = {\n  init,\n  supportsTouch: null as boolean,\n  supportsPointerEvent: null as boolean,\n  isIOS7: null as boolean,\n  isIOS: null as boolean,\n  isIe9: null as boolean,\n  isOperaMobile: null as boolean,\n  prefixedMatchesSelector: null as 'matches',\n  pEventTypes: null as {\n    up: string\n    down: string\n    over: string\n    out: string\n    move: string\n    cancel: string\n  },\n  wheelEvent: null as string,\n}\n\nfunction init (window: any) {\n  const Element = domObjects.Element\n  const navigator: Partial<Navigator> = window.navigator || {}\n\n  // Does the browser support touch input?\n  browser.supportsTouch =\n    'ontouchstart' in window ||\n    (is.func(window.DocumentTouch) && domObjects.document instanceof window.DocumentTouch)\n\n  // Does the browser support PointerEvents\n  // https://github.com/taye/interact.js/issues/703#issuecomment-471570492\n  browser.supportsPointerEvent = (navigator as any).pointerEnabled !== false && !!domObjects.PointerEvent\n\n  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform)\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion)\n\n  browser.isIe9 = /MSIE 9/.test(navigator.userAgent)\n\n  // Opera Mobile must be handled differently\n  browser.isOperaMobile =\n    navigator.appName === 'Opera' && browser.supportsTouch && /Presto/.test(navigator.userAgent)\n\n  // prefix matchesSelector\n  browser.prefixedMatchesSelector = (\n    'matches' in Element.prototype\n      ? 'matches'\n      : 'webkitMatchesSelector' in Element.prototype\n        ? 'webkitMatchesSelector'\n        : 'mozMatchesSelector' in Element.prototype\n          ? 'mozMatchesSelector'\n          : 'oMatchesSelector' in Element.prototype\n            ? 'oMatchesSelector'\n            : 'msMatchesSelector'\n  ) as 'matches'\n\n  browser.pEventTypes = browser.supportsPointerEvent\n    ? domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n        up: 'MSPointerUp',\n        down: 'MSPointerDown',\n        over: 'mouseover',\n        out: 'mouseout',\n        move: 'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up: 'pointerup',\n        down: 'pointerdown',\n        over: 'pointerover',\n        out: 'pointerout',\n        move: 'pointermove',\n        cancel: 'pointercancel',\n      }\n    : null\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  browser.wheelEvent = domObjects.document && 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n}\n\nexport default browser\n","import type { Rect, Target, Element } from '@interactjs/core/types'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains (parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest (element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return element\n    }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode (node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector (element: Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) => el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement (elements: Element[] | NodeListOf<globalThis.Element>) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i < elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (\n      deepestNode instanceof domObjects.HTMLElement &&\n      currentNode instanceof domObjects.SVGElement &&\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    } else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (\n      currentNodeParents[commonIndex] &&\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\n    ) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    if (parents[0]) {\n      let child = parents[0].lastChild\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestNodeIndex = i\n          deepestNodeParents = currentNodeParents\n\n          break\n        } else if (child === parents[2]) {\n          break\n        }\n\n        child = child.previousSibling\n      }\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents (node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan (higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex >= lowerIndex\n}\n\nexport function matchesUpTo (element: Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement (element: Element) {\n  return (element as any).correspondingUseElement || element\n}\n\nexport function getScrollXY (relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect (element: Element): Required<Rect> {\n  const clientRect =\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\n\n  return (\n    clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    }\n  )\n}\n\nexport function getElementRect (element: Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left += scroll.x\n    clientRect.right += scroll.x\n    clientRect.top += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath (node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector (value: Target) {\n  if (!is.string(value)) {\n    return false\n  }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n","export default function extend<T, U extends object> (dest: U & Partial<T>, source: T): T & U {\n  for (const prop in source) {\n    ;(dest as unknown as T)[prop] = source[prop]\n  }\n\n  const ret = dest as T & U\n\n  return ret\n}\n","import type {\n  HasGetRect,\n  RectResolvable,\n  Rect,\n  Element,\n  Point,\n  FullRect,\n  EdgeOptions,\n} from '@interactjs/core/types'\n\nimport { closest, getElementRect, parentNode } from './domUtils'\nimport extend from './extend'\nimport is from './is'\n\nexport function getStringOptionResult (value: any, target: HasGetRect, element: Node) {\n  if (value === 'parent') {\n    return parentNode(element)\n  }\n\n  if (value === 'self') {\n    return target.getRect(element as Element)\n  }\n\n  return closest(element, value)\n}\n\nexport function resolveRectLike<T extends any[]> (\n  value: RectResolvable<T>,\n  target?: HasGetRect,\n  element?: Node,\n  functionArgs?: T,\n) {\n  let returnValue: any = value\n  if (is.string(returnValue)) {\n    returnValue = getStringOptionResult(returnValue, target, element)\n  } else if (is.func(returnValue)) {\n    returnValue = returnValue(...functionArgs)\n  }\n\n  if (is.element(returnValue)) {\n    returnValue = getElementRect(returnValue)\n  }\n\n  return returnValue as Rect\n}\n\nexport function rectToXY (rect: Rect | Point) {\n  return (\n    rect && {\n      x: 'x' in rect ? rect.x : rect.left,\n      y: 'y' in rect ? rect.y : rect.top,\n    }\n  )\n}\n\nexport function xywhToTlbr<T extends Partial<Rect & Point>> (rect: T) {\n  if (rect && !('left' in rect && 'top' in rect)) {\n    rect = extend({}, rect)\n\n    rect.left = rect.x || 0\n    rect.top = rect.y || 0\n    rect.right = rect.right || rect.left + rect.width\n    rect.bottom = rect.bottom || rect.top + rect.height\n  }\n\n  return rect as Rect & T\n}\n\nexport function tlbrToXywh (rect: Rect & Partial<Point>) {\n  if (rect && !('x' in rect && 'y' in rect)) {\n    rect = extend({}, rect)\n\n    rect.x = rect.left || 0\n    rect.y = rect.top || 0\n    rect.width = rect.width || (rect.right || 0) - rect.x\n    rect.height = rect.height || (rect.bottom || 0) - rect.y\n  }\n\n  return rect as FullRect & Point\n}\n\nexport function addEdges (edges: EdgeOptions, rect: Rect, delta: Point) {\n  if (edges.left) {\n    rect.left += delta.x\n  }\n  if (edges.right) {\n    rect.right += delta.x\n  }\n  if (edges.top) {\n    rect.top += delta.y\n  }\n  if (edges.bottom) {\n    rect.bottom += delta.y\n  }\n\n  rect.width = rect.right - rect.left\n  rect.height = rect.bottom - rect.top\n}\n","import type { PerActionDefaults } from '@interactjs/core/options'\nimport type { ActionName, HasGetRect } from '@interactjs/core/types'\n\nimport { rectToXY, resolveRectLike } from './rect'\n\nexport default function (\n  target: HasGetRect & { options: PerActionDefaults },\n  element: Node,\n  actionName?: ActionName,\n) {\n  const actionOptions = (target.options as any)[actionName]\n  const actionOrigin = actionOptions && actionOptions.origin\n  const origin = actionOrigin || target.options.origin\n\n  const originRect = resolveRectLike(origin, target, element, [target && element])\n\n  return rectToXY(originRect) || { x: 0, y: 0 }\n}\n","import type { EventTypes, Listener, ListenersArg } from '@interactjs/core/types'\n\nimport extend from './extend'\nimport is from './is'\n\nexport interface NormalizedListeners {\n  [type: string]: Listener[]\n}\n\nexport default function normalize (\n  type: EventTypes,\n  listeners?: ListenersArg | ListenersArg[],\n  result?: NormalizedListeners,\n): NormalizedListeners {\n  result = result || {}\n\n  if (is.string(type) && type.search(' ') !== -1) {\n    type = split(type)\n  }\n\n  if (is.array(type)) {\n    return type.reduce<NormalizedListeners>((acc, t) => extend(acc, normalize(t, listeners, result)), result)\n  }\n\n  // ({ type: fn }) -> ('', { type: fn })\n  if (is.object(type)) {\n    listeners = type\n    type = ''\n  }\n\n  if (is.func(listeners)) {\n    result[type] = result[type] || []\n    result[type].push(listeners)\n  } else if (is.array(listeners)) {\n    for (const l of listeners) {\n      normalize(type, l, result)\n    }\n  } else if (is.object(listeners)) {\n    for (const prefix in listeners) {\n      const combinedTypes = split(prefix).map((p) => `${type}${p}`)\n\n      normalize(combinedTypes, listeners[prefix], result)\n    }\n  }\n\n  return result as NormalizedListeners\n}\n\nfunction split (type: string) {\n  return type.trim().split(/ +/)\n}\n","export default (x: number, y: number) => Math.sqrt(x * x + y * y)\n","export default function pointerExtend<T> (dest: Partial<T & { __set?: Partial<T> }>, source: T) {\n  dest.__set ||= {} as any\n\n  for (const prop in source) {\n    if (typeof dest[prop] !== 'function' && prop !== '__set') {\n      Object.defineProperty(dest, prop, {\n        get () {\n          if (prop in dest.__set) return dest.__set[prop]\n\n          return (dest.__set[prop] = source[prop] as any)\n        },\n        set (value: any) {\n          dest.__set[prop] = value\n        },\n        configurable: true,\n      })\n    }\n  }\n  return dest\n}\n","import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { CoordsSetMember, PointerType, Point, PointerEventType, Element } from '@interactjs/core/types'\n\nimport browser from './browser'\nimport dom from './domObjects'\nimport * as domUtils from './domUtils'\nimport hypot from './hypot'\nimport is from './is'\nimport pointerExtend from './pointerExtend'\n\nexport function copyCoords (dest: CoordsSetMember, src: CoordsSetMember) {\n  dest.page = dest.page || ({} as any)\n  dest.page.x = src.page.x\n  dest.page.y = src.page.y\n\n  dest.client = dest.client || ({} as any)\n  dest.client.x = src.client.x\n  dest.client.y = src.client.y\n\n  dest.timeStamp = src.timeStamp\n}\n\nexport function setCoordDeltas (targetObj: CoordsSetMember, prev: CoordsSetMember, cur: CoordsSetMember) {\n  targetObj.page.x = cur.page.x - prev.page.x\n  targetObj.page.y = cur.page.y - prev.page.y\n  targetObj.client.x = cur.client.x - prev.client.x\n  targetObj.client.y = cur.client.y - prev.client.y\n  targetObj.timeStamp = cur.timeStamp - prev.timeStamp\n}\n\nexport function setCoordVelocity (targetObj: CoordsSetMember, delta: CoordsSetMember) {\n  const dt = Math.max(delta.timeStamp / 1000, 0.001)\n\n  targetObj.page.x = delta.page.x / dt\n  targetObj.page.y = delta.page.y / dt\n  targetObj.client.x = delta.client.x / dt\n  targetObj.client.y = delta.client.y / dt\n  targetObj.timeStamp = dt\n}\n\nexport function setZeroCoords (targetObj: CoordsSetMember) {\n  targetObj.page.x = 0\n  targetObj.page.y = 0\n  targetObj.client.x = 0\n  targetObj.client.y = 0\n}\n\nexport function isNativePointer (pointer: any) {\n  return pointer instanceof dom.Event || pointer instanceof dom.Touch\n}\n\n// Get specified X/Y coords for mouse or event.touches[0]\nexport function getXY (type: string, pointer: PointerType | InteractEvent, xy: Point) {\n  xy = xy || ({} as Point)\n  type = type || 'page'\n\n  xy.x = pointer[(type + 'X') as 'pageX']\n  xy.y = pointer[(type + 'Y') as 'pageY']\n\n  return xy\n}\n\nexport function getPageXY (pointer: PointerType | InteractEvent, page?: Point) {\n  page = page || { x: 0, y: 0 }\n\n  // Opera Mobile handles the viewport and scrolling oddly\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    getXY('screen', pointer, page)\n\n    page.x += window.scrollX\n    page.y += window.scrollY\n  } else {\n    getXY('page', pointer, page)\n  }\n\n  return page\n}\n\nexport function getClientXY (pointer: PointerType, client: Point) {\n  client = client || ({} as any)\n\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    // Opera Mobile handles the viewport and scrolling oddly\n    getXY('screen', pointer, client)\n  } else {\n    getXY('client', pointer, client)\n  }\n\n  return client\n}\n\nexport function getPointerId (pointer: { pointerId?: number, identifier?: number, type?: string }) {\n  return is.number(pointer.pointerId) ? pointer.pointerId! : pointer.identifier!\n}\n\nexport function setCoords (dest: CoordsSetMember, pointers: any[], timeStamp: number) {\n  const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0]\n\n  getPageXY(pointer, dest.page)\n  getClientXY(pointer, dest.client)\n\n  dest.timeStamp = timeStamp\n}\n\nexport function getTouchPair (event: TouchEvent | PointerType[]) {\n  const touches: PointerType[] = []\n\n  // array of touches is supplied\n  if (is.array(event)) {\n    touches[0] = event[0]\n    touches[1] = event[1]\n  }\n  // an event\n  else {\n    if (event.type === 'touchend') {\n      if (event.touches.length === 1) {\n        touches[0] = event.touches[0]\n        touches[1] = event.changedTouches[0]\n      } else if (event.touches.length === 0) {\n        touches[0] = event.changedTouches[0]\n        touches[1] = event.changedTouches[1]\n      }\n    } else {\n      touches[0] = event.touches[0]\n      touches[1] = event.touches[1]\n    }\n  }\n\n  return touches\n}\n\nexport function pointerAverage (pointers: PointerType[]) {\n  const average = {\n    pageX: 0,\n    pageY: 0,\n    clientX: 0,\n    clientY: 0,\n    screenX: 0,\n    screenY: 0,\n  }\n\n  type CoordKeys = keyof typeof average\n\n  for (const pointer of pointers) {\n    for (const prop in average) {\n      average[prop as CoordKeys] += pointer[prop as CoordKeys]\n    }\n  }\n  for (const prop in average) {\n    average[prop as CoordKeys] /= pointers.length\n  }\n\n  return average\n}\n\nexport function touchBBox (event: PointerType[]) {\n  if (!event.length) {\n    return null\n  }\n\n  const touches = getTouchPair(event)\n  const minX = Math.min(touches[0].pageX, touches[1].pageX)\n  const minY = Math.min(touches[0].pageY, touches[1].pageY)\n  const maxX = Math.max(touches[0].pageX, touches[1].pageX)\n  const maxY = Math.max(touches[0].pageY, touches[1].pageY)\n\n  return {\n    x: minX,\n    y: minY,\n    left: minX,\n    top: minY,\n    right: maxX,\n    bottom: maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\nexport function touchDistance (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n\n  const dx = touches[0][sourceX] - touches[1][sourceX]\n  const dy = touches[0][sourceY] - touches[1][sourceY]\n\n  return hypot(dx, dy)\n}\n\nexport function touchAngle (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n  const dx = touches[1][sourceX] - touches[0][sourceX]\n  const dy = touches[1][sourceY] - touches[0][sourceY]\n  const angle = (180 * Math.atan2(dy, dx)) / Math.PI\n\n  return angle\n}\n\nexport function getPointerType (pointer: { pointerType?: string, identifier?: number, type?: string }) {\n  return is.string(pointer.pointerType)\n    ? pointer.pointerType\n    : is.number(pointer.pointerType)\n      ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]!\n      : // if the PointerEvent API isn't available, then the \"pointer\" must\n    // be either a MouseEvent, TouchEvent, or Touch object\n      /touch/.test(pointer.type || '') || pointer instanceof dom.Touch\n        ? 'touch'\n        : 'mouse'\n}\n\n// [ event.target, event.currentTarget ]\nexport function getEventTargets (event: Event) {\n  const path = is.func(event.composedPath)\n    ? (event.composedPath() as Element[])\n    : (event as unknown as { path: Element[] }).path\n\n  return [\n    domUtils.getActualElement(path ? path[0] : (event.target as Element)),\n    domUtils.getActualElement(event.currentTarget as Element),\n  ]\n}\n\nexport function newCoords (): CoordsSetMember {\n  return {\n    page: { x: 0, y: 0 },\n    client: { x: 0, y: 0 },\n    timeStamp: 0,\n  }\n}\n\nexport function coordsToEvent (coords: MockCoords) {\n  const event = {\n    coords,\n    get page () {\n      return this.coords.page\n    },\n    get client () {\n      return this.coords.client\n    },\n    get timeStamp () {\n      return this.coords.timeStamp\n    },\n    get pageX () {\n      return this.coords.page.x\n    },\n    get pageY () {\n      return this.coords.page.y\n    },\n    get clientX () {\n      return this.coords.client.x\n    },\n    get clientY () {\n      return this.coords.client.y\n    },\n    get pointerId () {\n      return this.coords.pointerId\n    },\n    get target () {\n      return this.coords.target\n    },\n    get type () {\n      return this.coords.type\n    },\n    get pointerType () {\n      return this.coords.pointerType\n    },\n    get buttons () {\n      return this.coords.buttons\n    },\n    preventDefault () {},\n  }\n\n  return event as typeof event & PointerType & PointerEventType\n}\n\nexport interface MockCoords {\n  page: Point\n  client: Point\n  timeStamp?: number\n  pointerId?: any\n  target?: any\n  type?: string\n  pointerType?: string\n  buttons?: number\n}\n\nexport { pointerExtend }\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/types'\n\nexport class BaseEvent<T extends ActionName | null = never> {\n  declare type: string\n  declare target: EventTarget\n  declare currentTarget: Node\n  declare interactable: Interactable\n  declare _interaction: Interaction<T>\n  declare timeStamp: number\n  immediatePropagationStopped = false\n  propagationStopped = false\n\n  constructor (interaction: Interaction<T>) {\n    this._interaction = interaction\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface BaseEvent<T extends ActionName> {\n  interaction: InteractionProxy<T>\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperty(BaseEvent.prototype, 'interaction', {\n  get (this: BaseEvent) {\n    return this._interaction._proxy\n  },\n  set (this: BaseEvent) {},\n})\n","type Filter<T> = (element: T, index: number, array: T[]) => boolean\n\nexport const contains = <T>(array: T[], target: T) => array.indexOf(target) !== -1\n\nexport const remove = <T>(array: T[], target: T) => array.splice(array.indexOf(target), 1)\n\nexport const merge = <T, U>(target: Array<T | U>, source: U[]) => {\n  for (const item of source) {\n    target.push(item)\n  }\n\n  return target\n}\n\nexport const from = <T = any>(source: ArrayLike<T>) => merge([] as T[], source as T[])\n\nexport const findIndex = <T>(array: T[], func: Filter<T>) => {\n  for (let i = 0; i < array.length; i++) {\n    if (func(array[i], i, array)) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport const find = <T = any>(array: T[], func: Filter<T>) => array[findIndex(array, func)]\n","import { BaseEvent } from '@interactjs/core/BaseEvent'\nimport type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Element } from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\n\nimport type { DropState } from './plugin'\n\nexport class DropEvent extends BaseEvent<'drag'> {\n  declare target: Element\n  dropzone: Interactable\n  dragEvent: InteractEvent<'drag'>\n  relatedTarget: Element\n  draggable: Interactable\n  propagationStopped = false\n  immediatePropagationStopped = false\n\n  /**\n   * Class of events fired on dropzones during drags with acceptable targets.\n   */\n  constructor (dropState: DropState, dragEvent: InteractEvent<'drag'>, type: string) {\n    super(dragEvent._interaction)\n\n    const { element, dropzone } = type === 'dragleave' ? dropState.prev : dropState.cur\n\n    this.type = type\n    this.target = element\n    this.currentTarget = element\n    this.dropzone = dropzone\n    this.dragEvent = dragEvent\n    this.relatedTarget = dragEvent.target\n    this.draggable = dragEvent.interactable\n    this.timeStamp = dragEvent.timeStamp\n  }\n\n  /**\n   * If this is a `dropactivate` event, the dropzone element will be\n   * deactivated.\n   *\n   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the\n   * dropzone element and more.\n   */\n  reject () {\n    const { dropState } = this._interaction\n\n    if (\n      this.type !== 'dropactivate' &&\n      (!this.dropzone || dropState.cur.dropzone !== this.dropzone || dropState.cur.element !== this.target)\n    ) {\n      return\n    }\n\n    dropState.prev.dropzone = this.dropzone\n    dropState.prev.element = this.target\n\n    dropState.rejected = true\n    dropState.events.enter = null\n\n    this.stopImmediatePropagation()\n\n    if (this.type === 'dropactivate') {\n      const activeDrops = dropState.activeDrops\n      const index = arr.findIndex(\n        activeDrops,\n        ({ dropzone, element }) => dropzone === this.dropzone && element === this.target,\n      )\n\n      dropState.activeDrops.splice(index, 1)\n\n      const deactivateEvent = new DropEvent(dropState, this.dragEvent, 'dropdeactivate')\n\n      deactivateEvent.dropzone = this.dropzone\n      deactivateEvent.target = this.target\n\n      this.dropzone.fire(deactivateEvent)\n    } else {\n      this.dropzone.fire(new DropEvent(dropState, this.dragEvent, 'dragleave'))\n    }\n  }\n\n  preventDefault () {}\n\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n","import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element, PointerEventType, Rect, ListenersArg } from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { DragEvent } from '../drag/plugin'\nimport drag from '../drag/plugin'\n\nimport { DropEvent } from './DropEvent'\n\nexport type DropFunctionChecker = (\n  dragEvent: any, // related drag operation\n  event: any, // touch or mouse EventEmitter\n  dropped: boolean, // default checker result\n  dropzone: Interactable, // dropzone interactable\n  dropElement: Element, // drop zone element\n  draggable: Interactable, // draggable's Interactable\n  draggableElement: Element, // dragged element\n) => boolean\n\nexport interface DropzoneOptions extends PerActionDefaults {\n  accept?:\n  | string\n  | Element\n  | (({ dropzone, draggableElement }: { dropzone: Interactable, draggableElement: Element }) => boolean)\n  // How the overlap is checked on the drop zone\n  overlap?: 'pointer' | 'center' | number\n  checker?: DropFunctionChecker\n\n  ondropactivate?: ListenersArg\n  ondropdeactivate?: ListenersArg\n  ondragenter?: ListenersArg\n  ondragleave?: ListenersArg\n  ondropmove?: ListenersArg\n  ondrop?: ListenersArg\n}\n\nexport interface DropzoneMethod {\n  (this: Interactable, options: DropzoneOptions | boolean): Interactable\n  (): DropzoneOptions\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    dropzone: DropzoneMethod\n    dropCheck: (\n      dragEvent: InteractEvent,\n      event: PointerEventType,\n      draggable: Interactable,\n      draggableElement: Element,\n      dropElemen: Element,\n      rect: any,\n    ) => boolean\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    dropState?: DropState\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    prevDropzone?: Interactable\n    dropzone?: Interactable\n    dragEnter?: Element\n    dragLeave?: Element\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    drop: DropzoneOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    dynamicDrop?: boolean\n  }\n\n  interface SignalArgs {\n    'actions/drop:start': DropSignalArg\n    'actions/drop:move': DropSignalArg\n    'actions/drop:end': DropSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/types' {\n  interface ActionMap {\n    drop?: typeof drop\n  }\n}\n\ndeclare module '@interactjs/core/InteractStatic' {\n  interface InteractStatic {\n    dynamicDrop: (this: InteractStatic, newValue?: boolean) => boolean | this\n  }\n}\n\ninterface DropSignalArg {\n  interaction: Interaction<'drag'>\n  dragEvent: DragEvent\n}\n\nexport interface ActiveDrop {\n  dropzone: Interactable\n  element: Element\n  rect: Rect\n}\n\nexport interface DropState {\n  cur: {\n    // the dropzone a drag target might be dropped into\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  prev: {\n    // the dropzone that was recently dragged away from\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  // wheather the potential drop was rejected from a listener\n  rejected: boolean\n  // the drop events related to the current drag event\n  events: FiredDropEvents\n  activeDrops: ActiveDrop[]\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    /** @lends module:interact */\n    interactStatic: interact,\n    /** @lends Interactable */\n    Interactable,\n    defaults,\n  } = scope\n\n  scope.usePlugin(drag)\n\n  /**\n   *\n   * ```js\n   * interact('.drop').dropzone({\n   *   accept: '.can-drop' || document.getElementById('single-drop'),\n   *   overlap: 'pointer' || 'center' || zeroToOne\n   * }\n   * ```\n   *\n   * Returns or sets whether draggables can be dropped onto this target to\n   * trigger drop events\n   *\n   * Dropzones can receive the following events:\n   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n   *  - `dragmove` when a draggable that has entered the dropzone is moved\n   *  - `drop` when a draggable is dropped into this dropzone\n   *\n   * Use the `accept` option to allow only elements that match the given CSS\n   * selector or element. The value can be:\n   *\n   *  - **an Element** - only that element can be dropped into this dropzone.\n   *  - **a string**, - the element being dragged must match it as a CSS selector.\n   *  - **`null`** - accept options is cleared - it accepts any element.\n   *\n   * Use the `overlap` option to set how drops are checked for. The allowed\n   * values are:\n   *\n   *   - `'pointer'`, the pointer must be over the dropzone (default)\n   *   - `'center'`, the draggable element's center must be over the dropzone\n   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n   *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n   *   over the dropzone\n   *\n   * Use the `checker` option to specify a function to check if a dragged element\n   * is over this Interactable.\n   *\n   * @param {boolean | object | null} [options] The new options to be set.\n   * @return {object | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.dropzone = function (this: Interactable, options) {\n    return dropzoneMethod(this, options)\n  } as Interactable['dropzone']\n\n  /**\n   * ```js\n   * interact(target)\n   * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n   *                       event,             // TouchEvent/PointerEvent/MouseEvent\n   *                       dropped,           // bool result of the default checker\n   *                       dropzone,          // dropzone Interactable\n   *                       dropElement,       // dropzone elemnt\n   *                       draggable,         // draggable Interactable\n   *                       draggableElement) {// draggable element\n   *\n   *   return dropped && event.target.hasAttribute('allow-drop')\n   * }\n   * ```\n   */\n  Interactable.prototype.dropCheck = function (\n    this: Interactable,\n    dragEvent,\n    event,\n    draggable,\n    draggableElement,\n    dropElement,\n    rect,\n  ) {\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\n  }\n\n  /**\n   * Returns or sets whether the dimensions of dropzone elements are calculated\n   * on every dragmove or only on dragstart for the default dropChecker\n   *\n   * @param {boolean} [newValue] True to check on each move. False to check only\n   * before start\n   * @return {boolean | interact} The current setting or interact\n   */\n  interact.dynamicDrop = function (newValue?: boolean) {\n    if (is.bool(newValue)) {\n      // if (dragging && scope.dynamicDrop !== newValue && !newValue) {\n      //  calcRects(dropzones)\n      // }\n\n      scope.dynamicDrop = newValue\n\n      return interact\n    }\n    return scope.dynamicDrop\n  }\n\n  extend(actions.phaselessTypes, {\n    dragenter: true,\n    dragleave: true,\n    dropactivate: true,\n    dropdeactivate: true,\n    dropmove: true,\n    drop: true,\n  })\n  actions.methodDict.drop = 'dropzone'\n\n  scope.dynamicDrop = false\n\n  defaults.actions.drop = drop.defaults\n}\n\nfunction collectDrops ({ interactables }: Scope, draggableElement: Element) {\n  const drops: ActiveDrop[] = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const dropzone of interactables.list) {\n    if (!dropzone.options.drop.enabled) {\n      continue\n    }\n\n    const accept = dropzone.options.drop.accept\n\n    // test the draggable draggableElement against the dropzone's accept setting\n    if (\n      (is.element(accept) && accept !== draggableElement) ||\n      (is.string(accept) && !domUtils.matchesSelector(draggableElement, accept)) ||\n      (is.func(accept) && !accept({ dropzone, draggableElement }))\n    ) {\n      continue\n    }\n\n    // query for new elements if necessary\n    const dropElements = (\n      is.string(dropzone.target)\n        ? dropzone._context.querySelectorAll(dropzone.target)\n        : is.array(dropzone.target)\n          ? dropzone.target\n          : [dropzone.target]\n    ) as Element[]\n\n    for (const dropzoneElement of dropElements) {\n      if (dropzoneElement !== draggableElement) {\n        drops.push({\n          dropzone,\n          element: dropzoneElement,\n          rect: dropzone.getRect(dropzoneElement),\n        })\n      }\n    }\n  }\n\n  return drops\n}\n\nfunction fireActivationEvents (activeDrops: ActiveDrop[], event: DropEvent) {\n  // loop through all active dropzones and trigger event\n  for (const { dropzone, element } of activeDrops.slice()) {\n    event.dropzone = dropzone\n\n    // set current element as event target\n    event.target = element\n    dropzone.fire(event)\n    event.propagationStopped = event.immediatePropagationStopped = false\n  }\n}\n\n// return a new array of possible drops. getActiveDrops should always be\n// called when a drag has just started or a drag event happens while\n// dynamicDrop is true\nfunction getActiveDrops (scope: Scope, dragElement: Element) {\n  // get dropzones and their elements that could receive the draggable\n  const activeDrops = collectDrops(scope, dragElement)\n\n  for (const activeDrop of activeDrops) {\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\n  }\n\n  return activeDrops\n}\n\nfunction getDrop (\n  { dropState, interactable: draggable, element: dragElement }: Partial<Interaction>,\n  dragEvent,\n  pointerEvent,\n) {\n  const validDrops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {\n    validDrops.push(\n      dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)\n        ? dropzoneElement\n        : null,\n    )\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = domUtils.indexOfDeepestElement(validDrops)\n\n  return dropState.activeDrops[dropIndex] || null\n}\n\nfunction getDropEvents (interaction: Interaction, _pointerEvent, dragEvent: DragEvent) {\n  const { dropState } = interaction\n  const dropEvents = {\n    enter: null,\n    leave: null,\n    activate: null,\n    deactivate: null,\n    move: null,\n    drop: null,\n  }\n\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = new DropEvent(dropState, dragEvent, 'dropactivate')\n\n    dropEvents.activate.target = null\n    dropEvents.activate.dropzone = null\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = new DropEvent(dropState, dragEvent, 'dropdeactivate')\n\n    dropEvents.deactivate.target = null\n    dropEvents.deactivate.dropzone = null\n  }\n\n  if (dropState.rejected) {\n    return dropEvents\n  }\n\n  if (dropState.cur.element !== dropState.prev.element) {\n    // if there was a previous dropzone, create a dragleave event\n    if (dropState.prev.dropzone) {\n      dropEvents.leave = new DropEvent(dropState, dragEvent, 'dragleave')\n\n      dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone\n    }\n    // if dropzone is not null, create a dragenter event\n    if (dropState.cur.dropzone) {\n      dropEvents.enter = new DropEvent(dropState, dragEvent, 'dragenter')\n\n      dragEvent.dragEnter = dropState.cur.element\n      dragEvent.dropzone = dropState.cur.dropzone\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && dropState.cur.dropzone) {\n    dropEvents.drop = new DropEvent(dropState, dragEvent, 'drop')\n\n    dragEvent.dropzone = dropState.cur.dropzone\n    dragEvent.relatedTarget = dropState.cur.element\n  }\n  if (dragEvent.type === 'dragmove' && dropState.cur.dropzone) {\n    dropEvents.move = new DropEvent(dropState, dragEvent, 'dropmove')\n\n    dropEvents.move.dragmove = dragEvent\n    dragEvent.dropzone = dropState.cur.dropzone\n  }\n\n  return dropEvents\n}\n\ntype FiredDropEvents = Partial<\nRecord<'leave' | 'enter' | 'move' | 'drop' | 'activate' | 'deactivate', DropEvent>\n>\n\nfunction fireDropEvents (interaction: Interaction, events: FiredDropEvents) {\n  const { dropState } = interaction\n  const { activeDrops, cur, prev } = dropState\n\n  if (events.leave) {\n    prev.dropzone.fire(events.leave)\n  }\n  if (events.enter) {\n    cur.dropzone.fire(events.enter)\n  }\n  if (events.move) {\n    cur.dropzone.fire(events.move)\n  }\n  if (events.drop) {\n    cur.dropzone.fire(events.drop)\n  }\n\n  if (events.deactivate) {\n    fireActivationEvents(activeDrops, events.deactivate)\n  }\n\n  dropState.prev.dropzone = cur.dropzone\n  dropState.prev.element = cur.element\n}\n\nfunction onEventCreated ({ interaction, iEvent, event }: DoPhaseArg<'drag', EventPhase>, scope: Scope) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\n    return\n  }\n\n  const { dropState } = interaction\n\n  if (scope.dynamicDrop) {\n    dropState.activeDrops = getActiveDrops(scope, interaction.element)\n  }\n\n  const dragEvent = iEvent\n  const dropResult = getDrop(interaction, dragEvent, event)\n\n  // update rejected status\n  dropState.rejected =\n    dropState.rejected &&\n    !!dropResult &&\n    dropResult.dropzone === dropState.cur.dropzone &&\n    dropResult.element === dropState.cur.element\n\n  dropState.cur.dropzone = dropResult && dropResult.dropzone\n  dropState.cur.element = dropResult && dropResult.element\n\n  dropState.events = getDropEvents(interaction, event, dragEvent)\n}\n\nfunction dropzoneMethod(interactable: Interactable): DropzoneOptions\nfunction dropzoneMethod(interactable: Interactable, options: DropzoneOptions | boolean): Interactable\nfunction dropzoneMethod (interactable: Interactable, options?: DropzoneOptions | boolean) {\n  if (is.object(options)) {\n    interactable.options.drop.enabled = options.enabled !== false\n\n    if (options.listeners) {\n      const normalized = normalizeListeners(options.listeners)\n      // rename 'drop' to '' as it will be prefixed with 'drop'\n      const corrected = Object.keys(normalized).reduce((acc, type) => {\n        const correctedType = /^(enter|leave)/.test(type)\n          ? `drag${type}`\n          : /^(activate|deactivate|move)/.test(type)\n            ? `drop${type}`\n            : type\n\n        acc[correctedType] = normalized[type]\n\n        return acc\n      }, {})\n\n      interactable.off(interactable.options.drop.listeners)\n      interactable.on(corrected)\n      interactable.options.drop.listeners = corrected\n    }\n\n    if (is.func(options.ondrop)) {\n      interactable.on('drop', options.ondrop)\n    }\n    if (is.func(options.ondropactivate)) {\n      interactable.on('dropactivate', options.ondropactivate)\n    }\n    if (is.func(options.ondropdeactivate)) {\n      interactable.on('dropdeactivate', options.ondropdeactivate)\n    }\n    if (is.func(options.ondragenter)) {\n      interactable.on('dragenter', options.ondragenter)\n    }\n    if (is.func(options.ondragleave)) {\n      interactable.on('dragleave', options.ondragleave)\n    }\n    if (is.func(options.ondropmove)) {\n      interactable.on('dropmove', options.ondropmove)\n    }\n\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\n      interactable.options.drop.overlap = options.overlap\n    } else if (is.number(options.overlap)) {\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\n    }\n    if ('accept' in options) {\n      interactable.options.drop.accept = options.accept\n    }\n    if ('checker' in options) {\n      interactable.options.drop.checker = options.checker\n    }\n\n    return interactable\n  }\n\n  if (is.bool(options)) {\n    interactable.options.drop.enabled = options\n\n    return interactable\n  }\n\n  return interactable.options.drop\n}\n\nfunction dropCheckMethod (\n  interactable: Interactable,\n  dragEvent: InteractEvent,\n  event: PointerEventType,\n  draggable: Interactable,\n  draggableElement: Element,\n  dropElement: Element,\n  rect: any,\n) {\n  let dropped = false\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || interactable.getRect(dropElement))) {\n    return interactable.options.drop.checker\n      ? interactable.options.drop.checker(\n        dragEvent,\n        event,\n        dropped,\n        interactable,\n        dropElement,\n        draggable,\n        draggableElement,\n      )\n      : false\n  }\n\n  const dropOverlap = interactable.options.drop.overlap\n\n  if (dropOverlap === 'pointer') {\n    const origin = getOriginXY(draggable, draggableElement, 'drag')\n    const page = pointerUtils.getPageXY(dragEvent)\n\n    page.x += origin.x\n    page.y += origin.y\n\n    const horizontal = page.x > rect.left && page.x < rect.right\n    const vertical = page.y > rect.top && page.y < rect.bottom\n\n    dropped = horizontal && vertical\n  }\n\n  const dragRect = draggable.getRect(draggableElement)\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width / 2\n    const cy = dragRect.top + dragRect.height / 2\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom\n  }\n\n  if (dragRect && is.number(dropOverlap)) {\n    const overlapArea =\n      Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\n      Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top))\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\n\n    dropped = overlapRatio >= dropOverlap\n  }\n\n  if (interactable.options.drop.checker) {\n    dropped = interactable.options.drop.checker(\n      dragEvent,\n      event,\n      dropped,\n      interactable,\n      dropElement,\n      draggable,\n      draggableElement,\n    )\n  }\n\n  return dropped\n}\n\nconst drop: Plugin = {\n  id: 'actions/drop',\n  install,\n  listeners: {\n    'interactions:before-action-start': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      interaction.dropState = {\n        cur: {\n          dropzone: null,\n          element: null,\n        },\n        prev: {\n          dropzone: null,\n          element: null,\n        },\n        rejected: null,\n        events: null,\n        activeDrops: [],\n      }\n    },\n\n    'interactions:after-action-start': (\n      { interaction, event, iEvent: dragEvent }: DoPhaseArg<'drag', EventPhase>,\n      scope,\n    ) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      // reset active dropzones\n      dropState.activeDrops = null\n      dropState.events = null\n      dropState.activeDrops = getActiveDrops(scope, interaction.element)\n      dropState.events = getDropEvents(interaction, event, dragEvent)\n\n      if (dropState.events.activate) {\n        fireActivationEvents(dropState.activeDrops, dropState.events.activate)\n        scope.fire('actions/drop:start', { interaction, dragEvent })\n      }\n    },\n\n    'interactions:action-move': onEventCreated,\n\n    'interactions:after-action-move': (\n      { interaction, iEvent: dragEvent }: DoPhaseArg<'drag', EventPhase>,\n      scope,\n    ) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      fireDropEvents(interaction, interaction.dropState.events)\n\n      scope.fire('actions/drop:move', { interaction, dragEvent })\n      interaction.dropState.events = {}\n    },\n\n    'interactions:action-end': (arg: DoPhaseArg<'drag', EventPhase>, scope) => {\n      if (arg.interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { interaction, iEvent: dragEvent } = arg\n\n      onEventCreated(arg, scope)\n      fireDropEvents(interaction, interaction.dropState.events)\n      scope.fire('actions/drop:end', { interaction, dragEvent })\n    },\n\n    'interactions:stop': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      if (dropState) {\n        dropState.activeDrops = null\n        dropState.events = null\n        dropState.cur.dropzone = null\n        dropState.cur.element = null\n        dropState.prev.dropzone = null\n        dropState.prev.element = null\n        dropState.rejected = false\n      }\n    },\n  },\n  getActiveDrops,\n  getDrop,\n  getDropEvents,\n  fireDropEvents,\n  defaults: {\n    enabled: false,\n    accept: null,\n    overlap: 'pointer',\n  } as DropzoneOptions,\n}\n\nexport default drop\n","import type { InteractEvent, EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionMethod, Rect, PointerType, ListenersArg } from '@interactjs/core/types'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nexport type GesturableMethod = ActionMethod<GesturableOptions>\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    gesture?: {\n      angle: number // angle from first to second touch\n      distance: number\n      scale: number // gesture.distance / gesture.startDistance\n      startAngle: number // angle of line joining two touches\n      startDistance: number // distance between two touches of touchStart\n    }\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    gesturable: GesturableMethod\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    gesture: GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/types' {\n  interface ActionMap {\n    gesture?: typeof gesture\n  }\n}\n\nexport interface GesturableOptions extends PerActionDefaults {\n  onstart?: ListenersArg\n  onmove?: ListenersArg\n  onend?: ListenersArg\n}\n\nexport interface GestureEvent extends InteractEvent<'gesture'> {\n  distance: number\n  angle: number\n  da: number // angle change\n  scale: number // ratio of distance start to current event\n  ds: number // scale change\n  box: Rect // enclosing box of all points\n  touches: PointerType[]\n}\n\nexport interface GestureSignalArg extends DoPhaseArg<'gesture', EventPhase> {\n  iEvent: GestureEvent\n  interaction: Interaction<'gesture'>\n}\n\nfunction install (scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  /**\n   * ```js\n   * interact(element).gesturable({\n   *     onstart: function (event) {},\n   *     onmove : function (event) {},\n   *     onend  : function (event) {},\n   *\n   *     // limit multiple gestures.\n   *     // See the explanation in {@link Interactable.draggable} example\n   *     max: Infinity,\n   *     maxPerElement: 1,\n   * })\n   *\n   * var isGestureable = interact(element).gesturable()\n   * ```\n   *\n   * Gets or sets whether multitouch gestures can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on gesture events (makes the Interactable gesturable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of gesture events, or this Interactable\n   */\n  Interactable.prototype.gesturable = function (\n    this: InstanceType<typeof Interactable>,\n    options: GesturableOptions | boolean,\n  ) {\n    if (is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction('gesture', options)\n      this.setOnEvents('gesture', options)\n\n      return this\n    }\n\n    if (is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as GesturableOptions\n  } as GesturableMethod\n\n  actions.map.gesture = gesture\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nfunction updateGestureProps ({ interaction, iEvent, phase }: GestureSignalArg) {\n  if (interaction.prepared.name !== 'gesture') return\n\n  const pointers = interaction.pointers.map((p) => p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.interactable.options.deltaSource\n\n  iEvent.touches = [pointers[0], pointers[1]]\n\n  if (starting) {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = 1\n    iEvent.ds = 0\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n    iEvent.da = 0\n\n    interaction.gesture.startDistance = iEvent.distance\n    interaction.gesture.startAngle = iEvent.angle\n  } else if (ending) {\n    const prevEvent = interaction.prevEvent as GestureEvent\n\n    iEvent.distance = prevEvent.distance\n    iEvent.box = prevEvent.box\n    iEvent.scale = prevEvent.scale\n    iEvent.ds = 0\n    iEvent.angle = prevEvent.angle\n    iEvent.da = 0\n  } else {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\n    iEvent.da = iEvent.angle - interaction.gesture.angle\n  }\n\n  interaction.gesture.distance = iEvent.distance\n  interaction.gesture.angle = iEvent.angle\n\n  if (is.number(iEvent.scale) && iEvent.scale !== Infinity && !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nconst gesture: Plugin = {\n  id: 'actions/gesture',\n  before: ['actions/drag', 'actions/resize'],\n  install,\n  listeners: {\n    'interactions:action-start': updateGestureProps,\n    'interactions:action-move': updateGestureProps,\n    'interactions:action-end': updateGestureProps,\n\n    'interactions:new': ({ interaction }) => {\n      interaction.gesture = {\n        angle: 0,\n        distance: 0,\n        scale: 1,\n        startAngle: 0,\n        startDistance: 0,\n      }\n    },\n\n    'auto-start:check': (arg) => {\n      if (arg.interaction.pointers.length < 2) {\n        return undefined\n      }\n\n      const gestureOptions = arg.interactable.options.gesture\n\n      if (!(gestureOptions && gestureOptions.enabled)) {\n        return undefined\n      }\n\n      arg.action = { name: 'gesture' }\n\n      return false\n    },\n  },\n\n  defaults: {},\n\n  getCursor () {\n    return ''\n  },\n}\n\nexport default gesture\n","import type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type {\n  ActionName,\n  ActionProps,\n  ActionMethod,\n  EdgeOptions,\n  FullRect,\n  ListenersArg,\n  OrBoolean,\n  Point,\n  Rect,\n} from '@interactjs/core/types'\nimport * as dom from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nexport type EdgeName = 'top' | 'left' | 'bottom' | 'right'\n\nexport type ResizableMethod = ActionMethod<ResizableOptions>\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    resizable: ResizableMethod\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction<T extends ActionName | null = ActionName> {\n    resizeAxes: 'x' | 'y' | 'xy'\n    resizeStartAspectRatio: number\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    resize: ResizableOptions\n  }\n}\n\ndeclare module '@interactjs/core/types' {\n  interface ActionMap {\n    resize?: typeof resize\n  }\n}\n\nexport interface ResizableOptions extends PerActionDefaults {\n  square?: boolean\n  preserveAspectRatio?: boolean\n  edges?: EdgeOptions | null\n  axis?: 'x' | 'y' | 'xy' // deprecated\n  invert?: 'none' | 'negate' | 'reposition'\n  margin?: number\n  squareResize?: boolean\n  oninertiastart?: ListenersArg\n  onstart?: ListenersArg\n  onmove?: ListenersArg\n  onend?: ListenersArg\n}\n\nexport interface ResizeEvent<P extends EventPhase = EventPhase> extends InteractEvent<'resize', P> {\n  deltaRect?: FullRect\n  edges?: ActionProps['edges']\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    browser,\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n    defaults,\n  } = scope\n\n  // Less Precision with touch input\n\n  resize.cursors = initCursors(browser)\n  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10\n\n  /**\n   * ```js\n   * interact(element).resizable({\n   *   onstart: function (event) {},\n   *   onmove : function (event) {},\n   *   onend  : function (event) {},\n   *\n   *   edges: {\n   *     top   : true,       // Use pointer coords to check for resize.\n   *     left  : false,      // Disable resizing from left edge.\n   *     bottom: '.resize-s',// Resize if pointer target matches selector\n   *     right : handleEl    // Resize if pointer target is the given Element\n   *   },\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height are adjusted at a 1:1 ratio.\n   *     square: false,\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height maintain the aspect ratio they had when resizing started.\n   *     preserveAspectRatio: false,\n   *\n   *   // a value of 'none' will limit the resize rect to a minimum of 0x0\n   *   // 'negate' will allow the rect to have negative width/height\n   *   // 'reposition' will keep the width/height positive by swapping\n   *   // the top and bottom edges and/or swapping the left and right edges\n   *   invert: 'none' || 'negate' || 'reposition'\n   *\n   *   // limit multiple resizes.\n   *   // See the explanation in the {@link Interactable.draggable} example\n   *   max: Infinity,\n   *   maxPerElement: 1,\n   * })\n   *\n   * var isResizeable = interact(element).resizable()\n   * ```\n   *\n   * Gets or sets whether resize actions can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on resize events (object makes the Interactable\n   * resizable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of resize elements, or this Interactable\n   */\n  Interactable.prototype.resizable = function (this: Interactable, options: ResizableOptions | boolean) {\n    return resizable(this, options, scope)\n  } as ResizableMethod\n\n  actions.map.resize = resize\n  actions.methodDict.resize = 'resizable'\n\n  defaults.actions.resize = resize.defaults\n}\n\nfunction resizeChecker (arg) {\n  const { interaction, interactable, element, rect, buttons } = arg\n\n  if (!rect) {\n    return undefined\n  }\n\n  const page = extend({}, interaction.coords.cur.page)\n  const resizeOptions = interactable.options.resize\n\n  if (\n    !(resizeOptions && resizeOptions.enabled) ||\n    // check mouseButton setting if the pointer is down\n    (interaction.pointerIsDown &&\n      /mouse|pointer/.test(interaction.pointerType) &&\n      (buttons & resizeOptions.mouseButtons) === 0)\n  ) {\n    return undefined\n  }\n\n  // if using resize.edges\n  if (is.object(resizeOptions.edges)) {\n    const resizeEdges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false,\n    }\n\n    for (const edge in resizeEdges) {\n      resizeEdges[edge] = checkResizeEdge(\n        edge,\n        resizeOptions.edges[edge],\n        page,\n        interaction._latestPointer.eventTarget,\n        element,\n        rect,\n        resizeOptions.margin || resize.defaultMargin,\n      )\n    }\n\n    resizeEdges.left = resizeEdges.left && !resizeEdges.right\n    resizeEdges.top = resizeEdges.top && !resizeEdges.bottom\n\n    if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n      arg.action = {\n        name: 'resize',\n        edges: resizeEdges,\n      }\n    }\n  } else {\n    const right = resizeOptions.axis !== 'y' && page.x > rect.right - resize.defaultMargin\n    const bottom = resizeOptions.axis !== 'x' && page.y > rect.bottom - resize.defaultMargin\n\n    if (right || bottom) {\n      arg.action = {\n        name: 'resize',\n        axes: (right ? 'x' : '') + (bottom ? 'y' : ''),\n      }\n    }\n  }\n\n  return arg.action ? false : undefined\n}\n\nfunction resizable (interactable: Interactable, options: OrBoolean<ResizableOptions> | boolean, scope: Scope) {\n  if (is.object(options)) {\n    interactable.options.resize.enabled = options.enabled !== false\n    interactable.setPerAction('resize', options)\n    interactable.setOnEvents('resize', options)\n\n    if (is.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {\n      interactable.options.resize.axis = options.axis\n    } else if (options.axis === null) {\n      interactable.options.resize.axis = scope.defaults.actions.resize.axis\n    }\n\n    if (is.bool(options.preserveAspectRatio)) {\n      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio\n    } else if (is.bool(options.square)) {\n      interactable.options.resize.square = options.square\n    }\n\n    return interactable\n  }\n  if (is.bool(options)) {\n    interactable.options.resize.enabled = options\n\n    return interactable\n  }\n  return interactable.options.resize\n}\n\nfunction checkResizeEdge (\n  name: string,\n  value: any,\n  page: Point,\n  element: Node,\n  interactableElement: Element,\n  rect: Rect,\n  margin: number,\n) {\n  // false, '', undefined, null\n  if (!value) {\n    return false\n  }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, \"switch\" edges\n    const width = is.number(rect.width) ? rect.width : rect.right - rect.left\n    const height = is.number(rect.height) ? rect.height : rect.bottom - rect.top\n\n    // don't use margin greater than half the relevent dimension\n    margin = Math.min(margin, Math.abs((name === 'left' || name === 'right' ? width : height) / 2))\n\n    if (width < 0) {\n      if (name === 'left') {\n        name = 'right'\n      } else if (name === 'right') {\n        name = 'left'\n      }\n    }\n    if (height < 0) {\n      if (name === 'top') {\n        name = 'bottom'\n      } else if (name === 'bottom') {\n        name = 'top'\n      }\n    }\n\n    if (name === 'left') {\n      const edge = width >= 0 ? rect.left : rect.right\n      return page.x < edge + margin\n    }\n    if (name === 'top') {\n      const edge = height >= 0 ? rect.top : rect.bottom\n      return page.y < edge + margin\n    }\n\n    if (name === 'right') {\n      return page.x > (width >= 0 ? rect.right : rect.left) - margin\n    }\n    if (name === 'bottom') {\n      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin\n    }\n  }\n\n  // the remaining checks require an element\n  if (!is.element(element)) {\n    return false\n  }\n\n  return is.element(value)\n    ? // the value is an element to use as a resize handle\n    value === element\n    : // otherwise check if element matches value as selector\n    dom.matchesUpTo(element, value, interactableElement)\n}\n\n/* eslint-disable multiline-ternary */\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nfunction initCursors (browser: typeof import('@interactjs/utils/browser').default) {\n  return browser.isIe9\n    ? {\n      x: 'e-resize',\n      y: 's-resize',\n      xy: 'se-resize',\n\n      top: 'n-resize',\n      left: 'w-resize',\n      bottom: 's-resize',\n      right: 'e-resize',\n      topleft: 'se-resize',\n      bottomright: 'se-resize',\n      topright: 'ne-resize',\n      bottomleft: 'ne-resize',\n    }\n    : {\n      x: 'ew-resize',\n      y: 'ns-resize',\n      xy: 'nwse-resize',\n\n      top: 'ns-resize',\n      left: 'ew-resize',\n      bottom: 'ns-resize',\n      right: 'ew-resize',\n      topleft: 'nwse-resize',\n      bottomright: 'nwse-resize',\n      topright: 'nesw-resize',\n      bottomleft: 'nesw-resize',\n    }\n}\n/* eslint-enable multiline-ternary */\n\nfunction start ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {\n    return\n  }\n\n  const resizeEvent = iEvent as ResizeEvent\n  const rect = interaction.rect\n\n  interaction._rects = {\n    start: extend({}, rect),\n    corrected: extend({}, rect),\n    previous: extend({}, rect),\n    delta: {\n      left: 0,\n      right: 0,\n      width: 0,\n      top: 0,\n      bottom: 0,\n      height: 0,\n    },\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction move ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\n\n  const resizeEvent = iEvent as ResizeEvent\n  const resizeOptions = interaction.interactable.options.resize\n  const invert = resizeOptions.invert\n  const invertible = invert === 'reposition' || invert === 'negate'\n\n  const current = interaction.rect\n  const { start: startRect, corrected, delta: deltaRect, previous } = interaction._rects\n\n  extend(previous, corrected)\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    extend(corrected, current)\n\n    if (invert === 'reposition') {\n      // swap edge values if necessary to keep width/height positive\n      if (corrected.top > corrected.bottom) {\n        const swap = corrected.top\n\n        corrected.top = corrected.bottom\n        corrected.bottom = swap\n      }\n      if (corrected.left > corrected.right) {\n        const swap = corrected.left\n\n        corrected.left = corrected.right\n        corrected.right = swap\n      }\n    }\n  } else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    corrected.top = Math.min(current.top, startRect.bottom)\n    corrected.bottom = Math.max(current.bottom, startRect.top)\n    corrected.left = Math.min(current.left, startRect.right)\n    corrected.right = Math.max(current.right, startRect.left)\n  }\n\n  corrected.width = corrected.right - corrected.left\n  corrected.height = corrected.bottom - corrected.top\n\n  for (const edge in corrected) {\n    deltaRect[edge] = corrected[edge] - previous[edge]\n  }\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = corrected\n  resizeEvent.deltaRect = deltaRect\n}\n\nfunction end ({ iEvent, interaction }: { iEvent: InteractEvent<any, any>, interaction: Interaction }) {\n  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) return\n\n  const resizeEvent = iEvent as ResizeEvent\n\n  resizeEvent.edges = interaction.prepared.edges\n  resizeEvent.rect = interaction._rects.corrected\n  resizeEvent.deltaRect = interaction._rects.delta\n}\n\nfunction updateEventAxes ({\n  iEvent,\n  interaction,\n}: {\n  iEvent: InteractEvent<any, any>\n  interaction: Interaction\n}) {\n  if (interaction.prepared.name !== 'resize' || !interaction.resizeAxes) return\n\n  const options = interaction.interactable.options\n  const resizeEvent = iEvent as ResizeEvent\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = resizeEvent.delta.y\n    } else {\n      resizeEvent.delta.y = resizeEvent.delta.x\n    }\n    resizeEvent.axes = 'xy'\n  } else {\n    resizeEvent.axes = interaction.resizeAxes\n\n    if (interaction.resizeAxes === 'x') {\n      resizeEvent.delta.y = 0\n    } else if (interaction.resizeAxes === 'y') {\n      resizeEvent.delta.x = 0\n    }\n  }\n}\n\nconst resize: Plugin = {\n  id: 'actions/resize',\n  before: ['actions/drag'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.resizeAxes = 'xy'\n    },\n\n    'interactions:action-start': (arg) => {\n      start(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-move': (arg) => {\n      move(arg)\n      updateEventAxes(arg)\n    },\n    'interactions:action-end': end,\n    'auto-start:check': resizeChecker,\n  },\n\n  defaults: {\n    square: false,\n    preserveAspectRatio: false,\n    axis: 'xy',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of 'none' will limit the resize rect to a minimum of 0x0\n    // 'negate' will alow the rect to have negative width/height\n    // 'reposition' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: 'none',\n  } as ResizableOptions,\n\n  cursors: null as ReturnType<typeof initCursors>,\n\n  getCursor ({ edges, axis, name }: ActionProps) {\n    const cursors = resize.cursors\n    let result: string = null\n\n    if (axis) {\n      result = cursors[name + axis]\n    } else if (edges) {\n      let cursorKey = ''\n\n      for (const edge of ['top', 'bottom', 'left', 'right']) {\n        if (edges[edge]) {\n          cursorKey += edge\n        }\n      }\n\n      result = cursors[cursorKey]\n    }\n\n    return result\n  },\n\n  defaultMargin: null as number,\n}\n\nexport default resize\n","import type { Scope } from '@interactjs/core/scope'\n\nimport drag from './drag/plugin'\nimport drop from './drop/plugin'\nimport gesture from './gesture/plugin'\nimport resize from './resize/plugin'\n\nexport default {\n  id: 'actions',\n  install (scope: Scope) {\n    scope.usePlugin(gesture)\n    scope.usePlugin(resize)\n    scope.usePlugin(drag)\n    scope.usePlugin(drop)\n  },\n}\n","let lastTime = 0\nlet request: typeof requestAnimationFrame\nlet cancel: typeof cancelAnimationFrame\n\nfunction init (global: Window | typeof globalThis) {\n  request = global.requestAnimationFrame\n  cancel = global.cancelAnimationFrame\n\n  if (!request) {\n    const vendors = ['ms', 'moz', 'webkit', 'o']\n\n    for (const vendor of vendors) {\n      request = global[`${vendor}RequestAnimationFrame` as 'requestAnimationFrame']\n      cancel =\n        global[`${vendor}CancelAnimationFrame` as 'cancelAnimationFrame'] ||\n        global[`${vendor}CancelRequestAnimationFrame` as 'cancelAnimationFrame']\n    }\n  }\n\n  request = request && request.bind(global)\n  cancel = cancel && cancel.bind(global)\n\n  if (!request) {\n    request = (callback) => {\n      const currTime = Date.now()\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime))\n      const token = global.setTimeout(() => {\n        // eslint-disable-next-line n/no-callback-literal\n        callback(currTime + timeToCall)\n      }, timeToCall)\n\n      lastTime = currTime + timeToCall\n      return token as any\n    }\n\n    cancel = (token) => clearTimeout(token)\n  }\n}\n\nexport default {\n  request: (callback: FrameRequestCallback) => request(callback),\n  cancel: (token: number) => cancel(token),\n  init,\n}\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, PointerType } from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport { getStringOptionResult } from '@interactjs/utils/rect'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoScroll: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoScroll?: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    autoScroll?: AutoScrollOptions\n  }\n}\n\nexport interface AutoScrollOptions {\n  container?: Window | HTMLElement | string\n  margin?: number\n  distance?: number\n  interval?: number\n  speed?: number\n  enabled?: boolean\n}\n\nfunction install (scope: Scope) {\n  const { defaults, actions } = scope\n\n  scope.autoScroll = autoScroll\n  autoScroll.now = () => scope.now()\n\n  actions.phaselessTypes.autoscroll = true\n  defaults.perAction.autoScroll = autoScroll.defaults\n}\n\nconst autoScroll = {\n  defaults: {\n    enabled: false,\n    margin: 60,\n\n    // the item that is scrolled (Window or HTMLElement)\n    container: null as AutoScrollOptions['container'],\n\n    // the scroll speed in pixels per second\n    speed: 300,\n  } as AutoScrollOptions,\n\n  now: Date.now,\n\n  interaction: null as Interaction<ActionName> | null,\n  i: 0, // the handle returned by window.setInterval\n\n  // Direction each pulse is to scroll in\n  x: 0,\n  y: 0,\n\n  isScrolling: false,\n  prevTime: 0,\n  margin: 0,\n  speed: 0,\n\n  start (interaction: Interaction) {\n    autoScroll.isScrolling = true\n    raf.cancel(autoScroll.i)\n\n    interaction.autoScroll = autoScroll\n    autoScroll.interaction = interaction\n    autoScroll.prevTime = autoScroll.now()\n    autoScroll.i = raf.request(autoScroll.scroll)\n  },\n\n  stop () {\n    autoScroll.isScrolling = false\n    if (autoScroll.interaction) {\n      autoScroll.interaction.autoScroll = null\n    }\n    raf.cancel(autoScroll.i)\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll () {\n    const { interaction } = autoScroll\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n    const now = autoScroll.now()\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000\n    // displacement\n    const s = options.speed * dt\n\n    if (s >= 1) {\n      const scrollBy = {\n        x: autoScroll.x * s,\n        y: autoScroll.y * s,\n      }\n\n      if (scrollBy.x || scrollBy.y) {\n        const prevScroll = getScroll(container)\n\n        if (is.window(container)) {\n          container.scrollBy(scrollBy.x, scrollBy.y)\n        } else if (container) {\n          container.scrollLeft += scrollBy.x\n          container.scrollTop += scrollBy.y\n        }\n\n        const curScroll = getScroll(container)\n        const delta = {\n          x: curScroll.x - prevScroll.x,\n          y: curScroll.y - prevScroll.y,\n        }\n\n        if (delta.x || delta.y) {\n          interactable.fire({\n            type: 'autoscroll',\n            target: element,\n            interactable,\n            delta,\n            interaction,\n            container,\n          })\n        }\n      }\n\n      autoScroll.prevTime = now\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i)\n      autoScroll.i = raf.request(autoScroll.scroll)\n    }\n  },\n  check (interactable: Interactable, actionName: ActionName) {\n    const options = interactable.options\n\n    return options[actionName].autoScroll?.enabled\n  },\n  onInteractionMove<T extends ActionName> ({\n    interaction,\n    pointer,\n  }: {\n    interaction: Interaction<T>\n    pointer: PointerType\n  }) {\n    if (\n      !(interaction.interacting() && autoScroll.check(interaction.interactable, interaction.prepared.name))\n    ) {\n      return\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0\n      return\n    }\n\n    let top: boolean\n    let right: boolean\n    let bottom: boolean\n    let left: boolean\n\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n\n    if (is.window(container)) {\n      left = pointer.clientX < autoScroll.margin\n      top = pointer.clientY < autoScroll.margin\n      right = pointer.clientX > container.innerWidth - autoScroll.margin\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin\n    } else {\n      const rect = domUtils.getElementClientRect(container)\n\n      left = pointer.clientX < rect.left + autoScroll.margin\n      top = pointer.clientY < rect.top + autoScroll.margin\n      right = pointer.clientX > rect.right - autoScroll.margin\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin\n    }\n\n    autoScroll.x = right ? 1 : left ? -1 : 0\n    autoScroll.y = bottom ? 1 : top ? -1 : 0\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin\n      autoScroll.speed = options.speed\n\n      autoScroll.start(interaction)\n    }\n  },\n}\n\nexport function getContainer (value: any, interactable: Interactable, element: Element) {\n  return (\n    (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element)\n  )\n}\n\nexport function getScroll (container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollLeft, y: container.scrollTop }\n}\n\nexport function getScrollSize (container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollWidth, y: container.scrollHeight }\n}\n\nexport function getScrollSizeDelta<T extends ActionName> (\n  {\n    interaction,\n    element,\n  }: {\n    interaction: Partial<Interaction<T>>\n    element: Element\n  },\n  func: any,\n) {\n  const scrollOptions = interaction && interaction.interactable.options[interaction.prepared.name].autoScroll\n\n  if (!scrollOptions || !scrollOptions.enabled) {\n    func()\n    return { x: 0, y: 0 }\n  }\n\n  const scrollContainer = getContainer(scrollOptions.container, interaction.interactable, element)\n\n  const prevSize = getScroll(scrollContainer)\n  func()\n  const curSize = getScroll(scrollContainer)\n\n  return {\n    x: curSize.x - prevSize.x,\n    y: curSize.y - prevSize.y,\n  }\n}\n\nconst autoScrollPlugin: Plugin = {\n  id: 'auto-scroll',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoScroll = null\n    },\n\n    'interactions:destroy': ({ interaction }) => {\n      interaction.autoScroll = null\n      autoScroll.stop()\n      if (autoScroll.interaction) {\n        autoScroll.interaction = null\n      }\n    },\n\n    'interactions:stop': autoScroll.stop,\n\n    'interactions:action-move': (arg: any) => autoScroll.onInteractionMove(arg),\n  },\n}\n\nexport default autoScrollPlugin\n","import type { ActionName, ActionProps } from '@interactjs/core/types'\n\nimport { window } from './window'\n\nexport function warnOnce<T> (this: T, method: (...args: any[]) => any, message: string) {\n  let warned = false\n\n  return function (this: T) {\n    if (!warned) {\n      ;(window as any).console.warn(message)\n      warned = true\n    }\n\n    return method.apply(this, arguments)\n  }\n}\n\nexport function copyAction<T extends ActionName> (dest: ActionProps<any>, src: ActionProps<T>) {\n  dest.name = src.name\n  dest.axis = src.axis\n  dest.edges = src.edges\n\n  return dest\n}\n\nexport const sign = (n: number) => (n >= 0 ? 1 : -1)\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { ActionProps, PointerType, PointerEventType, Element } from '@interactjs/core/types'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interactable,\n      pointer: PointerType,\n      event: PointerEventType,\n      interaction: Interaction,\n      element: Element,\n    ) => ActionProps | null\n    styleCursor: typeof styleCursor\n    actionChecker: typeof actionChecker\n    ignoreFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n    allowFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction (\n    this: Interactable,\n    pointer: PointerType,\n    event: PointerEventType,\n    interaction: Interaction,\n    element: Element,\n  ): ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  /**\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n   * of it's parents match the given CSS selector or Element, no\n   * drag/resize/gesture is started.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .draggable({\n   *     ignoreFrom: 'input, textarea, a[href]'',\n   *   })\n   *   .pointerEvents({\n   *     ignoreFrom: '[no-pointer]',\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to not ignore any elements\n   * @return {string | Element | object} The current ignoreFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  /**\n   *\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\n   * CSS selector or Element.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `allowFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .resizable({\n   *     allowFrom: '.resize-handle',\n   *   .pointerEvents({\n   *     allowFrom: '.handle',,\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to allow from any element\n   * @return {string | Element | object} The current allowFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  /**\n   * ```js\n   * interact('.resize-drag')\n   *   .resizable(true)\n   *   .draggable(true)\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   *\n   *     if (interact.matchesSelector(event.target, '.drag-handle')) {\n   *       // force drag with handle target\n   *       action.name = drag\n   *     }\n   *     else {\n   *       // resize from the top and right edges\n   *       action.name  = 'resize'\n   *       action.edges = { top: true, right: true }\n   *     }\n   *\n   *     return action\n   * })\n   * ```\n   *\n   * Returns or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   * @param {function | null} [checker] A function which takes a pointer event,\n   * defaultAction string, interactable, element and interaction as parameters\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n   * props.\n   * @return {Function | Interactable} The checker function or this Interactable\n   */\n  Interactable.prototype.actionChecker = actionChecker\n\n  /**\n   * Returns or sets whether the the cursor should be changed depending on the\n   * action that would be performed if the mouse were pressed and dragged.\n   *\n   * @param {boolean} [newValue]\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker (\n  interactable: Interactable,\n  event: PointerEventType,\n  interaction: Interaction,\n  element: Element,\n  scope: Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons =\n    (event as MouseEvent).buttons ||\n    {\n      0: 1,\n      1: 4,\n      3: 8,\n      4: 16,\n    }[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor(this: Interactable): boolean\nfunction styleCursor(this: Interactable, newValue: boolean): typeof this\nfunction styleCursor (this: Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker (this: Interactable, checker: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type {\n  CursorChecker,\n  PointerType,\n  PointerEventType,\n  Element,\n  ActionName,\n  ActionProps,\n} from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\nimport InteractableMethods from './InteractableMethods'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit<SignalArgs['interactions:move'], 'interaction'> & {\n      interaction: Interaction<ActionName>\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps<ActionName>\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install (scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  /**\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\n   * default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables and\n   * elements, you need to enable it in the draggable, resizable and gesturable\n   * `'max'` and `'maxPerElement'` options.\n   *\n   * @alias module:interact.maxInteractions\n   *\n   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n   */\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove (arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction<ActionName>).prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop ({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends ActionName> (\n  action: ActionProps<T>,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n    interactable.options[action.name].enabled &&\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction<ActionName>(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches (interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare (\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps<any>\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends ActionName> (\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions (newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor (element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends ActionName> (interaction: Interaction<T>, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { SignalArgs, Scope } from '@interactjs/core/scope'\nimport type { ActionName, Element } from '@interactjs/core/types'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\n\nimport autoStart from './base'\n\nfunction beforeStart ({ interaction, eventTarget, dx, dy }: SignalArgs['interactions:move'], scope: Scope) {\n  if (interaction.prepared.name !== 'drag') return\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx)\n  const absY = Math.abs(dy)\n  const targetOptions = interaction.interactable.options.drag\n  const startAxis = targetOptions.startAxis\n  const currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy'\n\n  interaction.prepared.axis =\n    targetOptions.lockAxis === 'start'\n      ? (currentAxis[0] as 'x' | 'y') // always lock to one axis even if currentAxis === 'xy'\n      : targetOptions.lockAxis\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    ;(interaction as Interaction<ActionName>).prepared.name = null\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget as Element\n\n    const getDraggable = function (interactable: Interactable): Interactable | void {\n      if (interactable === interaction.interactable) return\n\n      const options = interaction.interactable.options.drag\n\n      if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {\n        const action = interactable.getAction(\n          interaction.downPointer,\n          interaction.downEvent,\n          interaction,\n          element,\n        )\n\n        if (\n          action &&\n          action.name === 'drag' &&\n          checkStartAxis(currentAxis, interactable) &&\n          autoStart.validateAction(action, interactable, element, eventTarget, scope)\n        ) {\n          return interactable\n        }\n      }\n    }\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable)\n\n      if (interactable) {\n        ;(interaction as Interaction<ActionName>).prepared.name = 'drag'\n        interaction.interactable = interactable\n        interaction.element = element\n        break\n      }\n\n      element = parentNode(element) as Element\n    }\n  }\n}\n\nfunction checkStartAxis (startAxis: string, interactable: Interactable) {\n  if (!interactable) {\n    return false\n  }\n\n  const thisAxis = interactable.options.drag.startAxis\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis\n}\n\nexport default {\n  id: 'auto-start/dragAxis',\n  listeners: { 'autoStart:before-start': beforeStart },\n}\n","import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\n\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    hold?: number\n    delay?: number\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoStartHoldTimer?: any\n  }\n}\n\nfunction install (scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(basePlugin)\n\n  defaults.perAction.hold = 0\n  defaults.perAction.delay = 0\n}\n\nfunction getHoldDuration (interaction: Interaction) {\n  const actionName = interaction.prepared && interaction.prepared.name\n\n  if (!actionName) {\n    return null\n  }\n\n  const options = interaction.interactable.options\n\n  return options[actionName].hold || options[actionName].delay\n}\n\nconst hold: Plugin = {\n  id: 'auto-start/hold',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoStartHoldTimer = null\n    },\n\n    'autoStart:prepared': ({ interaction }) => {\n      const hold = getHoldDuration(interaction)\n\n      if (hold > 0) {\n        interaction.autoStartHoldTimer = setTimeout(() => {\n          interaction.start(interaction.prepared, interaction.interactable, interaction.element)\n        }, hold)\n      }\n    },\n\n    'interactions:move': ({ interaction, duplicate }) => {\n      if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {\n        clearTimeout(interaction.autoStartHoldTimer)\n        interaction.autoStartHoldTimer = null\n      }\n    },\n\n    // prevent regular down->move autoStart\n    'autoStart:before-start': ({ interaction }) => {\n      const holdDuration = getHoldDuration(interaction)\n\n      if (holdDuration > 0) {\n        interaction.prepared.name = null\n      }\n    },\n  },\n  getHoldDuration,\n}\nexport default hold\n","import type { Scope } from '@interactjs/core/scope'\n\nimport autoStart from './base'\nimport dragAxis from './dragAxis'\nimport hold from './hold'\n\nexport default {\n  id: 'auto-start',\n  install (scope: Scope) {\n    scope.usePlugin(autoStart)\n    scope.usePlugin(hold)\n    scope.usePlugin(dragAxis)\n  },\n}\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerEventType } from '@interactjs/core/types'\nimport { matchesSelector, nodeContains } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    preventDefault: typeof preventDefault\n    checkAndPreventDefault: (event: Event) => void\n  }\n}\n\ntype PreventDefaultValue = 'always' | 'never' | 'auto'\nfunction preventDefault(this: Interactable): PreventDefaultValue\nfunction preventDefault(this: Interactable, newValue: PreventDefaultValue): typeof this\nfunction preventDefault (this: Interactable, newValue?: PreventDefaultValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue\n    return this\n  }\n\n  if (is.bool(newValue)) {\n    this.options.preventDefault = newValue ? 'always' : 'never'\n    return this\n  }\n\n  return this.options.preventDefault\n}\n\nfunction checkAndPreventDefault (interactable: Interactable, scope: Scope, event: Event) {\n  const setting = interactable.options.preventDefault\n\n  if (setting === 'never') return\n\n  if (setting === 'always') {\n    event.preventDefault()\n    return\n  }\n\n  // setting === 'auto'\n\n  // if the browser supports passive event listeners and isn't running on iOS,\n  // don't preventDefault of touch{start,move} events. CSS touch-action and\n  // user-select should be used instead of calling event.preventDefault().\n  if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {\n    const doc = getWindow(event.target).document\n    const docOptions = scope.getDocOptions(doc)\n\n    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {\n      return\n    }\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return\n  }\n\n  // don't preventDefault on editable elements\n  if (\n    is.element(event.target) &&\n    matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')\n  ) {\n    return\n  }\n\n  event.preventDefault()\n}\n\nfunction onInteractionEvent ({ interaction, event }: { interaction: Interaction, event: PointerEventType }) {\n  if (interaction.interactable) {\n    interaction.interactable.checkAndPreventDefault(event as Event)\n  }\n}\n\nexport function install (scope: Scope) {\n  /** @lends Interactable */\n  const { Interactable } = scope\n\n  /**\n   * Returns or sets whether to prevent the browser's default behaviour in\n   * response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`\n   * @return {string | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.preventDefault = preventDefault\n\n  Interactable.prototype.checkAndPreventDefault = function (event) {\n    return checkAndPreventDefault(this, scope, event)\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  scope.interactions.docEvents.push({\n    type: 'dragstart',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        if (\n          interaction.element &&\n          (interaction.element === event.target || nodeContains(interaction.element, event.target))\n        ) {\n          interaction.interactable.checkAndPreventDefault(event)\n          return\n        }\n      }\n    },\n  })\n}\n\nexport default {\n  id: 'core/interactablePreventDefault',\n  install,\n  listeners: ['down', 'move', 'up', 'cancel'].reduce((acc, eventType) => {\n    acc[`interactions:${eventType}`] = onInteractionEvent\n    return acc\n  }, {} as any),\n}\n","export default {}\n","import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element, OptionMethod } from '@interactjs/core/types'\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport visualizer from '@interactjs/dev-tools/visualizer/plugin'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as win from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    logger: Logger\n  }\n}\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    visializer: typeof visualizer\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    devTools?: DevToolsOptions\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    devTools: OptionMethod<DevToolsOptions>\n  }\n}\n\nexport interface DevToolsOptions {\n  ignore: { [P in keyof typeof CheckName]?: boolean }\n}\n\nexport interface Logger {\n  warn: (...args: any[]) => void\n  error: (...args: any[]) => void\n  log: (...args: any[]) => void\n}\n\nexport interface Check {\n  name: CheckName\n  text: string\n  perform: (interaction: Interaction) => boolean\n  getInfo: (interaction: Interaction) => any[]\n}\n\nenum CheckName {\n  touchAction = 'touchAction',\n  boxSizing = 'boxSizing',\n  noListeners = 'noListeners',\n}\n\nconst prefix = '[interact.js] '\nconst links = {\n  touchAction: 'https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action',\n  boxSizing: 'https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing',\n}\n\n// eslint-disable-next-line no-undef\nconst isProduction = process.env.NODE_ENV === 'production'\n\nfunction install (scope: Scope, { logger }: { logger?: Logger } = {}) {\n  const { Interactable, defaults } = scope\n\n  scope.logger = logger || console\n\n  defaults.base.devTools = {\n    ignore: {},\n  }\n\n  Interactable.prototype.devTools = function (options?: object) {\n    if (options) {\n      extend(this.options.devTools, options)\n      return this\n    }\n\n    return this.options.devTools\n  }\n\n  scope.usePlugin(visualizer)\n}\n\nconst checks: Check[] = [\n  {\n    name: CheckName.touchAction,\n    perform ({ element }) {\n      return !parentHasStyle(element, 'touchAction', /pan-|pinch|none/)\n    },\n    getInfo ({ element }) {\n      return [element, links.touchAction]\n    },\n    text: 'Consider adding CSS \"touch-action: none\" to this element\\n',\n  },\n\n  {\n    name: CheckName.boxSizing,\n    perform (interaction) {\n      const { element } = interaction\n\n      return (\n        interaction.prepared.name === 'resize' &&\n        element instanceof domObjects.HTMLElement &&\n        !hasStyle(element, 'boxSizing', /border-box/)\n      )\n    },\n    text: 'Consider adding CSS \"box-sizing: border-box\" to this resizable element',\n    getInfo ({ element }) {\n      return [element, links.boxSizing]\n    },\n  },\n\n  {\n    name: CheckName.noListeners,\n    perform (interaction) {\n      const actionName = interaction.prepared.name\n      const moveListeners = interaction.interactable.events.types[`${actionName}move`] || []\n\n      return !moveListeners.length\n    },\n    getInfo (interaction) {\n      return [interaction.prepared.name, interaction.interactable]\n    },\n    text: 'There are no listeners set for this action',\n  },\n]\n\nfunction hasStyle (element: HTMLElement, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\n  const value = element.style[prop] || win.window.getComputedStyle(element)[prop]\n  return styleRe.test((value || '').toString())\n}\n\nfunction parentHasStyle (element: Element, prop: keyof CSSStyleDeclaration, styleRe: RegExp) {\n  let parent = element as HTMLElement\n\n  while (is.element(parent)) {\n    if (hasStyle(parent, prop, styleRe)) {\n      return true\n    }\n\n    parent = parentNode(parent) as HTMLElement\n  }\n\n  return false\n}\n\nconst id = 'dev-tools'\nconst defaultExport: Plugin = isProduction\n  ? { id, install: () => {} }\n  : {\n    id,\n    install,\n    listeners: {\n      'interactions:action-start': ({ interaction }, scope) => {\n        for (const check of checks) {\n          const options = interaction.interactable && interaction.interactable.options\n\n          if (\n            !(options && options.devTools && options.devTools.ignore[check.name]) &&\n              check.perform(interaction)\n          ) {\n            scope.logger.warn(prefix + check.text, ...check.getInfo(interaction))\n          }\n        }\n      },\n    },\n    checks,\n    CheckName,\n    links,\n    prefix,\n  }\n\nexport default defaultExport\n","import * as arr from './arr'\nimport is from './is'\n\n// tslint:disable-next-line ban-types\nexport default function clone<T extends Object> (source: T): Partial<T> {\n  const dest = {} as Partial<T>\n\n  for (const prop in source) {\n    const value = source[prop]\n\n    if (is.plainObject(value)) {\n      dest[prop] = clone(value) as any\n    } else if (is.array(value)) {\n      dest[prop] = arr.from(value) as typeof value\n    } else {\n      dest[prop] = value\n    }\n  }\n\n  return dest\n}\n","import type { EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoAnyPhaseArg } from '@interactjs/core/Interaction'\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/core/types'\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { Modifier, ModifierArg, ModifierState } from './types'\n\nexport interface ModificationResult {\n  delta: Point\n  rectDelta: Rect\n  coords: Point\n  rect: FullRect\n  eventProps: any[]\n  changed: boolean\n}\n\ninterface MethodArg {\n  phase: EventPhase\n  pageCoords: Point\n  rect: FullRect\n  coords: Point\n  preEnd?: boolean\n  skipModifiers?: number\n}\n\nexport default class Modification {\n  states: ModifierState[] = []\n  startOffset: Rect = { left: 0, right: 0, top: 0, bottom: 0 }\n  startDelta!: Point\n  result!: ModificationResult\n  endResult!: Point\n  edges!: EdgeOptions\n  readonly interaction: Readonly<Interaction>\n\n  constructor (interaction: Interaction) {\n    this.interaction = interaction\n    this.result = createResult()\n  }\n\n  start ({ phase }: { phase: EventPhase }, pageCoords: Point) {\n    const { interaction } = this\n    const modifierList = getModifierList(interaction)\n    this.prepareStates(modifierList)\n\n    this.edges = extend({}, interaction.edges)\n    this.startOffset = getRectOffset(interaction.rect, pageCoords)\n    this.startDelta = { x: 0, y: 0 }\n\n    const arg = this.fillArg({\n      phase,\n      pageCoords,\n      preEnd: false,\n    })\n\n    this.result = createResult()\n    this.startAll(arg)\n\n    const result = (this.result = this.setAll(arg))\n\n    return result\n  }\n\n  fillArg (arg: Partial<ModifierArg>) {\n    const { interaction } = this\n\n    arg.interaction = interaction\n    arg.interactable = interaction.interactable\n    arg.element = interaction.element\n    arg.rect = arg.rect || interaction.rect\n    arg.edges = this.edges\n    arg.startOffset = this.startOffset\n\n    return arg as ModifierArg\n  }\n\n  startAll (arg: MethodArg & Partial<ModifierArg>) {\n    for (const state of this.states) {\n      if (state.methods.start) {\n        arg.state = state\n        state.methods.start(arg as ModifierArg)\n      }\n    }\n  }\n\n  setAll (arg: MethodArg & Partial<ModifierArg>): ModificationResult {\n    const { phase, preEnd, skipModifiers, rect: unmodifiedRect } = arg\n\n    arg.coords = extend({}, arg.pageCoords)\n    arg.rect = extend({}, unmodifiedRect)\n\n    const states = skipModifiers ? this.states.slice(skipModifiers) : this.states\n\n    const newResult = createResult(arg.coords, arg.rect)\n\n    for (const state of states) {\n      const { options } = state\n      const lastModifierCoords = extend({}, arg.coords)\n      let returnValue = null\n\n      if (state.methods?.set && this.shouldDo(options, preEnd, phase)) {\n        arg.state = state\n        returnValue = state.methods.set(arg as ModifierArg<never>)\n\n        rectUtils.addEdges(this.interaction.edges, arg.rect, {\n          x: arg.coords.x - lastModifierCoords.x,\n          y: arg.coords.y - lastModifierCoords.y,\n        })\n      }\n\n      newResult.eventProps.push(returnValue)\n    }\n\n    newResult.delta.x = arg.coords.x - arg.pageCoords.x\n    newResult.delta.y = arg.coords.y - arg.pageCoords.y\n\n    newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left\n    newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right\n    newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top\n    newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom\n\n    const prevCoords = this.result.coords\n    const prevRect = this.result.rect\n\n    if (prevCoords && prevRect) {\n      const rectChanged =\n        newResult.rect.left !== prevRect.left ||\n        newResult.rect.right !== prevRect.right ||\n        newResult.rect.top !== prevRect.top ||\n        newResult.rect.bottom !== prevRect.bottom\n\n      newResult.changed =\n        rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y\n    }\n\n    return newResult\n  }\n\n  applyToInteraction (arg: { phase: EventPhase, rect?: Rect }) {\n    const { interaction } = this\n    const { phase } = arg\n    const curCoords = interaction.coords.cur\n    const startCoords = interaction.coords.start\n    const { result, startDelta } = this\n    const curDelta = result.delta\n\n    if (phase === 'start') {\n      extend(this.startDelta, result.delta)\n    }\n\n    for (const [coordsSet, delta] of [\n      [startCoords, startDelta],\n      [curCoords, curDelta],\n    ] as const) {\n      coordsSet.page.x += delta.x\n      coordsSet.page.y += delta.y\n      coordsSet.client.x += delta.x\n      coordsSet.client.y += delta.y\n    }\n\n    const { rectDelta } = this.result\n    const rect = arg.rect || interaction.rect\n\n    rect.left += rectDelta.left\n    rect.right += rectDelta.right\n    rect.top += rectDelta.top\n    rect.bottom += rectDelta.bottom\n\n    rect.width = rect.right - rect.left\n    rect.height = rect.bottom - rect.top\n  }\n\n  setAndApply (\n    arg: Partial<DoAnyPhaseArg> & {\n      phase: EventPhase\n      preEnd?: boolean\n      skipModifiers?: number\n      modifiedCoords?: Point\n    },\n  ): void | false {\n    const { interaction } = this\n    const { phase, preEnd, skipModifiers } = arg\n\n    const result = this.setAll(\n      this.fillArg({\n        preEnd,\n        phase,\n        pageCoords: arg.modifiedCoords || interaction.coords.cur.page,\n      }),\n    )\n\n    this.result = result\n\n    // don't fire an action move if a modifier would keep the event in the same\n    // cordinates as before\n    if (\n      !result.changed &&\n      (!skipModifiers || skipModifiers < this.states.length) &&\n      interaction.interacting()\n    ) {\n      return false\n    }\n\n    if (arg.modifiedCoords) {\n      const { page } = interaction.coords.cur\n      const adjustment = {\n        x: arg.modifiedCoords.x - page.x,\n        y: arg.modifiedCoords.y - page.y,\n      }\n\n      result.coords.x += adjustment.x\n      result.coords.y += adjustment.y\n      result.delta.x += adjustment.x\n      result.delta.y += adjustment.y\n    }\n\n    this.applyToInteraction(arg)\n  }\n\n  beforeEnd (arg: Omit<DoAnyPhaseArg, 'iEvent'> & { state?: ModifierState }): void | false {\n    const { interaction, event } = arg\n    const states = this.states\n\n    if (!states || !states.length) {\n      return\n    }\n\n    let doPreend = false\n\n    for (const state of states) {\n      arg.state = state\n      const { options, methods } = state\n\n      const endPosition = methods.beforeEnd && methods.beforeEnd(arg as unknown as ModifierArg)\n\n      if (endPosition) {\n        this.endResult = endPosition\n        return false\n      }\n\n      doPreend = doPreend || (!doPreend && this.shouldDo(options, true, arg.phase, true))\n    }\n\n    if (doPreend) {\n      // trigger a final modified move before ending\n      interaction.move({ event, preEnd: true })\n    }\n  }\n\n  stop (arg: { interaction: Interaction }) {\n    const { interaction } = arg\n\n    if (!this.states || !this.states.length) {\n      return\n    }\n\n    const modifierArg: Partial<ModifierArg> = extend(\n      {\n        states: this.states,\n        interactable: interaction.interactable,\n        element: interaction.element,\n        rect: null,\n      },\n      arg,\n    )\n\n    this.fillArg(modifierArg)\n\n    for (const state of this.states) {\n      modifierArg.state = state\n\n      if (state.methods.stop) {\n        state.methods.stop(modifierArg as ModifierArg)\n      }\n    }\n\n    this.states = null\n    this.endResult = null\n  }\n\n  prepareStates (modifierList: Modifier[]) {\n    this.states = []\n\n    for (let index = 0; index < modifierList.length; index++) {\n      const { options, methods, name } = modifierList[index]\n\n      this.states.push({\n        options,\n        methods,\n        index,\n        name,\n      })\n    }\n\n    return this.states\n  }\n\n  restoreInteractionCoords ({ interaction: { coords, rect, modification } }: { interaction: Interaction }) {\n    if (!modification.result) return\n\n    const { startDelta } = modification\n    const { delta: curDelta, rectDelta } = modification.result\n\n    const coordsAndDeltas = [\n      [coords.start, startDelta],\n      [coords.cur, curDelta],\n    ]\n\n    for (const [coordsSet, delta] of coordsAndDeltas as any) {\n      coordsSet.page.x -= delta.x\n      coordsSet.page.y -= delta.y\n      coordsSet.client.x -= delta.x\n      coordsSet.client.y -= delta.y\n    }\n\n    rect.left -= rectDelta.left\n    rect.right -= rectDelta.right\n    rect.top -= rectDelta.top\n    rect.bottom -= rectDelta.bottom\n  }\n\n  shouldDo (options, preEnd?: boolean, phase?: string, requireEndOnly?: boolean) {\n    if (\n      // ignore disabled modifiers\n      !options ||\n      options.enabled === false ||\n      // check if we require endOnly option to fire move before end\n      (requireEndOnly && !options.endOnly) ||\n      // don't apply endOnly modifiers when not ending\n      (options.endOnly && !preEnd) ||\n      // check if modifier should run be applied on start\n      (phase === 'start' && !options.setStart)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  copyFrom (other: Modification) {\n    this.startOffset = other.startOffset\n    this.startDelta = other.startDelta\n    this.edges = other.edges\n    this.states = other.states.map((s) => clone(s) as ModifierState)\n    this.result = createResult(extend({}, other.result.coords), extend({}, other.result.rect))\n  }\n\n  destroy () {\n    for (const prop in this) {\n      this[prop] = null\n    }\n  }\n}\n\nfunction createResult (coords?: Point, rect?: FullRect): ModificationResult {\n  return {\n    rect,\n    coords,\n    delta: { x: 0, y: 0 },\n    rectDelta: {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n    },\n    eventProps: [],\n    changed: true,\n  }\n}\n\nfunction getModifierList (interaction) {\n  const actionOptions = interaction.interactable.options[interaction.prepared.name]\n  const actionModifiers = actionOptions.modifiers\n\n  if (actionModifiers && actionModifiers.length) {\n    return actionModifiers\n  }\n\n  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize']\n    .map((type) => {\n      const options = actionOptions[type]\n\n      return (\n        options &&\n        options.enabled && {\n          options,\n          methods: options._methods,\n        }\n      )\n    })\n    .filter((m) => !!m)\n}\n\nexport function getRectOffset (rect, coords) {\n  return rect\n    ? {\n      left: coords.x - rect.left,\n      top: coords.y - rect.top,\n      right: rect.right - coords.x,\n      bottom: rect.bottom - coords.y,\n    }\n    : {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    }\n}\n","import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Plugin } from '@interactjs/core/scope'\n\nimport Modification from './Modification'\nimport type { Modifier, ModifierModule, ModifierState } from './types'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    modification?: Modification\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    modifiers?: Array<{\n      name: string\n      [key: string]: any\n    }>\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    modifiers?: Modifier[]\n  }\n}\n\nexport function makeModifier<\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Name extends string,\n  Result,\n> (module: ModifierModule<Defaults, State, Result>, name?: Name) {\n  const { defaults } = module\n  const methods = {\n    start: module.start,\n    set: module.set,\n    beforeEnd: module.beforeEnd,\n    stop: module.stop,\n  }\n\n  const modifier = (_options?: Partial<Defaults>) => {\n    const options = (_options || {}) as Defaults\n\n    options.enabled = options.enabled !== false\n\n    // add missing defaults to options\n    for (const prop in defaults) {\n      if (!(prop in options)) {\n        ;(options as any)[prop] = defaults[prop]\n      }\n    }\n\n    const m: Modifier<Defaults, State, Name, Result> = {\n      options,\n      methods,\n      name,\n      enable: () => {\n        options.enabled = true\n        return m\n      },\n      disable: () => {\n        options.enabled = false\n        return m\n      },\n    }\n\n    return m\n  }\n\n  if (name && typeof name === 'string') {\n    // for backwrads compatibility\n    modifier._defaults = defaults\n    modifier._methods = methods\n  }\n\n  return modifier\n}\n\nexport function addEventModifiers ({\n  iEvent,\n  interaction,\n}: {\n  iEvent: InteractEvent<any>\n  interaction: Interaction<any>\n}) {\n  const result = interaction.modification!.result\n\n  if (result) {\n    iEvent.modifiers = result.eventProps\n  }\n}\n\nconst modifiersBase: Plugin = {\n  id: 'modifiers/base',\n  before: ['actions'],\n  install: (scope) => {\n    scope.defaults.perAction.modifiers = []\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.modification = new Modification(interaction)\n    },\n\n    'interactions:before-action-start': (arg) => {\n      const modification = arg.interaction.modification!\n\n      modification.start(arg, arg.interaction.coords.start.page)\n      arg.interaction.edges = modification.edges\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-move': (arg) => arg.interaction.modification.setAndApply(arg),\n\n    'interactions:before-action-end': (arg) => arg.interaction.modification.beforeEnd(arg),\n\n    'interactions:action-start': addEventModifiers,\n    'interactions:action-move': addEventModifiers,\n    'interactions:action-end': addEventModifiers,\n\n    'interactions:after-action-start': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-move': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n\n    'interactions:stop': (arg) => arg.interaction.modification.stop(arg),\n  },\n}\n\nexport default modifiersBase\n","import type { Point, Listeners, OrBoolean, Element } from '@interactjs/core/types'\n\nexport interface Defaults {\n  base: BaseDefaults\n  perAction: PerActionDefaults\n  actions: ActionDefaults\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionDefaults {}\n\nexport interface BaseDefaults {\n  preventDefault?: 'auto' | 'never' | string\n  deltaSource?: 'page' | 'client'\n  context?: Node\n}\n\nexport interface PerActionDefaults {\n  enabled?: boolean\n  origin?: Point | string | Element\n  listeners?: Listeners\n  allowFrom?: string | Element\n  ignoreFrom?: string | Element\n}\n\nexport type Options = Partial<BaseDefaults> &\nPartial<PerActionDefaults> & {\n  [P in keyof ActionDefaults]?: Partial<ActionDefaults[P]>\n}\n\nexport interface OptionsArg extends BaseDefaults, OrBoolean<Partial<ActionDefaults>> {}\n\nexport const defaults: Defaults = {\n  base: {\n    preventDefault: 'auto',\n    deltaSource: 'page',\n  },\n\n  perAction: {\n    enabled: false,\n    origin: { x: 0, y: 0 },\n  },\n\n  actions: {} as ActionDefaults,\n}\n","import type { Point, FullRect, PointerEventType, Element } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\n\nimport { BaseEvent } from './BaseEvent'\nimport type { Interaction } from './Interaction'\nimport { defaults } from './options'\nimport type { ActionName } from './types'\n\nexport type EventPhase = keyof PhaseMap\n\nexport interface PhaseMap {\n  start: true\n  move: true\n  end: true\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface InteractEvent {\n  pageX: number\n  pageY: number\n\n  clientX: number\n  clientY: number\n\n  dx: number\n  dy: number\n\n  velocityX: number\n  velocityY: number\n}\n\nexport class InteractEvent<\n  T extends ActionName = never,\n  P extends EventPhase = EventPhase,\n> extends BaseEvent<T> {\n  declare target: Element\n  declare currentTarget: Element\n  relatedTarget: Element | null = null\n  screenX?: number\n  screenY?: number\n  button: number\n  buttons: number\n  ctrlKey: boolean\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  page: Point\n  client: Point\n  delta: Point\n  rect: FullRect\n  x0: number\n  y0: number\n  t0: number\n  dt: number\n  duration: number\n  clientX0: number\n  clientY0: number\n  velocity: Point\n  speed: number\n  swipe: ReturnType<InteractEvent<T>['getSwipe']>\n  // resize\n  axes?: 'x' | 'y' | 'xy'\n  preEnd?: boolean\n\n  /** */\n  constructor (\n    interaction: Interaction<T>,\n    event: PointerEventType,\n    actionName: T,\n    phase: P,\n    element: Element,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    super(interaction)\n\n    element = element || interaction.element\n\n    const target = interaction.interactable\n    const deltaSource = (((target && target.options) || defaults) as any).deltaSource as 'page' | 'client'\n    const origin = getOriginXY(target, element, actionName)\n    const starting = phase === 'start'\n    const ending = phase === 'end'\n    const prevEvent = starting ? this : interaction.prevEvent\n    const coords = starting\n      ? interaction.coords.start\n      : ending\n        ? { page: prevEvent.page, client: prevEvent.client, timeStamp: interaction.coords.cur.timeStamp }\n        : interaction.coords.cur\n\n    this.page = extend({}, coords.page)\n    this.client = extend({}, coords.client)\n    this.rect = extend({}, interaction.rect)\n    this.timeStamp = coords.timeStamp\n\n    if (!ending) {\n      this.page.x -= origin.x\n      this.page.y -= origin.y\n\n      this.client.x -= origin.x\n      this.client.y -= origin.y\n    }\n\n    this.ctrlKey = event.ctrlKey\n    this.altKey = event.altKey\n    this.shiftKey = event.shiftKey\n    this.metaKey = event.metaKey\n    this.button = (event as MouseEvent).button\n    this.buttons = (event as MouseEvent).buttons\n    this.target = element\n    this.currentTarget = element\n    this.preEnd = preEnd\n    this.type = type || actionName + (phase || '')\n    this.interactable = target\n\n    this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0\n\n    this.x0 = interaction.coords.start.page.x - origin.x\n    this.y0 = interaction.coords.start.page.y - origin.y\n    this.clientX0 = interaction.coords.start.client.x - origin.x\n    this.clientY0 = interaction.coords.start.client.y - origin.y\n\n    if (starting || ending) {\n      this.delta = { x: 0, y: 0 }\n    } else {\n      this.delta = {\n        x: this[deltaSource].x - prevEvent[deltaSource].x,\n        y: this[deltaSource].y - prevEvent[deltaSource].y,\n      }\n    }\n\n    this.dt = interaction.coords.delta.timeStamp\n    this.duration = this.timeStamp - this.t0\n\n    // velocity and speed in pixels per second\n    this.velocity = extend({}, interaction.coords.velocity[deltaSource])\n    this.speed = hypot(this.velocity.x, this.velocity.y)\n\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null\n  }\n\n  getSwipe () {\n    const interaction = this._interaction\n\n    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null\n    }\n\n    let angle = (180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX)) / Math.PI\n    const overlap = 22.5\n\n    if (angle < 0) {\n      angle += 360\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap\n    const up = 225 - overlap <= angle && angle < 315 + overlap\n\n    const right = !left && (315 - overlap <= angle || angle < 45 + overlap)\n    const down = !up && 45 - overlap <= angle && angle < 135 + overlap\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    }\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperties(InteractEvent.prototype, {\n  pageX: {\n    get () {\n      return this.page.x\n    },\n    set (value) {\n      this.page.x = value\n    },\n  },\n  pageY: {\n    get () {\n      return this.page.y\n    },\n    set (value) {\n      this.page.y = value\n    },\n  },\n\n  clientX: {\n    get () {\n      return this.client.x\n    },\n    set (value) {\n      this.client.x = value\n    },\n  },\n  clientY: {\n    get () {\n      return this.client.y\n    },\n    set (value) {\n      this.client.y = value\n    },\n  },\n\n  dx: {\n    get () {\n      return this.delta.x\n    },\n    set (value) {\n      this.delta.x = value\n    },\n  },\n  dy: {\n    get () {\n      return this.delta.y\n    },\n    set (value) {\n      this.delta.y = value\n    },\n  },\n\n  velocityX: {\n    get () {\n      return this.velocity.x\n    },\n    set (value) {\n      this.velocity.x = value\n    },\n  },\n  velocityY: {\n    get () {\n      return this.velocity.y\n    },\n    set (value) {\n      this.velocity.y = value\n    },\n  },\n})\n","import type { PointerEventType, PointerType } from '@interactjs/core/types'\n\nexport class PointerInfo {\n  id: number\n  pointer: PointerType\n  event: PointerEventType\n  downTime: number\n  downTarget: Node\n\n  constructor (id: number, pointer: PointerType, event: PointerEventType, downTime: number, downTarget: Node) {\n    this.id = id\n    this.pointer = pointer\n    this.event = event\n    this.downTime = downTime\n    this.downTarget = downTarget\n  }\n}\n","import type {\n  Element,\n  EdgeOptions,\n  PointerEventType,\n  PointerType,\n  FullRect,\n  CoordsSet,\n} from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { EventPhase } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport type { Interactable } from './Interactable'\nimport { PointerInfo } from './PointerInfo'\nimport type { ActionDefaults } from './options'\nimport type { Scope } from './scope'\nimport type { ActionName, ActionProps } from './types'\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = '',\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = '',\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: PointerType\n  event: PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction<never>\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction<ActionName> }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction<never>, event: Event, type: 'blur' }\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName | null = never> = Pick<\nInteraction<T>,\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName | null = ActionName> {\n  // current interactable being interacted with\n  interactable: Interactable | null = null\n\n  // the target element of the interactable\n  element: Element | null = null\n  rect: FullRect | null = null\n  _rects?: {\n    start: FullRect\n    corrected: FullRect\n    previous: FullRect\n    delta: FullRect\n  }\n  edges: EdgeOptions | null = null\n\n  _scopeFire: Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name: null,\n    axis: null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: PointerEventType | null = null\n\n  downPointer: PointerType = {} as PointerType\n\n  _latestPointer: {\n    pointer: PointerType\n    event: PointerEventType\n    eventTarget: Node\n  } = {\n      pointer: null,\n      event: null,\n      eventTarget: null,\n    }\n\n  // previous action event\n  prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n  _stopped = true\n  _proxy: InteractionProxy<T> | null = null\n\n  simulation = null\n\n  /** @internal */ get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = warnOnce(function (this: Interaction, signalArg: any) {\n    this.move(signalArg)\n  }, 'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  readonly _id: number = idCounter++\n\n  /** */\n  constructor ({ pointerType, scopeFire }: { pointerType?: string, scopeFire: Scope['fire'] }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get () {\n          return that[key]\n        },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {Boolean} Whether the interaction was successfully started\n   */\n  start<A extends ActionName> (action: ActionProps<A>, interactable: Interactable, element: Element): boolean {\n    if (\n      this.interacting() ||\n      !this.pointerIsDown ||\n      this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n      !interactable.options[action.name as keyof ActionDefaults].enabled\n    ) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element = element\n    this.rect = interactable.getRect(element)\n    this.edges = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped = false\n    this._interacting =\n      this._doPhase({\n        interaction: this,\n        event: this.downEvent,\n        phase: 'start',\n      }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove =\n      this.coords.cur.page.x === this.coords.prev.page.x &&\n      this.coords.cur.page.y === this.coords.prev.page.y &&\n      this.coords.cur.client.x === this.coords.prev.client.x &&\n      this.coords.cur.client.y === this.coords.prev.client.y\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this as unknown as Interaction<never>,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend(\n      {\n        pointer: this._latestPointer.pointer,\n        event: this._latestPointer.event,\n        eventTarget: this._latestPointer.eventTarget,\n        interaction: this,\n      },\n      signalArg || {},\n    )\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', {\n      event,\n      type: 'blur',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event?: PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer: any) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return this.pointerType === 'mouse' || this.pointerType === 'pen'\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, (curPointer) => curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false ? false : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(id, pointer, event, null, null)\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    } else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(\n      this.coords.cur,\n      this.pointers.map((p) => p.pointer),\n      this._now(),\n    )\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer: PointerType, event: PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) return\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  _updateLatestPointer (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy () {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  _createPreparedEvent<P extends EventPhase> (\n    event: PointerEventType,\n    phase: P,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  _fireEvent<P extends EventPhase> (iEvent: InteractEvent<T, P>) {\n    this.interactable?.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase<P extends EventPhase> (\n    signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> },\n  ) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = (signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type))\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') {\n      this.prevEvent = iEvent\n    }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  _now () {\n    return Date.now()\n  }\n}\n\nexport default Interaction\nexport { PointerInfo }\n","import type Interaction from '@interactjs/core/Interaction'\nimport { _ProxyMethods } from '@interactjs/core/Interaction'\nimport type { Plugin } from '@interactjs/core/scope'\nimport type { Point } from '@interactjs/core/types'\nimport * as rectUtils from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    offsetBy?: typeof offsetBy\n    offset: {\n      total: Point\n      pending: Point\n    }\n  }\n\n  enum _ProxyMethods {\n    offsetBy = '',\n  }\n}\n\n;(_ProxyMethods as any).offsetBy = ''\n\nexport function addTotal (interaction: Interaction) {\n  if (!interaction.pointerIsDown) {\n    return\n  }\n\n  addToCoords(interaction.coords.cur, interaction.offset.total)\n\n  interaction.offset.pending.x = 0\n  interaction.offset.pending.y = 0\n}\n\nfunction beforeAction ({ interaction }: { interaction: Interaction }) {\n  applyPending(interaction)\n}\n\nfunction beforeEnd ({ interaction }: { interaction: Interaction }): boolean | void {\n  const hadPending = applyPending(interaction)\n\n  if (!hadPending) return\n\n  interaction.move({ offset: true })\n  interaction.end()\n\n  return false\n}\n\nfunction end ({ interaction }: { interaction: Interaction }) {\n  interaction.offset.total.x = 0\n  interaction.offset.total.y = 0\n  interaction.offset.pending.x = 0\n  interaction.offset.pending.y = 0\n}\n\nexport function applyPending (interaction: Interaction) {\n  if (!hasPending(interaction)) {\n    return false\n  }\n\n  const { pending } = interaction.offset\n\n  addToCoords(interaction.coords.cur, pending)\n  addToCoords(interaction.coords.delta, pending)\n  rectUtils.addEdges(interaction.edges, interaction.rect, pending)\n\n  pending.x = 0\n  pending.y = 0\n\n  return true\n}\n\nfunction offsetBy (this: Interaction, { x, y }: Point) {\n  this.offset.pending.x += x\n  this.offset.pending.y += y\n\n  this.offset.total.x += x\n  this.offset.total.y += y\n}\n\nfunction addToCoords ({ page, client }, { x, y }: Point) {\n  page.x += x\n  page.y += y\n  client.x += x\n  client.y += y\n}\n\nfunction hasPending (interaction: Interaction) {\n  return !!(interaction.offset.pending.x || interaction.offset.pending.y)\n}\n\nconst offset: Plugin = {\n  id: 'offset',\n  before: ['modifiers', 'pointer-events', 'actions', 'inertia'],\n  install (scope) {\n    scope.Interaction.prototype.offsetBy = offsetBy\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.offset = {\n        total: { x: 0, y: 0 },\n        pending: { x: 0, y: 0 },\n      }\n    },\n    'interactions:update-pointer': ({ interaction }) => addTotal(interaction),\n    'interactions:before-action-start': beforeAction,\n    'interactions:before-action-move': beforeAction,\n    'interactions:before-action-end': beforeEnd,\n    'interactions:stop': end,\n  },\n}\n\nexport default offset\n","import type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, Point, PointerEventType } from '@interactjs/core/types'\nimport Modification from '@interactjs/modifiers/Modification'\nimport * as modifiers from '@interactjs/modifiers/base'\nimport type { ModifierArg } from '@interactjs/modifiers/types'\nimport offset from '@interactjs/offset/plugin'\nimport * as dom from '@interactjs/utils/domUtils'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { copyCoords } from '@interactjs/utils/pointerUtils'\nimport raf from '@interactjs/utils/raf'\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    resume?: true\n    inertiastart?: true\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    inertia?: InertiaState\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    inertia?: {\n      enabled?: boolean\n      resistance?: number // the lambda in exponential decay\n      minSpeed?: number // target speed must be above this for inertia to start\n      endSpeed?: number // the speed at which inertia is slow enough to stop\n      allowResume?: true // allow resuming an action in inertia phase\n      smoothEndDuration?: number // animate to snap/restrict endOnly if there's no inertia\n    }\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-inertiastart': Omit<DoPhaseArg<ActionName, 'inertiastart'>, 'iEvent'>\n    'interactions:action-inertiastart': DoPhaseArg<ActionName, 'inertiastart'>\n    'interactions:after-action-inertiastart': DoPhaseArg<ActionName, 'inertiastart'>\n    'interactions:before-action-resume': Omit<DoPhaseArg<ActionName, 'resume'>, 'iEvent'>\n    'interactions:action-resume': DoPhaseArg<ActionName, 'resume'>\n    'interactions:after-action-resume': DoPhaseArg<ActionName, 'resume'>\n  }\n}\n\nfunction install (scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(offset)\n  scope.usePlugin(modifiers.default)\n  scope.actions.phases.inertiastart = true\n  scope.actions.phases.resume = true\n\n  defaults.perAction.inertia = {\n    enabled: false,\n    resistance: 10, // the lambda in exponential decay\n    minSpeed: 100, // target speed must be above this for inertia to start\n    endSpeed: 10, // the speed at which inertia is slow enough to stop\n    allowResume: true, // allow resuming an action in inertia phase\n    smoothEndDuration: 300, // animate to snap/restrict endOnly if there's no inertia\n  }\n}\n\nexport class InertiaState {\n  active = false\n  isModified = false\n  smoothEnd = false\n  allowResume = false\n\n  modification!: Modification\n  modifierCount = 0\n  modifierArg!: ModifierArg\n\n  startCoords!: Point\n  t0 = 0\n  v0 = 0\n\n  te = 0\n  targetOffset!: Point\n  modifiedOffset!: Point\n  currentOffset!: Point\n\n  lambda_v0? = 0 // eslint-disable-line camelcase\n  one_ve_v0? = 0 // eslint-disable-line camelcase\n  timeout!: number\n  readonly interaction: Interaction\n\n  constructor (interaction: Interaction) {\n    this.interaction = interaction\n  }\n\n  start (event: PointerEventType) {\n    const { interaction } = this\n    const options = getOptions(interaction)\n\n    if (!options || !options.enabled) {\n      return false\n    }\n\n    const { client: velocityClient } = interaction.coords.velocity\n    const pointerSpeed = hypot(velocityClient.x, velocityClient.y)\n    const modification = this.modification || (this.modification = new Modification(interaction))\n\n    modification.copyFrom(interaction.modification)\n\n    this.t0 = interaction._now()\n    this.allowResume = options.allowResume\n    this.v0 = pointerSpeed\n    this.currentOffset = { x: 0, y: 0 }\n    this.startCoords = interaction.coords.cur.page\n\n    this.modifierArg = modification.fillArg({\n      pageCoords: this.startCoords,\n      preEnd: true,\n      phase: 'inertiastart',\n    })\n\n    const thrown =\n      this.t0 - interaction.coords.cur.timeStamp < 50 &&\n      pointerSpeed > options.minSpeed &&\n      pointerSpeed > options.endSpeed\n\n    if (thrown) {\n      this.startInertia()\n    } else {\n      modification.result = modification.setAll(this.modifierArg)\n\n      if (!modification.result.changed) {\n        return false\n      }\n\n      this.startSmoothEnd()\n    }\n\n    // force modification change\n    interaction.modification.result.rect = null\n\n    // bring inertiastart event to the target coords\n    interaction.offsetBy(this.targetOffset)\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'inertiastart',\n    })\n    interaction.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y })\n    // force modification change\n    interaction.modification.result.rect = null\n\n    this.active = true\n    interaction.simulation = this\n\n    return true\n  }\n\n  startInertia () {\n    const startVelocity = this.interaction.coords.velocity.client\n    const options = getOptions(this.interaction)\n    const lambda = options.resistance\n    const inertiaDur = -Math.log(options.endSpeed / this.v0) / lambda\n\n    this.targetOffset = {\n      x: (startVelocity.x - inertiaDur) / lambda,\n      y: (startVelocity.y - inertiaDur) / lambda,\n    }\n\n    this.te = inertiaDur\n    this.lambda_v0 = lambda / this.v0\n    this.one_ve_v0 = 1 - options.endSpeed / this.v0\n\n    const { modification, modifierArg } = this\n\n    modifierArg.pageCoords = {\n      x: this.startCoords.x + this.targetOffset.x,\n      y: this.startCoords.y + this.targetOffset.y,\n    }\n\n    modification.result = modification.setAll(modifierArg)\n\n    if (modification.result.changed) {\n      this.isModified = true\n      this.modifiedOffset = {\n        x: this.targetOffset.x + modification.result.delta.x,\n        y: this.targetOffset.y + modification.result.delta.y,\n      }\n    }\n\n    this.onNextFrame(() => this.inertiaTick())\n  }\n\n  startSmoothEnd () {\n    this.smoothEnd = true\n    this.isModified = true\n    this.targetOffset = {\n      x: this.modification.result.delta.x,\n      y: this.modification.result.delta.y,\n    }\n\n    this.onNextFrame(() => this.smoothEndTick())\n  }\n\n  onNextFrame (tickFn: () => void) {\n    this.timeout = raf.request(() => {\n      if (this.active) {\n        tickFn()\n      }\n    })\n  }\n\n  inertiaTick () {\n    const { interaction } = this\n    const options = getOptions(interaction)\n    const lambda = options.resistance\n    const t = (interaction._now() - this.t0) / 1000\n\n    if (t < this.te) {\n      const progress = 1 - (Math.exp(-lambda * t) - this.lambda_v0) / this.one_ve_v0\n      let newOffset: Point\n\n      if (this.isModified) {\n        newOffset = getQuadraticCurvePoint(\n          0,\n          0,\n          this.targetOffset.x,\n          this.targetOffset.y,\n          this.modifiedOffset.x,\n          this.modifiedOffset.y,\n          progress,\n        )\n      } else {\n        newOffset = {\n          x: this.targetOffset.x * progress,\n          y: this.targetOffset.y * progress,\n        }\n      }\n\n      const delta = { x: newOffset.x - this.currentOffset.x, y: newOffset.y - this.currentOffset.y }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move()\n\n      this.onNextFrame(() => this.inertiaTick())\n    } else {\n      interaction.offsetBy({\n        x: this.modifiedOffset.x - this.currentOffset.x,\n        y: this.modifiedOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  smoothEndTick () {\n    const { interaction } = this\n    const t = interaction._now() - this.t0\n    const { smoothEndDuration: duration } = getOptions(interaction)\n\n    if (t < duration) {\n      const newOffset = {\n        x: easeOutQuad(t, 0, this.targetOffset.x, duration),\n        y: easeOutQuad(t, 0, this.targetOffset.y, duration),\n      }\n      const delta = {\n        x: newOffset.x - this.currentOffset.x,\n        y: newOffset.y - this.currentOffset.y,\n      }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move({ skipModifiers: this.modifierCount })\n\n      this.onNextFrame(() => this.smoothEndTick())\n    } else {\n      interaction.offsetBy({\n        x: this.targetOffset.x - this.currentOffset.x,\n        y: this.targetOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  resume ({ pointer, event, eventTarget }: SignalArgs['interactions:down']) {\n    const { interaction } = this\n\n    // undo inertia changes to interaction coords\n    interaction.offsetBy({\n      x: -this.currentOffset.x,\n      y: -this.currentOffset.y,\n    })\n\n    // update pointer at pointer down position\n    interaction.updatePointer(pointer, event, eventTarget, true)\n\n    // fire resume signals and event\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'resume',\n    })\n    copyCoords(interaction.coords.prev, interaction.coords.cur)\n\n    this.stop()\n  }\n\n  end () {\n    this.interaction.move()\n    this.interaction.end()\n    this.stop()\n  }\n\n  stop () {\n    this.active = this.smoothEnd = false\n    this.interaction.simulation = null\n    raf.cancel(this.timeout)\n  }\n}\n\nfunction start ({ interaction, event }: DoPhaseArg<ActionName, 'end'>) {\n  if (!interaction._interacting || interaction.simulation) {\n    return null\n  }\n\n  const started = interaction.inertia.start(event)\n\n  // prevent action end if inertia or smoothEnd\n  return started ? false : null\n}\n\n// Check if the down event hits the current inertia target\n// control should be return to the user\nfunction resume (arg: SignalArgs['interactions:down']) {\n  const { interaction, eventTarget } = arg\n  const state = interaction.inertia\n\n  if (!state.active) return\n\n  let element = eventTarget as Node\n\n  // climb up the DOM tree from the event target\n  while (is.element(element)) {\n    // if interaction element is the current inertia target element\n    if (element === interaction.element) {\n      state.resume(arg)\n      break\n    }\n\n    element = dom.parentNode(element)\n  }\n}\n\nfunction stop ({ interaction }: { interaction: Interaction }) {\n  const state = interaction.inertia\n\n  if (state.active) {\n    state.stop()\n  }\n}\n\nfunction getOptions ({ interactable, prepared }: Interaction) {\n  return interactable && interactable.options && prepared.name && interactable.options[prepared.name].inertia\n}\n\nconst inertia: Plugin = {\n  id: 'inertia',\n  before: ['modifiers', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.inertia = new InertiaState(interaction)\n    },\n\n    'interactions:before-action-end': start,\n    'interactions:down': resume,\n    'interactions:stop': stop,\n\n    'interactions:before-action-resume': (arg) => {\n      const { modification } = arg.interaction\n\n      modification.stop(arg)\n      modification.start(arg, arg.interaction.coords.cur.page)\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-inertiastart': (arg) => arg.interaction.modification.setAndApply(arg),\n    'interactions:action-resume': modifiers.addEventModifiers,\n    'interactions:action-inertiastart': modifiers.addEventModifiers,\n    'interactions:after-action-inertiastart': (arg) =>\n      arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-resume': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n  },\n}\n\n// http://stackoverflow.com/a/5634528/2280888\nfunction _getQBezierValue (t: number, p1: number, p2: number, p3: number) {\n  const iT = 1 - t\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3\n}\n\nfunction getQuadraticCurvePoint (\n  startX: number,\n  startY: number,\n  cpX: number,\n  cpY: number,\n  endX: number,\n  endY: number,\n  position: number,\n) {\n  return {\n    x: _getQBezierValue(position, startX, cpX, endX),\n    y: _getQBezierValue(position, startY, cpY, endY),\n  }\n}\n\n// http://gizma.com/easing/\nfunction easeOutQuad (t: number, b: number, c: number, d: number) {\n  t /= d\n  return -c * t * (t - 2) + b\n}\n\nexport default inertia\n","import type { Listener, ListenersArg, Rect } from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport type { NormalizedListeners } from '@interactjs/utils/normalizeListeners'\nimport normalize from '@interactjs/utils/normalizeListeners'\n\nfunction fireUntilImmediateStopped (event: any, listeners: Listener[]) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) {\n      break\n    }\n\n    listener(event)\n  }\n}\n\nexport class Eventable {\n  options: any\n  types: NormalizedListeners = {}\n  propagationStopped = false\n  immediatePropagationStopped = false\n  global: any\n\n  constructor (options?: { [index: string]: any }) {\n    this.options = extend({}, options || {})\n  }\n\n  fire<T extends { type: string, propagationStopped?: boolean }> (event: T) {\n    let listeners: Listener[]\n    const global = this.global\n\n    // Interactable#on() listeners\n    // tslint:disable no-conditional-assignment\n    if ((listeners = this.types[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n  }\n\n  on (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      this.types[type] = arr.merge(this.types[type] || [], listeners[type])\n    }\n  }\n\n  off (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      const eventList = this.types[type]\n\n      if (!eventList || !eventList.length) {\n        continue\n      }\n\n      for (const subListener of listeners[type]) {\n        const index = eventList.indexOf(subListener)\n\n        if (index !== -1) {\n          eventList.splice(index, 1)\n        }\n      }\n    }\n  }\n\n  getRect (_element: Element): Rect {\n    return null\n  }\n}\n","import type { Actions } from '@interactjs/core/types'\n\nexport default function isNonNativeEvent (type: string, actions: Actions) {\n  if (actions.phaselessTypes[type]) {\n    return true\n  }\n\n  for (const name in actions.map) {\n    if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {\n      return true\n    }\n  }\n\n  return false\n}\n","/** @module interact */\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Context, EventTypes, Listener, ListenersArg, Target } from '@interactjs/core/types'\nimport browser from '@interactjs/utils/browser'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { Interactable } from './Interactable'\nimport isNonNativeEvent from './isNonNativeEvent'\nimport type { Options } from './options'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    (target: Target, options?: Options): Interactable\n    getPointerAverage: typeof pointerUtils.pointerAverage\n    getTouchBBox: typeof pointerUtils.touchBBox\n    getTouchDistance: typeof pointerUtils.touchDistance\n    getTouchAngle: typeof pointerUtils.touchAngle\n    getElementRect: typeof domUtils.getElementRect\n    getElementClientRect: typeof domUtils.getElementClientRect\n    matchesSelector: typeof domUtils.matchesSelector\n    closest: typeof domUtils.closest\n    /** @internal */ globalEvents: any\n    version: string\n    /** @internal */ scope: Scope\n    use(\n      plugin: Plugin,\n      options?: {\n        [key: string]: any\n      },\n    ): any\n    isSet(target: Target, options?: any): boolean\n    on(type: string | EventTypes, listener: ListenersArg, options?: object): any\n    off(type: EventTypes, listener: any, options?: object): any\n    debug(): any\n    supportsTouch(): boolean\n    supportsPointerEvent(): boolean\n    stop(): any\n    pointerMoveTolerance(newValue?: number): any\n    addDocument(doc: Document, options?: object): void\n    removeDocument(doc: Document): void\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\ntype _InteractStatic = import('@interactjs/core/InteractStatic').InteractStatic\n\nexport function createInteractStatic (scope: Scope): _InteractStatic {\n  /**\n   * ```js\n   * interact('#draggable').draggable(true)\n   *\n   * var rectables = interact('rect')\n   * rectables\n   *   .gesturable(true)\n   *   .on('gesturemove', function (event) {\n   *       // ...\n   *   })\n   * ```\n   *\n   * The methods of this variable can be used to set elements as interactables\n   * and also to change various default settings.\n   *\n   * Calling it as a function and passing an element or a valid CSS selector\n   * string returns an Interactable object which has various methods to configure\n   * it.\n   *\n   * @global\n   *\n   * @param {Element | string} target The HTML or SVG Element to interact with\n   * or CSS selector\n   * @return {Interactable}\n   */\n  const interact = ((target: Target, options: Options) => {\n    let interactable = scope.interactables.get(target, options)\n\n    if (!interactable) {\n      interactable = scope.interactables.new(target, options)\n      interactable.events.global = interact.globalEvents\n    }\n\n    return interactable\n  }) as _InteractStatic\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerUtils.pointerAverage\n  interact.getTouchBBox = pointerUtils.touchBBox\n  interact.getTouchDistance = pointerUtils.touchDistance\n  interact.getTouchAngle = pointerUtils.touchAngle\n\n  interact.getElementRect = domUtils.getElementRect\n  interact.getElementClientRect = domUtils.getElementClientRect\n  interact.matchesSelector = domUtils.matchesSelector\n  interact.closest = domUtils.closest\n\n  interact.globalEvents = {} as any\n\n  // eslint-disable-next-line no-undef\n  interact.version = process.env.npm_package_version\n  interact.scope = scope\n  /**\n   * Use a plugin\n   *\n   * @alias module:interact.use\n   *\n   */\n  interact.use = function (plugin, options) {\n    this.scope.usePlugin(plugin, options)\n\n    return this\n  }\n\n  /**\n   * Check if an element or selector has been set with the {@link interact}\n   * function\n   *\n   * @alias module:interact.isSet\n   *\n   * @param {Target} target The Element or string being searched for\n   * @param {object} options\n   * @return {boolean} Indicates if the element or CSS selector was previously\n   * passed to interact\n   */\n  interact.isSet = function (target: Target, options?: { context?: Context }): boolean {\n    return !!this.scope.interactables.get(target, options && options.context)\n  }\n\n  /**\n   * @deprecated\n   * Add a global listener for an InteractEvent or adds a DOM event to `document`\n   *\n   * @alias module:interact.on\n   *\n   * @param {string | array | object} type The types of events to listen for\n   * @param {function} listener The function event (s)\n   * @param {object | boolean} [options] object or useCapture flag for\n   * addEventListener\n   * @return {object} interact\n   */\n  interact.on = warnOnce(function on (type: string | EventTypes, listener: ListenersArg, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type as any[]) {\n        this.on(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.on(prop, (type as any)[prop], listener)\n      }\n\n      return this\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      // if this type of event was never bound\n      if (!this.globalEvents[type]) {\n        this.globalEvents[type] = [listener]\n      } else {\n        this.globalEvents[type].push(listener)\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      this.scope.events.add(this.scope.document, type, listener as Listener, { options })\n    }\n\n    return this\n  }, 'The interact.on() method is being deprecated')\n\n  /**\n   * @deprecated\n   * Removes a global InteractEvent listener or DOM event from `document`\n   *\n   * @alias module:interact.off\n   *\n   * @param {string | array | object} type The types of events that were listened\n   * for\n   * @param {function} listener The listener function to be removed\n   * @param {object | boolean} options [options] object or useCapture flag for\n   * removeEventListener\n   * @return {object} interact\n   */\n  interact.off = warnOnce(function off (type: EventTypes, listener: any, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type) {\n        this.off(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.off(prop, type[prop], listener)\n      }\n\n      return this\n    }\n\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      let index: number\n\n      if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) {\n        this.globalEvents[type].splice(index, 1)\n      }\n    } else {\n      this.scope.events.remove(this.scope.document, type, listener, options)\n    }\n\n    return this\n  }, 'The interact.off() method is being deprecated')\n\n  interact.debug = function () {\n    return this.scope\n  }\n\n  /**\n   * @alias module:interact.supportsTouch\n   *\n   * @return {boolean} Whether or not the browser supports touch input\n   */\n  interact.supportsTouch = function () {\n    return browser.supportsTouch\n  }\n\n  /**\n   * @alias module:interact.supportsPointerEvent\n   *\n   * @return {boolean} Whether or not the browser supports PointerEvents\n   */\n  interact.supportsPointerEvent = function () {\n    return browser.supportsPointerEvent\n  }\n\n  /**\n   * Cancels all interactions (end events are not fired)\n   *\n   * @alias module:interact.stop\n   *\n   * @return {object} interact\n   */\n  interact.stop = function () {\n    for (const interaction of this.scope.interactions.list) {\n      interaction.stop()\n    }\n\n    return this\n  }\n\n  /**\n   * Returns or sets the distance the pointer must be moved before an action\n   * sequence occurs. This also affects tolerance for tap events.\n   *\n   * @alias module:interact.pointerMoveTolerance\n   *\n   * @param {number} [newValue] The movement from the start position must be greater than this value\n   * @return {interact | number}\n   */\n  interact.pointerMoveTolerance = function (newValue?: number) {\n    if (is.number(newValue)) {\n      this.scope.interactions.pointerMoveTolerance = newValue\n\n      return this\n    }\n\n    return this.scope.interactions.pointerMoveTolerance\n  }\n\n  interact.addDocument = function (doc: Document, options?: object) {\n    this.scope.addDocument(doc, options)\n  }\n\n  interact.removeDocument = function (doc: Document) {\n    this.scope.removeDocument(doc)\n  }\n\n  return interact\n}\n","/* eslint-disable no-dupe-class-members */\nimport type { Scope } from '@interactjs/core/scope'\nimport type {\n  ActionMap,\n  ActionMethod,\n  ActionName,\n  Actions,\n  Context,\n  Element,\n  EventTypes,\n  Listeners,\n  ListenersArg,\n  OrBoolean,\n  Target,\n} from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport isNonNativeEvent from './isNonNativeEvent'\nimport type { ActionDefaults, Defaults, OptionsArg, PerActionDefaults, Options } from './options'\n\ntype IgnoreValue = string | Element | boolean\ntype DeltaSource = 'page' | 'client'\n\n/** */\nexport class Interactable implements Partial<Eventable> {\n  /** @internal */ get _defaults (): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly options!: Required<Options>\n  readonly _actions: Actions\n  readonly target: Target\n  readonly events = new Eventable()\n  readonly _context: Context\n  readonly _win: Window\n  readonly _doc: Document\n  readonly _scopeEvents: Scope['events']\n\n  /** @internal */ _rectChecker?: typeof Interactable.prototype.getRect\n\n  /** */\n  constructor (\n    target: Target,\n    options: any,\n    defaultContext: Document | Element,\n    scopeEvents: Scope['events'],\n  ) {\n    this._actions = options.actions\n    this.target = target\n    this._context = options.context || defaultContext\n    this._win = getWindow(trySelector(target) ? this._context : target)\n    this._doc = this._win.document\n    this._scopeEvents = scopeEvents\n\n    this.set(options)\n  }\n\n  setOnEvents (actionName: ActionName, phases: NonNullable<any>) {\n    if (is.func(phases.onstart)) {\n      this.on(`${actionName}start`, phases.onstart)\n    }\n    if (is.func(phases.onmove)) {\n      this.on(`${actionName}move`, phases.onmove)\n    }\n    if (is.func(phases.onend)) {\n      this.on(`${actionName}end`, phases.onend)\n    }\n    if (is.func(phases.oninertiastart)) {\n      this.on(`${actionName}inertiastart`, phases.oninertiastart)\n    }\n\n    return this\n  }\n\n  updatePerActionListeners (actionName: ActionName, prev: Listeners, cur: Listeners) {\n    if (is.array(prev) || is.object(prev)) {\n      this.off(actionName, prev)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this.on(actionName, cur)\n    }\n  }\n\n  setPerAction (actionName: ActionName, options: OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array(optionValue)) {\n        ;(actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        ;(actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || ({} as any),\n          clone(optionValue),\n        )\n\n        // set anabled field to true if it exists in the defaults\n        if (\n          is.object(defaults.perAction[optionName]) &&\n          'enabled' in (defaults.perAction[optionName] as any)\n        ) {\n          ;(actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        ;(actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        ;(actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {Rect} The object's bounding rectangle.\n   */\n  getRect (element: Element) {\n    element = element || (is.element(this.target) ? this.target : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker(): (element: Element) => any | null\n  rectChecker(checker: (element: Element) => any): this\n  rectChecker (checker?: (element: Element) => any) {\n    if (is.func(checker)) {\n      this._rectChecker = checker\n\n      this.getRect = (element) => {\n        const rect = extend({}, this._rectChecker(element))\n\n        if (!(('width' in rect) as unknown)) {\n          rect.width = rect.right - rect.left\n          rect.height = rect.bottom - rect.top\n        }\n\n        return rect\n      }\n\n      return this\n    }\n\n    if (checker === null) {\n      delete this.getRect\n      delete this._rectChecker\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  _backCompatOption (optionName: keyof Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      ;(this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        ;(this.options[action as keyof ActionMap] as any)[optionName] = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource(): DeltaSource\n  deltaSource(newValue: DeltaSource): this\n  deltaSource (newValue?: DeltaSource) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context\n  }\n\n  inContext (element: Document | Node) {\n    return this._context === element.ownerDocument || nodeContains(this._context, element)\n  }\n\n  testIgnoreAllow (\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue, allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Node,\n  ) {\n    return (\n      !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &&\n      this.testAllow(options.allowFrom, targetNode, eventTarget)\n    )\n  }\n\n  testAllow (this: Interactable, allowFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!allowFrom) {\n      return true\n    }\n\n    if (!is.element(element)) {\n      return false\n    }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    } else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  testIgnore (this: Interactable, ignoreFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!ignoreFrom || !is.element(element)) {\n      return false\n    }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    } else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire<E extends { type: string }> (iEvent: E) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  _onOff (method: 'on' | 'off', typeArg: EventTypes, listenerArg?: ListenersArg | null, options?: any) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const addRemove = method === 'on' ? 'add' : 'remove'\n    const listeners = normalizeListeners(typeArg, listenerArg)\n\n    for (let type in listeners) {\n      if (type === 'wheel') {\n        type = browser.wheelEvent\n      }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[`${addRemove}Delegate` as 'addDelegate' | 'removeDelegate'](\n            this.target,\n            this._context,\n            type,\n            listener,\n            options,\n          )\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[addRemove](this.target, type, listener, options)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on (types: EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('on', types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off (types: string | string[] | EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('off', types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options: OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    ;(this.options as Required<Options>) = clone(defaults.base) as Required<Options>\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n      ;(this[methodName] as ActionMethod<unknown>)(options[actionName])\n    }\n\n    for (const setting in options) {\n      if (is.func((this as any)[setting])) {\n        ;(this as any)[setting](options[setting as keyof typeof options])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset () {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i >= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target && context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l >= 0; l--) {\n            this._scopeEvents.removeDelegate(\n              this.target,\n              this._context,\n              type,\n              listeners[l][0],\n              listeners[l][1],\n            )\n          }\n        }\n      }\n    } else {\n      this._scopeEvents.remove(this.target as Node, 'all')\n    }\n  }\n}\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { OptionsArg, Options } from '@interactjs/core/options'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { Target, Context } from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactable:new': {\n      interactable: Interactable\n      target: Target\n      options: OptionsArg\n      win: Window\n    }\n  }\n}\n\ninterface InteractableScopeProp {\n  context: Context\n  interactable: Interactable\n}\n\nexport class InteractableSet {\n  // all set interactables\n  list: Interactable[] = []\n\n  selectorMap: {\n    [selector: string]: InteractableScopeProp[]\n  } = {}\n\n  scope: Scope\n\n  constructor (scope: Scope) {\n    this.scope = scope\n    scope.addListeners({\n      'interactable:unset': ({ interactable }) => {\n        const { target, _context: context } = interactable\n        const targetMappings: InteractableScopeProp[] = is.string(target)\n          ? this.selectorMap[target]\n          : (target as any)[this.scope.id]\n\n        const targetIndex = arr.findIndex(targetMappings, (m) => m.context === context)\n        if (targetMappings[targetIndex]) {\n          // Destroying mappingInfo's context and interactable\n          targetMappings[targetIndex].context = null\n          targetMappings[targetIndex].interactable = null\n        }\n        targetMappings.splice(targetIndex, 1)\n      },\n    })\n  }\n\n  new (target: Target, options?: any): Interactable {\n    options = extend(options || {}, {\n      actions: this.scope.actions,\n    })\n    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events)\n    const mappingInfo = { context: interactable._context, interactable }\n\n    this.scope.addDocument(interactable._doc)\n    this.list.push(interactable)\n\n    if (is.string(target)) {\n      if (!this.selectorMap[target]) {\n        this.selectorMap[target] = []\n      }\n      this.selectorMap[target].push(mappingInfo)\n    } else {\n      if (!(interactable.target as any)[this.scope.id]) {\n        Object.defineProperty(target, this.scope.id, {\n          value: [],\n          configurable: true,\n        })\n      }\n\n      ;(target as any)[this.scope.id].push(mappingInfo)\n    }\n\n    this.scope.fire('interactable:new', {\n      target,\n      options,\n      interactable,\n      win: this.scope._win,\n    })\n\n    return interactable\n  }\n\n  get (target: Target, options?: Options) {\n    const context = (options && options.context) || this.scope.document\n    const isSelector = is.string(target)\n    const targetMappings: InteractableScopeProp[] = isSelector\n      ? this.selectorMap[target as string]\n      : (target as any)[this.scope.id]\n\n    if (!targetMappings) {\n      return null\n    }\n\n    const found = arr.find(\n      targetMappings,\n      (m) => m.context === context && (isSelector || m.interactable.inContext(target as any)),\n    )\n\n    return found && found.interactable\n  }\n\n  forEachMatch<T> (node: Node, callback: (interactable: Interactable) => T) {\n    for (const interactable of this.list) {\n      let ret: void | T\n\n      if (\n        (is.string(interactable.target)\n          ? // target is a selector and the element matches\n          is.element(node) && domUtils.matchesSelector(node, interactable.target)\n          : // target is the element\n          node === interactable.target) &&\n        // the element is in context\n        interactable.inContext(node)\n      ) {\n        ret = callback(interactable)\n      }\n\n      if (ret !== undefined) {\n        return ret\n      }\n    }\n  }\n}\n","import type { Scope } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport pExtend from '@interactjs/utils/pointerExtend'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    events: ReturnType<typeof install>\n  }\n}\n\ntype Listener = (event: Event | FakeEvent) => any\n\nfunction install (scope: Scope) {\n  const targets: Array<{\n    eventTarget: EventTarget\n    events: { [type: string]: Listener[] }\n  }> = []\n\n  const delegatedEvents: {\n    [type: string]: Array<{\n      selector: string\n      context: Node\n      listeners: Array<[Listener, { capture: boolean, passive: boolean }]>\n    }>\n  } = {}\n  const documents: Document[] = []\n\n  const eventsMethods = {\n    add,\n    remove,\n\n    addDelegate,\n    removeDelegate,\n\n    delegateListener,\n    delegateUseCapture,\n    delegatedEvents,\n    documents,\n\n    targets,\n\n    supportsOptions: false,\n    supportsPassive: false,\n  }\n\n  // check if browser supports passive events and options arg\n  scope.document?.createElement('div').addEventListener('test', null, {\n    get capture () {\n      return (eventsMethods.supportsOptions = true)\n    },\n    get passive () {\n      return (eventsMethods.supportsPassive = true)\n    },\n  })\n\n  scope.events = eventsMethods\n\n  function add (eventTarget: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\n    const options = getOptions(optionalArg)\n    let target = arr.find(targets, (t) => t.eventTarget === eventTarget)\n\n    if (!target) {\n      target = {\n        eventTarget,\n        events: {},\n      }\n\n      targets.push(target)\n    }\n\n    if (!target.events[type]) {\n      target.events[type] = []\n    }\n\n    if (eventTarget.addEventListener && !arr.contains(target.events[type], listener)) {\n      eventTarget.addEventListener(\n        type,\n        listener as any,\n        eventsMethods.supportsOptions ? options : options.capture,\n      )\n      target.events[type].push(listener)\n    }\n  }\n\n  function remove (\n    eventTarget: EventTarget,\n    type: string,\n    listener?: 'all' | Listener,\n    optionalArg?: boolean | any,\n  ) {\n    const options = getOptions(optionalArg)\n    const targetIndex = arr.findIndex(targets, (t) => t.eventTarget === eventTarget)\n    const target = targets[targetIndex]\n\n    if (!target || !target.events) {\n      return\n    }\n\n    if (type === 'all') {\n      for (type in target.events) {\n        if (target.events.hasOwnProperty(type)) {\n          remove(eventTarget, type, 'all')\n        }\n      }\n      return\n    }\n\n    let typeIsEmpty = false\n    const typeListeners = target.events[type]\n\n    if (typeListeners) {\n      if (listener === 'all') {\n        for (let i = typeListeners.length - 1; i >= 0; i--) {\n          remove(eventTarget, type, typeListeners[i], options)\n        }\n        return\n      } else {\n        for (let i = 0; i < typeListeners.length; i++) {\n          if (typeListeners[i] === listener) {\n            eventTarget.removeEventListener(\n              type,\n              listener as any,\n              eventsMethods.supportsOptions ? options : options.capture,\n            )\n            typeListeners.splice(i, 1)\n\n            if (typeListeners.length === 0) {\n              delete target.events[type]\n              typeIsEmpty = true\n            }\n\n            break\n          }\n        }\n      }\n    }\n\n    if (typeIsEmpty && !Object.keys(target.events).length) {\n      targets.splice(targetIndex, 1)\n    }\n  }\n\n  function addDelegate (selector: string, context: Node, type: string, listener: Listener, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    if (!delegatedEvents[type]) {\n      delegatedEvents[type] = []\n\n      // add delegate listener functions\n      for (const doc of documents) {\n        add(doc, type, delegateListener)\n        add(doc, type, delegateUseCapture, true)\n      }\n    }\n\n    const delegates = delegatedEvents[type]\n    let delegate = arr.find(delegates, (d) => d.selector === selector && d.context === context)\n\n    if (!delegate) {\n      delegate = { selector, context, listeners: [] }\n      delegates.push(delegate)\n    }\n\n    delegate.listeners.push([listener, options])\n  }\n\n  function removeDelegate (\n    selector: string,\n    context: Document | Element,\n    type: string,\n    listener?: Listener,\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    const delegates = delegatedEvents[type]\n    let matchFound = false\n    let index: number\n\n    if (!delegates) return\n\n    // count from last index of delegated to 0\n    for (index = delegates.length - 1; index >= 0; index--) {\n      const cur = delegates[index]\n      // look for matching selector and context Node\n      if (cur.selector === selector && cur.context === context) {\n        const { listeners } = cur\n\n        // each item of the listeners array is an array: [function, capture, passive]\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          const [fn, { capture, passive }] = listeners[i]\n\n          // check if the listener functions and capture and passive flags match\n          if (fn === listener && capture === options.capture && passive === options.passive) {\n            // remove the listener from the array of listeners\n            listeners.splice(i, 1)\n\n            // if all listeners for this target have been removed\n            // remove the target from the delegates array\n            if (!listeners.length) {\n              delegates.splice(index, 1)\n\n              // remove delegate function from context\n              remove(context, type, delegateListener)\n              remove(context, type, delegateUseCapture, true)\n            }\n\n            // only remove one listener\n            matchFound = true\n            break\n          }\n        }\n\n        if (matchFound) {\n          break\n        }\n      }\n    }\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener (event: Event | FakeEvent, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    const fakeEvent = new FakeEvent(event as Event)\n    const delegates = delegatedEvents[event.type]\n    const [eventTarget] = pointerUtils.getEventTargets(event as Event)\n    let element: Node = eventTarget\n\n    // climb up document tree looking for selector matches\n    while (is.element(element)) {\n      for (let i = 0; i < delegates.length; i++) {\n        const cur = delegates[i]\n        const { selector, context } = cur\n\n        if (\n          domUtils.matchesSelector(element, selector) &&\n          domUtils.nodeContains(context, eventTarget) &&\n          domUtils.nodeContains(context, element)\n        ) {\n          const { listeners } = cur\n\n          fakeEvent.currentTarget = element\n\n          for (const [fn, { capture, passive }] of listeners) {\n            if (capture === options.capture && passive === options.passive) {\n              fn(fakeEvent)\n            }\n          }\n        }\n      }\n\n      element = domUtils.parentNode(element)\n    }\n  }\n\n  function delegateUseCapture (this: Element, event: Event | FakeEvent) {\n    return delegateListener.call(this, event, true)\n  }\n\n  // for type inferrence\n  return eventsMethods\n}\n\nclass FakeEvent implements Partial<Event> {\n  currentTarget: Node\n  originalEvent: Event\n  type: string\n\n  constructor (originalEvent: Event) {\n    this.originalEvent = originalEvent\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation () {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation () {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nfunction getOptions (param: { [index: string]: any } | boolean): { capture: boolean, passive: boolean } {\n  if (!is.object(param)) {\n    return { capture: !!param, passive: false }\n  }\n\n  const options = extend({}, param) as any\n\n  options.capture = !!param.capture\n  options.passive = !!param.passive\n\n  return options\n}\n\nexport default {\n  id: 'events',\n  install,\n}\n","import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/core/types'\nimport * as dom from '@interactjs/utils/domUtils'\n\nexport interface SearchDetails {\n  pointer: PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: EventTarget\n  curEventTarget: EventTarget\n  scope: Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search (details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume ({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (\n        interaction.simulation &&\n        interaction.simulation.allowResume &&\n        interaction.pointerType === pointerType\n      ) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen ({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {\n          continue\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer ({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle ({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !(target.options.gesture && target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && pointerType === interaction.pointerType) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId (interaction: Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) => id === pointerId)\n}\n\nexport default finder\n","import type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, Listener } from '@interactjs/core/types'\nimport browser from '@interactjs/utils/browser'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { nodeContains } from '@interactjs/utils/domUtils'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport InteractionBase from './Interaction'\nimport interactablePreventDefault from './interactablePreventDefault'\nimport type { SearchDetails } from './interactionFinder'\nimport finder from './interactionFinder'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    Interaction: typeof InteractionBase\n    interactions: {\n      new: <T extends ActionName>(options: any) => InteractionBase<T>\n      list: Array<InteractionBase<ActionName>>\n      listeners: { [type: string]: Listener }\n      docEvents: Array<{ type: string, listener: Listener }>\n      pointerMoveTolerance: number\n    }\n    prevTouchTime: number\n  }\n\n  interface SignalArgs {\n    'interactions:find': {\n      interaction: InteractionBase\n      searchDetails: SearchDetails\n    }\n  }\n}\n\nconst methodNames = [\n  'pointerDown',\n  'pointerMove',\n  'pointerUp',\n  'updatePointer',\n  'removePointer',\n  'windowBlur',\n]\n\nfunction install (scope: Scope) {\n  const listeners = {} as any\n\n  for (const method of methodNames) {\n    listeners[method] = doOnInteractions(method, scope)\n  }\n\n  const pEventTypes = browser.pEventTypes\n  let docEvents: typeof scope.interactions.docEvents\n\n  if (domObjects.PointerEvent) {\n    docEvents = [\n      { type: pEventTypes.down, listener: releasePointersOnRemovedEls },\n      { type: pEventTypes.down, listener: listeners.pointerDown },\n      { type: pEventTypes.move, listener: listeners.pointerMove },\n      { type: pEventTypes.up, listener: listeners.pointerUp },\n      { type: pEventTypes.cancel, listener: listeners.pointerUp },\n    ]\n  } else {\n    docEvents = [\n      { type: 'mousedown', listener: listeners.pointerDown },\n      { type: 'mousemove', listener: listeners.pointerMove },\n      { type: 'mouseup', listener: listeners.pointerUp },\n\n      { type: 'touchstart', listener: releasePointersOnRemovedEls },\n      { type: 'touchstart', listener: listeners.pointerDown },\n      { type: 'touchmove', listener: listeners.pointerMove },\n      { type: 'touchend', listener: listeners.pointerUp },\n      { type: 'touchcancel', listener: listeners.pointerUp },\n    ]\n  }\n\n  docEvents.push({\n    type: 'blur',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        interaction.documentBlur(event)\n      }\n    },\n  })\n\n  // for ignoring browser's simulated mouse events\n  scope.prevTouchTime = 0\n\n  scope.Interaction = class <T extends ActionName> extends InteractionBase<T> {\n    get pointerMoveTolerance () {\n      return scope.interactions.pointerMoveTolerance\n    }\n\n    set pointerMoveTolerance (value) {\n      scope.interactions.pointerMoveTolerance = value\n    }\n\n    _now () {\n      return scope.now()\n    }\n  }\n\n  scope.interactions = {\n    // all active and idle interactions\n    list: [],\n    new<T extends ActionName> (options: { pointerType?: string, scopeFire?: Scope['fire'] }) {\n      options.scopeFire = (name, arg) => scope.fire(name, arg)\n\n      const interaction = new scope.Interaction<T>(options as Required<typeof options>)\n\n      scope.interactions.list.push(interaction)\n      return interaction\n    },\n    listeners,\n    docEvents,\n    pointerMoveTolerance: 1,\n  }\n\n  function releasePointersOnRemovedEls () {\n    // for all inactive touch interactions with pointers down\n    for (const interaction of scope.interactions.list) {\n      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {\n        continue\n      }\n\n      // if a pointer is down on an element that is no longer in the DOM tree\n      for (const pointer of interaction.pointers) {\n        if (!scope.documents.some(({ doc }) => nodeContains(doc, pointer.downTarget))) {\n          // remove the pointer from the interaction\n          interaction.removePointer(pointer.pointer, pointer.event)\n        }\n      }\n    }\n  }\n\n  scope.usePlugin(interactablePreventDefault)\n}\n\nfunction doOnInteractions (method: string, scope: Scope) {\n  return function (event: Event) {\n    const interactions = scope.interactions.list\n\n    const pointerType = pointerUtils.getPointerType(event)\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\n    const matches: any[] = [] // [ [pointer, interaction], ...]\n\n    if (/^touch/.test(event.type)) {\n      scope.prevTouchTime = scope.now()\n\n      // @ts-expect-error\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch\n        const pointerId = pointerUtils.getPointerId(pointer)\n        const searchDetails: SearchDetails = {\n          pointer,\n          pointerId,\n          pointerType,\n          eventType: event.type,\n          eventTarget,\n          curEventTarget,\n          scope,\n        }\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    } else {\n      let invalidPointer = false\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < interactions.length && !invalidPointer; i++) {\n          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer =\n          invalidPointer ||\n          scope.now() - scope.prevTouchTime < 500 ||\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          event.timeStamp === 0\n      }\n\n      if (!invalidPointer) {\n        const searchDetails = {\n          pointer: event as PointerEvent,\n          pointerId: pointerUtils.getPointerId(event as PointerEvent),\n          pointerType,\n          eventType: event.type,\n          curEventTarget,\n          eventTarget,\n          scope,\n        }\n\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n\n    // eslint-disable-next-line no-shadow\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\n      interaction[method](pointer, event, eventTarget, curEventTarget)\n    }\n  }\n}\n\nfunction getInteraction (searchDetails: SearchDetails) {\n  const { pointerType, scope } = searchDetails\n\n  const foundInteraction = finder.search(searchDetails)\n  const signalArg = { interaction: foundInteraction, searchDetails }\n\n  scope.fire('interactions:find', signalArg)\n\n  return signalArg.interaction || scope.interactions.new({ pointerType })\n}\n\nfunction onDocSignal<T extends 'scope:add-document' | 'scope:remove-document'> (\n  { doc, scope, options }: SignalArgs[T],\n  eventMethodName: 'add' | 'remove',\n) {\n  const {\n    interactions: { docEvents },\n    events,\n  } = scope\n  const eventMethod = events[eventMethodName]\n\n  if (scope.browser.isIOS && !options.events) {\n    options.events = { passive: false }\n  }\n\n  // delegate event listener\n  for (const eventType in events.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener)\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\n  }\n\n  const eventOptions = options && options.events\n\n  for (const { type, listener } of docEvents) {\n    eventMethod(doc, type, listener, eventOptions)\n  }\n}\n\nconst interactions: Plugin = {\n  id: 'core/interactions',\n  install,\n  listeners: {\n    'scope:add-document': (arg) => onDocSignal(arg, 'add'),\n    'scope:remove-document': (arg) => onDocSignal(arg, 'remove'),\n    'interactable:unset': ({ interactable }, scope) => {\n      // Stop and destroy related interactions when an Interactable is unset\n      for (let i = scope.interactions.list.length - 1; i >= 0; i--) {\n        const interaction = scope.interactions.list[i]\n\n        if (interaction.interactable !== interactable) {\n          continue\n        }\n\n        interaction.stop()\n        scope.fire('interactions:destroy', { interaction })\n        interaction.destroy()\n\n        if (scope.interactions.list.length > 2) {\n          scope.interactions.list.splice(i, 1)\n        }\n      }\n    },\n  },\n  onDocSignal,\n  doOnInteractions,\n  methodNames,\n}\n\nexport default interactions\n","import type Interaction from '@interactjs/core/Interaction'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport domObjects from '@interactjs/utils/domObjects'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport * as win from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport { InteractEvent } from './InteractEvent'\nimport { createInteractStatic } from './InteractStatic'\nimport { Interactable as InteractableBase } from './Interactable'\nimport { InteractableSet } from './InteractableSet'\nimport events from './events'\nimport interactions from './interactions'\nimport type { OptionsArg } from './options'\nimport { defaults } from './options'\nimport type { Actions } from './types'\n\nexport interface SignalArgs {\n  'scope:add-document': DocSignalArg\n  'scope:remove-document': DocSignalArg\n  'interactable:unset': { interactable: InteractableBase }\n  'interactable:set': { interactable: InteractableBase, options: OptionsArg }\n  'interactions:destroy': { interaction: Interaction }\n}\n\nexport type ListenerName = keyof SignalArgs\n\nexport type ListenerMap = {\n  [P in ListenerName]?: (arg: SignalArgs[P], scope: Scope, signalName: P) => void | boolean\n}\n\ninterface DocSignalArg {\n  doc: Document\n  window: Window\n  scope: Scope\n  options: Record<string, any>\n}\n\nexport interface Plugin {\n  [key: string]: any\n  id?: string\n  listeners?: ListenerMap\n  before?: string[]\n  install?(scope: Scope, options?: any): void\n}\n\nexport class Scope {\n  id = `__interact_scope_${Math.floor(Math.random() * 100)}`\n  isInitialized = false\n  listenerMaps: Array<{\n    map: ListenerMap\n    id: string\n  }> = []\n\n  browser = browser\n  defaults = clone(defaults) as typeof defaults\n  Eventable = Eventable\n  actions: Actions = {\n    map: {},\n    phases: {\n      start: true,\n      move: true,\n      end: true,\n    },\n    methodDict: {} as any,\n    phaselessTypes: {},\n  }\n\n  interactStatic = createInteractStatic(this)\n  InteractEvent = InteractEvent\n  Interactable: typeof InteractableBase\n  interactables = new InteractableSet(this)\n\n  // main window\n  _win!: Window\n\n  // main document\n  document!: Document\n\n  // main window\n  window!: Window\n\n  // all documents being listened to\n  documents: Array<{ doc: Document, options: any }> = []\n\n  _plugins: {\n    list: Plugin[]\n    map: { [id: string]: Plugin }\n  } = {\n      list: [],\n      map: {},\n    }\n\n  constructor () {\n    const scope = this\n\n    this.Interactable = class extends InteractableBase {\n      get _defaults () {\n        return scope.defaults\n      }\n\n      set<T extends InteractableBase> (this: T, options: OptionsArg) {\n        super.set(options)\n\n        scope.fire('interactable:set', {\n          options,\n          interactable: this,\n        })\n\n        return this\n      }\n\n      unset (this: InteractableBase) {\n        super.unset()\n\n        const index = scope.interactables.list.indexOf(this)\n        if (index < 0) return\n\n        super.unset()\n        scope.interactables.list.splice(index, 1)\n        scope.fire('interactable:unset', { interactable: this })\n      }\n    }\n  }\n\n  addListeners (map: ListenerMap, id?: string) {\n    this.listenerMaps.push({ id, map })\n  }\n\n  fire<T extends ListenerName> (name: T, arg: SignalArgs[T]): void | false {\n    for (const {\n      map: { [name]: listener },\n    } of this.listenerMaps) {\n      if (!!listener && listener(arg as any, this, name as never) === false) {\n        return false\n      }\n    }\n  }\n\n  onWindowUnload = (event: BeforeUnloadEvent) => this.removeDocument(event.target as Document)\n\n  init (window: Window | typeof globalThis) {\n    return this.isInitialized ? this : initScope(this, window)\n  }\n\n  pluginIsInstalled (plugin: Plugin) {\n    return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1\n  }\n\n  usePlugin (plugin: Plugin, options?: { [key: string]: any }) {\n    if (!this.isInitialized) {\n      return this\n    }\n\n    if (this.pluginIsInstalled(plugin)) {\n      return this\n    }\n\n    if (plugin.id) {\n      this._plugins.map[plugin.id] = plugin\n    }\n    this._plugins.list.push(plugin)\n\n    if (plugin.install) {\n      plugin.install(this, options)\n    }\n\n    if (plugin.listeners && plugin.before) {\n      let index = 0\n      const len = this.listenerMaps.length\n      const before = plugin.before.reduce((acc, id) => {\n        acc[id] = true\n        acc[pluginIdRoot(id)] = true\n        return acc\n      }, {})\n\n      for (; index < len; index++) {\n        const otherId = this.listenerMaps[index].id\n\n        if (before[otherId] || before[pluginIdRoot(otherId)]) {\n          break\n        }\n      }\n\n      this.listenerMaps.splice(index, 0, { id: plugin.id, map: plugin.listeners })\n    } else if (plugin.listeners) {\n      this.listenerMaps.push({ id: plugin.id, map: plugin.listeners })\n    }\n\n    return this\n  }\n\n  addDocument (doc: Document, options?: any): void | false {\n    // do nothing if document is already known\n    if (this.getDocIndex(doc) !== -1) {\n      return false\n    }\n\n    const window = win.getWindow(doc)\n\n    options = options ? extend({}, options) : {}\n\n    this.documents.push({ doc, options })\n    this.events.documents.push(doc)\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== this.document) {\n      this.events.add(window, 'unload', this.onWindowUnload)\n    }\n\n    this.fire('scope:add-document', { doc, window, scope: this, options })\n  }\n\n  removeDocument (doc: Document) {\n    const index = this.getDocIndex(doc)\n\n    const window = win.getWindow(doc)\n    const options = this.documents[index].options\n\n    this.events.remove(window, 'unload', this.onWindowUnload)\n\n    this.documents.splice(index, 1)\n    this.events.documents.splice(index, 1)\n\n    this.fire('scope:remove-document', { doc, window, scope: this, options })\n  }\n\n  getDocIndex (doc: Document) {\n    for (let i = 0; i < this.documents.length; i++) {\n      if (this.documents[i].doc === doc) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getDocOptions (doc: Document) {\n    const docIndex = this.getDocIndex(doc)\n\n    return docIndex === -1 ? null : this.documents[docIndex].options\n  }\n\n  now () {\n    return (((this.window as any).Date as typeof Date) || Date).now()\n  }\n}\n\nexport function initScope (scope: Scope, window: Window | typeof globalThis) {\n  scope.isInitialized = true\n\n  if (is.window(window)) {\n    win.init(window)\n  }\n\n  domObjects.init(window)\n  browser.init(window)\n  raf.init(window)\n\n  // @ts-expect-error\n  scope.window = window\n  scope.document = window.document\n\n  scope.usePlugin(interactions)\n  scope.usePlugin(events)\n\n  return scope\n}\n\nfunction pluginIdRoot (id: string) {\n  return id && id.replace(/\\/.*$/, '')\n}\n","import { Scope } from '@interactjs/core/scope'\n\nconst scope = new Scope()\n\nconst interact = scope.interactStatic\n\nexport default interact\n\nconst _global = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : this\nscope.init(_global)\n","export default () => {}\n","export default () => {}\n","import type { Rect, Point } from '@interactjs/core/types'\nimport type { SnapFunction, SnapTarget } from '@interactjs/modifiers/snap/pointer'\n\nexport type GridOptions = (Partial<Rect> | Point) & {\n  range?: number\n  limits?: Rect\n  offset?: Point\n}\n\nexport default (grid: GridOptions) => {\n  const coordFields = (\n    [\n      ['x', 'y'],\n      ['left', 'top'],\n      ['right', 'bottom'],\n      ['width', 'height'],\n    ] as const\n  ).filter(([xField, yField]) => xField in grid || yField in grid)\n\n  const gridFunc: SnapFunction & {\n    grid: typeof grid\n    coordFields: typeof coordFields\n  } = (x, y) => {\n    const {\n      range,\n      limits = {\n        left: -Infinity,\n        right: Infinity,\n        top: -Infinity,\n        bottom: Infinity,\n      },\n      offset = { x: 0, y: 0 },\n    } = grid\n\n    const result: SnapTarget & {\n      grid: typeof grid\n    } = { range, grid, x: null as number, y: null as number }\n\n    for (const [xField, yField] of coordFields) {\n      const gridx = Math.round((x - offset.x) / (grid as any)[xField])\n      const gridy = Math.round((y - offset.y) / (grid as any)[yField])\n\n      result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * (grid as any)[xField] + offset.x))\n      result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * (grid as any)[yField] + offset.y))\n    }\n\n    return result\n  }\n\n  gridFunc.grid = grid\n  gridFunc.coordFields = coordFields\n\n  return gridFunc\n}\n","import type { Plugin } from '@interactjs/core/scope'\nimport extend from '@interactjs/utils/extend'\n\nimport * as allSnappers from './all'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    snappers: typeof allSnappers\n    createSnapGrid: typeof allSnappers.grid\n  }\n}\n\nconst snappersPlugin: Plugin = {\n  id: 'snappers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    interact.snappers = extend(interact.snappers || {}, allSnappers)\n    interact.createSnapGrid = interact.snappers.grid\n  },\n}\n\nexport default snappersPlugin\n","/**\n * @module modifiers/aspectRatio\n *\n * @description\n * This module forces elements to be resized with a specified dx/dy ratio.\n *\n * ```js\n * interact(target).resizable({\n *   modifiers: [\n *     interact.modifiers.snapSize({\n *       targets: [ interact.snappers.grid({ x: 20, y: 20 }) ],\n *     }),\n *     interact.aspectRatio({ ratio: 'preserve' }),\n *   ],\n * });\n * ```\n */\n\nimport type { Point, Rect, EdgeOptions } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport { addEdges } from '@interactjs/utils/rect'\n\nimport Modification from './Modification'\nimport { makeModifier } from './base'\nimport type { Modifier, ModifierModule, ModifierState } from './types'\n\nexport interface AspectRatioOptions {\n  ratio?: number | 'preserve'\n  equalDelta?: boolean\n  modifiers?: Modifier[]\n  enabled?: boolean\n}\n\nexport type AspectRatioState = ModifierState<\nAspectRatioOptions,\n{\n  startCoords: Point\n  startRect: Rect\n  linkedEdges: EdgeOptions\n  ratio: number\n  equalDelta: boolean\n  xIsPrimaryAxis: boolean\n  edgeSign: {\n    x: number\n    y: number\n  }\n  subModification: Modification\n}\n>\n\nconst aspectRatio: ModifierModule<AspectRatioOptions, AspectRatioState> = {\n  start (arg) {\n    const { state, rect, edges: originalEdges, pageCoords: coords } = arg\n    let { ratio } = state.options\n    const { equalDelta, modifiers } = state.options\n\n    if (ratio === 'preserve') {\n      ratio = rect.width / rect.height\n    }\n\n    state.startCoords = extend({}, coords)\n    state.startRect = extend({}, rect)\n    state.ratio = ratio\n    state.equalDelta = equalDelta\n\n    const linkedEdges = (state.linkedEdges = {\n      top: originalEdges.top || (originalEdges.left && !originalEdges.bottom),\n      left: originalEdges.left || (originalEdges.top && !originalEdges.right),\n      bottom: originalEdges.bottom || (originalEdges.right && !originalEdges.top),\n      right: originalEdges.right || (originalEdges.bottom && !originalEdges.left),\n    })\n\n    state.xIsPrimaryAxis = !!(originalEdges.left || originalEdges.right)\n\n    if (state.equalDelta) {\n      const sign = (linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1)\n      state.edgeSign = {\n        x: sign,\n        y: sign,\n      }\n    } else {\n      state.edgeSign = {\n        x: linkedEdges.left ? -1 : 1,\n        y: linkedEdges.top ? -1 : 1,\n      }\n    }\n\n    extend(arg.edges, linkedEdges)\n\n    if (!modifiers || !modifiers.length) return\n\n    const subModification = new Modification(arg.interaction)\n\n    subModification.copyFrom(arg.interaction.modification)\n    subModification.prepareStates(modifiers)\n\n    state.subModification = subModification\n    subModification.startAll({ ...arg })\n  },\n\n  set (arg) {\n    const { state, rect, coords } = arg\n    const initialCoords = extend({}, coords)\n    const aspectMethod = state.equalDelta ? setEqualDelta : setRatio\n\n    aspectMethod(state, state.xIsPrimaryAxis, coords, rect)\n\n    if (!state.subModification) {\n      return null\n    }\n\n    const correctedRect = extend({}, rect)\n\n    addEdges(state.linkedEdges, correctedRect, {\n      x: coords.x - initialCoords.x,\n      y: coords.y - initialCoords.y,\n    })\n\n    const result = state.subModification.setAll({\n      ...arg,\n      rect: correctedRect,\n      edges: state.linkedEdges,\n      pageCoords: coords,\n      prevCoords: coords,\n      prevRect: correctedRect,\n    })\n\n    const { delta } = result\n\n    if (result.changed) {\n      const xIsCriticalAxis = Math.abs(delta.x) > Math.abs(delta.y)\n\n      // do aspect modification again with critical edge axis as primary\n      aspectMethod(state, xIsCriticalAxis, result.coords, result.rect)\n      extend(coords, result.coords)\n    }\n\n    return result.eventProps\n  },\n\n  defaults: {\n    ratio: 'preserve',\n    equalDelta: false,\n    modifiers: [],\n    enabled: false,\n  },\n}\n\nfunction setEqualDelta ({ startCoords, edgeSign }: AspectRatioState, xIsPrimaryAxis: boolean, coords: Point) {\n  if (xIsPrimaryAxis) {\n    coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign.y\n  } else {\n    coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign.x\n  }\n}\n\nfunction setRatio (\n  { startRect, startCoords, ratio, edgeSign }: AspectRatioState,\n  xIsPrimaryAxis: boolean,\n  coords: Point,\n  rect: Rect,\n) {\n  if (xIsPrimaryAxis) {\n    const newHeight = rect.width / ratio\n\n    coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign.y\n  } else {\n    const newWidth = rect.height * ratio\n\n    coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign.x\n  }\n}\n\nexport default makeModifier(aspectRatio, 'aspectRatio')\nexport { aspectRatio }\n","import type { ModifierFunction } from './types'\n\nconst noop = (() => {}) as unknown as ModifierFunction<any, any, 'noop'>\n\nnoop._defaults = {}\n\nexport default noop\n","import type Interaction from '@interactjs/core/Interaction'\nimport type { RectResolvable, Rect, Point } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierModule, ModifierState } from '../types'\n\nexport interface RestrictOptions {\n  // where to drag over\n  restriction: RectResolvable<[number, number, Interaction]>\n  // what part of self is allowed to drag over\n  elementRect: Rect\n  offset: Rect\n  // restrict just before the end drag\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictState = ModifierState<\nRestrictOptions,\n{\n  offset: Rect\n}\n>\n\nfunction start ({ rect, startOffset, state, interaction, pageCoords }: ModifierArg<RestrictState>) {\n  const { options } = state\n  const { elementRect } = options\n  const offset: Rect = extend(\n    {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    },\n    options.offset || {},\n  )\n\n  if (rect && elementRect) {\n    const restriction = getRestrictionRect(options.restriction, interaction, pageCoords)\n\n    if (restriction) {\n      const widthDiff = restriction.right - restriction.left - rect.width\n      const heightDiff = restriction.bottom - restriction.top - rect.height\n\n      if (widthDiff < 0) {\n        offset.left += widthDiff\n        offset.right += widthDiff\n      }\n      if (heightDiff < 0) {\n        offset.top += heightDiff\n        offset.bottom += heightDiff\n      }\n    }\n\n    offset.left += startOffset.left - rect.width * elementRect.left\n    offset.top += startOffset.top - rect.height * elementRect.top\n\n    offset.right += startOffset.right - rect.width * (1 - elementRect.right)\n    offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom)\n  }\n\n  state.offset = offset\n}\n\nfunction set ({ coords, interaction, state }: ModifierArg<RestrictState>) {\n  const { options, offset } = state\n\n  const restriction = getRestrictionRect(options.restriction, interaction, coords)\n\n  if (!restriction) return\n\n  const rect = rectUtils.xywhToTlbr(restriction)\n\n  coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left)\n  coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top)\n}\n\nexport function getRestrictionRect (\n  value: RectResolvable<[number, number, Interaction]>,\n  interaction: Interaction,\n  coords?: Point,\n) {\n  if (is.func(value)) {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element, [\n      coords.x,\n      coords.y,\n      interaction,\n    ])\n  } else {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element)\n  }\n}\n\nconst defaults: RestrictOptions = {\n  restriction: null,\n  elementRect: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrict: ModifierModule<RestrictOptions, RestrictState> = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrict, 'restrict')\nexport { restrict }\n","// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n//   },\n// })\n\nimport type { Point, Rect } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierState } from '../types'\n\nimport type { RestrictOptions } from './pointer'\nimport { getRestrictionRect } from './pointer'\n\nexport interface RestrictEdgesOptions {\n  inner: RestrictOptions['restriction']\n  outer: RestrictOptions['restriction']\n  offset?: RestrictOptions['offset']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictEdgesState = ModifierState<\nRestrictEdgesOptions,\n{\n  inner: Rect\n  outer: Rect\n  offset: RestrictEdgesOptions['offset']\n}\n>\n\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity }\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity }\n\nfunction start ({ interaction, startOffset, state }: ModifierArg<RestrictEdgesState>) {\n  const { options } = state\n  let offset: Point\n\n  if (options) {\n    const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page)\n\n    offset = rectUtils.rectToXY(offsetRect)\n  }\n\n  offset = offset || { x: 0, y: 0 }\n\n  state.offset = {\n    top: offset.y + startOffset.top,\n    left: offset.x + startOffset.left,\n    bottom: offset.y - startOffset.bottom,\n    right: offset.x - startOffset.right,\n  }\n}\n\nfunction set ({ coords, edges, interaction, state }: ModifierArg<RestrictEdgesState>) {\n  const { offset, options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const page = extend({}, coords)\n  const inner = getRestrictionRect(options.inner, interaction, page) || ({} as Rect)\n  const outer = getRestrictionRect(options.outer, interaction, page) || ({} as Rect)\n\n  fixRect(inner, noInner)\n  fixRect(outer, noOuter)\n\n  if (edges.top) {\n    coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top)\n  } else if (edges.bottom) {\n    coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom)\n  }\n  if (edges.left) {\n    coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left)\n  } else if (edges.right) {\n    coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right)\n  }\n}\n\nfunction fixRect (rect: Rect, defaults: Rect) {\n  for (const edge of ['top', 'left', 'bottom', 'right']) {\n    if (!(edge in rect)) {\n      rect[edge] = defaults[edge]\n    }\n  }\n\n  return rect\n}\n\nconst defaults: RestrictEdgesOptions = {\n  inner: null,\n  outer: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictEdges = {\n  noInner,\n  noOuter,\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictEdges, 'restrictEdges')\nexport { restrictEdges }\n","import extend from '@interactjs/utils/extend'\n\nimport { makeModifier } from '../base'\n\nimport { restrict } from './pointer'\n\nconst defaults = extend(\n  {\n    get elementRect () {\n      return { top: 0, left: 0, bottom: 1, right: 1 }\n    },\n    set elementRect (_) {},\n  },\n  restrict.defaults,\n)\n\nconst restrictRect = {\n  start: restrict.start,\n  set: restrict.set,\n  defaults,\n}\n\nexport default makeModifier(restrictRect, 'restrictRect')\nexport { restrictRect }\n","import type { Point, Rect, Size } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierState } from '../types'\n\nimport type { RestrictEdgesState } from './edges'\nimport { restrictEdges } from './edges'\nimport type { RestrictOptions } from './pointer'\nimport { getRestrictionRect } from './pointer'\n\nconst noMin = { width: -Infinity, height: -Infinity }\nconst noMax = { width: +Infinity, height: +Infinity }\n\nexport interface RestrictSizeOptions {\n  min?: Size | Point | RestrictOptions['restriction']\n  max?: Size | Point | RestrictOptions['restriction']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nfunction start (arg: ModifierArg<RestrictEdgesState>) {\n  return restrictEdges.start(arg)\n}\n\nexport type RestrictSizeState = RestrictEdgesState &\nModifierState<\nRestrictSizeOptions & { inner: Rect, outer: Rect },\n{\n  min: Rect\n  max: Rect\n}\n>\n\nfunction set (arg: ModifierArg<RestrictSizeState>) {\n  const { interaction, state, rect, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const minSize =\n    rectUtils.tlbrToXywh(getRestrictionRect(options.min as any, interaction, arg.coords)) || noMin\n  const maxSize =\n    rectUtils.tlbrToXywh(getRestrictionRect(options.max as any, interaction, arg.coords)) || noMax\n\n  state.options = {\n    endOnly: options.endOnly,\n    inner: extend({}, restrictEdges.noInner),\n    outer: extend({}, restrictEdges.noOuter),\n  }\n\n  if (edges.top) {\n    state.options.inner.top = rect.bottom - minSize.height\n    state.options.outer.top = rect.bottom - maxSize.height\n  } else if (edges.bottom) {\n    state.options.inner.bottom = rect.top + minSize.height\n    state.options.outer.bottom = rect.top + maxSize.height\n  }\n  if (edges.left) {\n    state.options.inner.left = rect.right - minSize.width\n    state.options.outer.left = rect.right - maxSize.width\n  } else if (edges.right) {\n    state.options.inner.right = rect.left + minSize.width\n    state.options.outer.right = rect.left + maxSize.width\n  }\n\n  restrictEdges.set(arg)\n\n  state.options = options\n}\n\nconst defaults: RestrictSizeOptions = {\n  min: null,\n  max: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictSize, 'restrictSize')\nexport { restrictSize }\n","import type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName, Point, RectResolvable, Element } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierState } from '../types'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Point | null\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: InteractionProxy<ActionName>,\n  offset: Offset,\n  index: number,\n) => SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets: SnapTarget[] | null\n  // target range\n  range: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints: Point[] | null\n  // startCoords = offset snapping from drag start page position\n  offset: Point | RectResolvable<[Interaction]> | 'startCoords' | null\n  offsetWithOrigin?: boolean\n  origin: RectResolvable<[Element]> | Point | null\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState<\nSnapOptions,\n{\n  offsets?: Offset[]\n  closest?: any\n  targetFields?: string[][]\n}\n>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin ? getOrigin(arg) : { x: 0, y: 0 }\n\n  let snapOffset: Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  } else {\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets =\n    rect && relativePoints && relativePoints.length\n      ? relativePoints.map((relativePoint, index) => ({\n        index,\n        relativePoint,\n        x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,\n        y: startOffset.top - rect.height * relativePoint.y + snapOffset.y,\n      }))\n      : [\n        {\n          index: 0,\n          relativePoint: null,\n          x: snapOffset.x,\n          y: snapOffset.y,\n        },\n      ]\n}\n\nfunction set (arg: ModifierArg<SnapState>) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name)\n  const page = extend({}, coords)\n  const targets = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets.length; index < len; index++) {\n      const snapTarget = options.targets[index]\n      let target: SnapPosition\n\n      if (is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\n      } else {\n        target = snapTarget\n      }\n\n      if (!target) {\n        continue\n      }\n\n      targets.push({\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (\n      !closest.target ||\n      (inRange\n        ? // is the closest target in range?\n        closest.inRange && range !== Infinity\n          ? // the pointer is relatively deeper in this target\n          distance / range < closest.distance / closest.range\n          : // this target has Infinite range and the closest doesn't\n          (range === Infinity && closest.range !== Infinity) ||\n            // OR this target is closer that the previous closest\n            distance < closest.distance\n        : // The other is not in range and the pointer is closer to this target\n        !closest.inRange && distance < closest.distance)\n    ) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin (arg: Partial<ModifierArg<SnapState>>) {\n  const { element } = arg.interaction\n  const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin as any, null, null, [element]))\n  const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name)\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n","// This module allows snapping of the size of targets during resize\n// interactions.\n\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg } from '../types'\n\nimport type { SnapOptions, SnapState } from './pointer'\nimport { snap } from './pointer'\n\nexport type SnapSizeOptions = Pick<SnapOptions, 'targets' | 'offset' | 'endOnly' | 'range' | 'enabled'>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { state, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return null\n  }\n\n  arg.state = {\n    options: {\n      targets: null,\n      relativePoints: [\n        {\n          x: edges.left ? 0 : 1,\n          y: edges.top ? 0 : 1,\n        },\n      ],\n      offset: options.offset || 'self',\n      origin: { x: 0, y: 0 },\n      range: options.range,\n    },\n  }\n\n  state.targetFields = state.targetFields || [\n    ['width', 'height'],\n    ['x', 'y'],\n  ]\n\n  snap.start(arg)\n  state.offsets = arg.state.offsets\n\n  arg.state = state\n}\n\nfunction set (arg) {\n  const { interaction, state, coords } = arg\n  const { options, offsets } = state\n  const relative = {\n    x: coords.x - offsets[0].x,\n    y: coords.y - offsets[0].y,\n  }\n\n  state.options = extend({}, options)\n  state.options.targets = []\n\n  for (const snapTarget of options.targets || []) {\n    let target\n\n    if (is.func(snapTarget)) {\n      target = snapTarget(relative.x, relative.y, interaction)\n    } else {\n      target = snapTarget\n    }\n\n    if (!target) {\n      continue\n    }\n\n    for (const [xField, yField] of state.targetFields) {\n      if (xField in target || yField in target) {\n        target.x = target[xField]\n        target.y = target[yField]\n\n        break\n      }\n    }\n\n    state.options.targets.push(target)\n  }\n\n  const returnValue = snap.set(arg)\n\n  state.options = options\n\n  return returnValue\n}\n\nconst defaults: SnapSizeOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst snapSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snapSize, 'snapSize')\nexport { snapSize }\n","/**\n * @module modifiers/snapEdges\n *\n * @description\n * WOW> This module allows snapping of the edges of targets during resize\n * interactions.\n *\n * ```js\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [interact.snappers.grid({ x: 100, y: 50 })],\n *   },\n * })\n *\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [\n *       interact.snappers.grid({\n *        top: 50,\n *        left: 50,\n *        bottom: 100,\n *        right: 100,\n *       }),\n *     ],\n *   },\n * })\n * ```\n */\n\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierModule } from '../types'\n\nimport type { SnapOptions, SnapState } from './pointer'\nimport { snapSize } from './size'\n\nexport type SnapEdgesOptions = Pick<SnapOptions, 'targets' | 'range' | 'offset' | 'endOnly' | 'enabled'>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { edges } = arg\n\n  if (!edges) {\n    return null\n  }\n\n  arg.state.targetFields = arg.state.targetFields || [\n    [edges.left ? 'left' : 'right', edges.top ? 'top' : 'bottom'],\n  ]\n\n  return snapSize.start(arg)\n}\n\nconst snapEdges: ModifierModule<SnapEdgesOptions, SnapState, ReturnType<typeof snapSize.set>> = {\n  start,\n  set: snapSize.set,\n  defaults: extend(clone(snapSize.defaults), {\n    targets: null,\n    range: null,\n    offset: { x: 0, y: 0 },\n  } as const),\n}\n\nexport default makeModifier(snapEdges, 'snapEdges')\nexport { snapEdges }\n","/* eslint-disable n/no-extraneous-import, import/no-unresolved */\nimport aspectRatio from './aspectRatio'\nimport avoid from './avoid/avoid'\nimport restrictEdges from './restrict/edges'\nimport restrict from './restrict/pointer'\nimport restrictRect from './restrict/rect'\nimport restrictSize from './restrict/size'\nimport rubberband from './rubberband/rubberband'\nimport snapEdges from './snap/edges'\nimport snap from './snap/pointer'\nimport snapSize from './snap/size'\nimport spring from './spring/spring'\nimport transform from './transform/transform'\n\nexport default {\n  aspectRatio,\n  restrictEdges,\n  restrict,\n  restrictRect,\n  restrictSize,\n  snapEdges,\n  snap,\n  snapSize,\n\n  spring,\n  avoid,\n  transform,\n  rubberband,\n}\n","import type { Plugin } from '@interactjs/core/scope'\nimport snappers from '@interactjs/snappers/plugin'\n\nimport all from './all'\nimport base from './base'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    modifiers: typeof all\n  }\n}\n\nconst modifiers: Plugin = {\n  id: 'modifiers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    scope.usePlugin(base)\n    scope.usePlugin(snappers)\n\n    interact.modifiers = all\n\n    // for backwrads compatibility\n    for (const type in all) {\n      const { _defaults, _methods } = all[type as keyof typeof all]\n\n      ;(_defaults as any)._methods = _methods\n      ;(scope.defaults.perAction as any)[type] = _defaults\n    }\n  },\n}\n\nexport default modifiers\n","import { BaseEvent } from '@interactjs/core/BaseEvent'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { PointerEventType, PointerType, Point } from '@interactjs/core/types'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nexport default class PointerEvent<T extends string = any> extends BaseEvent<never> {\n  declare type: T\n  declare originalEvent: PointerEventType\n  declare pointerId: number\n  declare pointerType: string\n  declare double: boolean\n  declare pageX: number\n  declare pageY: number\n  declare clientX: number\n  declare clientY: number\n  declare dt: number\n  declare eventable: any;\n  [key: string]: any\n\n  /** */\n  constructor (\n    type: T,\n    pointer: PointerType | PointerEvent<any>,\n    event: PointerEventType,\n    eventTarget: Node,\n    interaction: Interaction<never>,\n    timeStamp: number,\n  ) {\n    super(interaction)\n    pointerUtils.pointerExtend(this, event)\n\n    if (event !== pointer) {\n      pointerUtils.pointerExtend(this, pointer)\n    }\n\n    this.timeStamp = timeStamp\n    this.originalEvent = event\n    this.type = type\n    this.pointerId = pointerUtils.getPointerId(pointer)\n    this.pointerType = pointerUtils.getPointerType(pointer)\n    this.target = eventTarget\n    this.currentTarget = null\n\n    if (type === 'tap') {\n      const pointerIndex = interaction.getPointerIndex(pointer)\n      this.dt = this.timeStamp - interaction.pointers[pointerIndex].downTime\n\n      const interval = this.timeStamp - interaction.tapTime\n\n      this.double =\n        !!interaction.prevTap &&\n        interaction.prevTap.type !== 'doubletap' &&\n        interaction.prevTap.target === this.target &&\n        interval < 500\n    } else if (type === 'doubletap') {\n      this.dt = (pointer as PointerEvent<'tap'>).timeStamp - interaction.tapTime\n      this.double = true\n    }\n  }\n\n  _subtractOrigin ({ x: originX, y: originY }: Point) {\n    this.pageX -= originX\n    this.pageY -= originY\n    this.clientX -= originX\n    this.clientY -= originY\n\n    return this\n  }\n\n  _addOrigin ({ x: originX, y: originY }: Point) {\n    this.pageX += originX\n    this.pageY += originY\n    this.clientX += originX\n    this.clientY += originY\n\n    return this\n  }\n\n  /**\n   * Prevent the default behaviour of the original Event\n   */\n  preventDefault () {\n    this.originalEvent.preventDefault()\n  }\n}\n\nexport { PointerEvent }\n","import type { Eventable } from '@interactjs/core/Eventable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { Point, PointerType, PointerEventType, Element } from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\n\nimport { PointerEvent } from './PointerEvent'\n\nexport type EventTargetList = Array<{\n  node: Node\n  eventable: Eventable\n  props: { [key: string]: any }\n}>\n\nexport interface PointerEventOptions extends PerActionDefaults {\n  enabled?: undefined // not used\n  holdDuration?: number\n  ignoreFrom?: any\n  allowFrom?: any\n  origin?: Point | string | Element\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    pointerEvents: typeof pointerEvents\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    prevTap?: PointerEvent<string>\n    tapTime?: number\n  }\n}\n\ndeclare module '@interactjs/core/PointerInfo' {\n  interface PointerInfo {\n    hold?: {\n      duration: number\n      timeout: any\n    }\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    pointerEvents: Options\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'pointerEvents:new': { pointerEvent: PointerEvent<any> }\n    'pointerEvents:fired': {\n      interaction: Interaction<null>\n      pointer: PointerType | PointerEvent<any>\n      event: PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      pointerEvent: PointerEvent<any>\n      targets?: EventTargetList\n      type: string\n    }\n    'pointerEvents:collect-targets': {\n      interaction: Interaction<any>\n      pointer: PointerType | PointerEvent<any>\n      event: PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      targets?: EventTargetList\n      type: string\n      path: Node[]\n      node: null\n    }\n  }\n}\n\nconst defaults: PointerEventOptions = {\n  holdDuration: 600,\n  ignoreFrom: null,\n  allowFrom: null,\n  origin: { x: 0, y: 0 },\n}\n\nconst pointerEvents: Plugin = {\n  id: 'pointer-events/base',\n  before: ['inertia', 'modifiers', 'auto-start', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': addInteractionProps,\n    'interactions:update-pointer': addHoldInfo,\n    'interactions:move': moveAndClearHold,\n    'interactions:down': (arg, scope) => {\n      downAndStartHold(arg, scope)\n      fire(arg, scope)\n    },\n    'interactions:up': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n      tapAfterUp(arg, scope)\n    },\n    'interactions:cancel': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n    },\n  },\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  defaults,\n  types: {\n    down: true,\n    move: true,\n    up: true,\n    cancel: true,\n    tap: true,\n    doubletap: true,\n    hold: true,\n  } as { [type: string]: true },\n}\n\nfunction fire<T extends string> (\n  arg: {\n    pointer: PointerType | PointerEvent<any>\n    event: PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    interaction: Interaction<never>\n    type: T\n    targets?: EventTargetList\n  },\n  scope: Scope,\n) {\n  const { interaction, pointer, event, eventTarget, type, targets = collectEventTargets(arg, scope) } = arg\n\n  const pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction, scope.now())\n\n  scope.fire('pointerEvents:new', { pointerEvent })\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  }\n\n  for (let i = 0; i < targets.length; i++) {\n    const target = targets[i]\n\n    for (const prop in target.props || {}) {\n      ;(pointerEvent as any)[prop] = target.props[prop]\n    }\n\n    const origin = getOriginXY(target.eventable, target.node)\n\n    pointerEvent._subtractOrigin(origin)\n    pointerEvent.eventable = target.eventable\n    pointerEvent.currentTarget = target.node\n\n    target.eventable.fire(pointerEvent)\n\n    pointerEvent._addOrigin(origin)\n\n    if (\n      pointerEvent.immediatePropagationStopped ||\n      (pointerEvent.propagationStopped &&\n        i + 1 < targets.length &&\n        targets[i + 1].node !== pointerEvent.currentTarget)\n    ) {\n      break\n    }\n  }\n\n  scope.fire('pointerEvents:fired', signalArg)\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire(\n        {\n          interaction,\n          pointer,\n          event,\n          eventTarget,\n          type: 'doubletap',\n        },\n        scope,\n      )\n      : pointerEvent\n\n    interaction.prevTap = prevTap\n    interaction.tapTime = prevTap.timeStamp\n  }\n\n  return pointerEvent\n}\n\nfunction collectEventTargets<T extends string> (\n  {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n  }: {\n    interaction: Interaction<any>\n    pointer: PointerType | PointerEvent<any>\n    event: PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    type: T\n  },\n  scope: Scope,\n) {\n  const pointerIndex = interaction.getPointerIndex(pointer)\n  const pointerInfo = interaction.pointers[pointerIndex]\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (\n    type === 'tap' &&\n    (interaction.pointerWasMoved ||\n      // or if the pointerup target is different to the pointerdown target\n      !(pointerInfo && pointerInfo.downTarget === eventTarget))\n  ) {\n    return []\n  }\n\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [] as EventTargetList,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter(\n      (target) => target.eventable.options.holdDuration === interaction.pointers[pointerIndex]?.hold.duration,\n    )\n  }\n\n  return signalArg.targets\n}\n\nfunction addInteractionProps ({ interaction }) {\n  interaction.prevTap = null // the most recent tap event on this interaction\n  interaction.tapTime = 0 // time of the most recent tap event\n}\n\nfunction addHoldInfo ({ down, pointerInfo }: SignalArgs['interactions:update-pointer']) {\n  if (!down && pointerInfo.hold) {\n    return\n  }\n\n  pointerInfo.hold = { duration: Infinity, timeout: null }\n}\n\nfunction clearHold ({ interaction, pointerIndex }) {\n  const hold = interaction.pointers[pointerIndex].hold\n\n  if (hold && hold.timeout) {\n    clearTimeout(hold.timeout)\n    hold.timeout = null\n  }\n}\n\nfunction moveAndClearHold (arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction, pointer, event, eventTarget, duplicate } = arg\n\n  if (!duplicate && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearHold(arg)\n    }\n\n    fire(\n      {\n        interaction,\n        pointer,\n        event,\n        eventTarget: eventTarget as Element,\n        type: 'move',\n      },\n      scope,\n    )\n  }\n}\n\nfunction downAndStartHold (\n  { interaction, pointer, event, eventTarget, pointerIndex }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  const timer = interaction.pointers[pointerIndex].hold\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type: 'hold',\n    targets: [] as EventTargetList,\n    path,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (!signalArg.targets.length) return\n\n  let minDuration = Infinity\n\n  for (const target of signalArg.targets) {\n    const holdDuration = target.eventable.options.holdDuration\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration\n    }\n  }\n\n  timer.duration = minDuration\n  timer.timeout = setTimeout(() => {\n    fire(\n      {\n        interaction,\n        eventTarget,\n        pointer,\n        event,\n        type: 'hold',\n      },\n      scope,\n    )\n  }, minDuration)\n}\n\nfunction tapAfterUp (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:up'],\n  scope: Scope,\n) {\n  if (!interaction.pointerWasMoved) {\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' }, scope)\n  }\n}\n\nfunction install (scope: Scope) {\n  scope.pointerEvents = pointerEvents\n  scope.defaults.actions.pointerEvents = pointerEvents.defaults\n  extend(scope.actions.phaselessTypes, pointerEvents.types)\n}\n\nexport default pointerEvents\n","import type Interaction from '@interactjs/core/Interaction'\nimport type { ListenerMap, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\n\nimport type PointerEvent from './PointerEvent'\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    holdIntervalHandle?: any\n  }\n}\n\ndeclare module '@interactjs/pointer-events/PointerEvent' {\n  interface PointerEvent<T extends string = any> {\n    count?: number\n  }\n}\n\ndeclare module '@interactjs/pointer-events/base' {\n  interface PointerEventOptions {\n    holdRepeatInterval?: number\n  }\n}\n\nfunction install (scope: Scope) {\n  scope.usePlugin(basePlugin)\n\n  const { pointerEvents } = scope\n\n  // don't repeat by default\n  pointerEvents.defaults.holdRepeatInterval = 0\n  pointerEvents.types.holdrepeat = scope.actions.phaselessTypes.holdrepeat = true\n}\n\nfunction onNew ({ pointerEvent }: { pointerEvent: PointerEvent<any> }) {\n  if (pointerEvent.type !== 'hold') return\n\n  pointerEvent.count = (pointerEvent.count || 0) + 1\n}\n\nfunction onFired (\n  { interaction, pointerEvent, eventTarget, targets }: SignalArgs['pointerEvents:fired'],\n  scope: Scope,\n) {\n  if (pointerEvent.type !== 'hold' || !targets.length) return\n\n  // get the repeat interval from the first eventable\n  const interval = targets[0].eventable.options.holdRepeatInterval\n\n  // don't repeat if the interval is 0 or less\n  if (interval <= 0) return\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(() => {\n    scope.pointerEvents.fire(\n      {\n        interaction,\n        eventTarget,\n        type: 'hold',\n        pointer: pointerEvent,\n        event: pointerEvent,\n      },\n      scope,\n    )\n  }, interval)\n}\n\nfunction endHoldRepeat ({ interaction }: { interaction: Interaction }) {\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle)\n    interaction.holdIntervalHandle = null\n  }\n}\n\nconst holdRepeat: Plugin = {\n  id: 'pointer-events/holdRepeat',\n  install,\n  listeners: ['move', 'up', 'cancel', 'endall'].reduce(\n    (acc, enderTypes) => {\n      ;(acc as any)[`pointerEvents:${enderTypes}`] = endHoldRepeat\n      return acc\n    },\n    {\n      'pointerEvents:new': onNew,\n      'pointerEvents:fired': onFired,\n    } as ListenerMap,\n  ),\n}\n\nexport default holdRepeat\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    pointerEvents: typeof pointerEventsMethod\n    __backCompatOption: (optionName: string, newValue: any) => any\n  }\n}\n\nfunction install (scope: Scope) {\n  const { Interactable } = scope\n\n  Interactable.prototype.pointerEvents = pointerEventsMethod\n\n  const __backCompatOption = Interactable.prototype._backCompatOption\n\n  Interactable.prototype._backCompatOption = function (optionName, newValue) {\n    const ret = __backCompatOption.call(this, optionName, newValue)\n\n    if (ret === this) {\n      this.events.options[optionName] = newValue\n    }\n\n    return ret\n  }\n}\n\nfunction pointerEventsMethod (this: Interactable, options: any) {\n  extend(this.events.options, options)\n\n  return this\n}\n\nconst plugin: Plugin = {\n  id: 'pointer-events/interactableTargets',\n  install,\n  listeners: {\n    'pointerEvents:collect-targets': ({ targets, node, type, eventTarget }, scope) => {\n      scope.interactables.forEachMatch(node, (interactable: Interactable) => {\n        const eventable = interactable.events\n        const options = eventable.options\n\n        if (\n          eventable.types[type] &&\n          eventable.types[type].length &&\n          interactable.testIgnoreAllow(options, node, eventTarget)\n        ) {\n          targets.push({\n            node,\n            eventable,\n            props: { interactable },\n          })\n        }\n      })\n    },\n\n    'interactable:new': ({ interactable }) => {\n      interactable.events.getRect = function (element: Element) {\n        return interactable.getRect(element)\n      }\n    },\n\n    'interactable:set': ({ interactable, options }, scope) => {\n      extend(interactable.events.options, scope.pointerEvents.defaults)\n      extend(interactable.events.options, options.pointerEvents || {})\n    },\n  },\n}\n\nexport default plugin\n","import type { Plugin } from '@interactjs/core/scope'\n\nimport * as pointerEvents from './base'\nimport holdRepeat from './holdRepeat'\nimport interactableTargets from './interactableTargets'\n\nconst plugin: Plugin = {\n  id: 'pointer-events',\n  install (scope) {\n    scope.usePlugin(pointerEvents)\n    scope.usePlugin(holdRepeat)\n    scope.usePlugin(interactableTargets)\n  },\n}\n\nexport default plugin\n","import type { Interactable } from '@interactjs/core/Interactable'\nimport type { DoAnyPhaseArg, Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, ActionProps, Element } from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport { tlbrToXywh } from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-reflow': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-reflow': DoAnyPhaseArg\n    'interactions:after-action-reflow': DoAnyPhaseArg\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    reflow: <T extends ActionName>(action: ActionProps<T>) => ReturnType<typeof doReflow>\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    _reflowPromise: Promise<void>\n    _reflowResolve: (...args: unknown[]) => void\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    reflow?: true\n  }\n}\n\nexport function install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable,\n  } = scope\n\n  scope.actions.phases.reflow = true\n\n  /**\n   * ```js\n   * const interactable = interact(target)\n   * const drag = { name: drag, axis: 'x' }\n   * const resize = { name: resize, edges: { left: true, bottom: true }\n   *\n   * interactable.reflow(drag)\n   * interactable.reflow(resize)\n   * ```\n   *\n   * Start an action sequence to re-apply modifiers, check drops, etc.\n   *\n   * @param { Object } action The action to begin\n   * @param { string } action.name The name of the action\n   * @returns { Promise } A promise that resolves to the `Interactable` when actions on all targets have ended\n   */\n  Interactable.prototype.reflow = function (action: ActionProps) {\n    return doReflow(this, action, scope)\n  }\n}\n\nfunction doReflow<T extends ActionName> (\n  interactable: Interactable,\n  action: ActionProps<T>,\n  scope: Scope,\n): Promise<Interactable> {\n  const elements = (\n    is.string(interactable.target)\n      ? arr.from(interactable._context.querySelectorAll(interactable.target))\n      : [interactable.target]\n  ) as Element[]\n\n  // tslint:disable-next-line variable-name\n  const Promise = (scope.window as any).Promise\n  const promises: Array<Promise<null>> | null = Promise ? [] : null\n\n  for (const element of elements) {\n    const rect = interactable.getRect(element as HTMLElement | SVGElement)\n\n    if (!rect) {\n      break\n    }\n\n    const runningInteraction = arr.find(scope.interactions.list, (interaction: Interaction) => {\n      return (\n        interaction.interacting() &&\n        interaction.interactable === interactable &&\n        interaction.element === element &&\n        interaction.prepared.name === action.name\n      )\n    })\n    let reflowPromise: Promise<null>\n\n    if (runningInteraction) {\n      runningInteraction.move()\n\n      if (promises) {\n        reflowPromise =\n          runningInteraction._reflowPromise ||\n          new Promise((resolve: any) => {\n            runningInteraction._reflowResolve = resolve\n          })\n      }\n    } else {\n      const xywh = tlbrToXywh(rect)\n      const coords = {\n        page: { x: xywh.x, y: xywh.y },\n        client: { x: xywh.x, y: xywh.y },\n        timeStamp: scope.now(),\n      }\n\n      const event = pointerUtils.coordsToEvent(coords)\n      reflowPromise = startReflow<T>(scope, interactable, element, action, event)\n    }\n\n    if (promises) {\n      promises.push(reflowPromise)\n    }\n  }\n\n  return promises && Promise.all(promises).then(() => interactable)\n}\n\nfunction startReflow<T extends ActionName> (\n  scope: Scope,\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  event: any,\n) {\n  const interaction = scope.interactions.new({ pointerType: 'reflow' })\n  const signalArg = {\n    interaction,\n    event,\n    pointer: event,\n    eventTarget: element,\n    phase: 'reflow',\n  } as const\n\n  interaction.interactable = interactable\n  interaction.element = element\n  interaction.prevEvent = event\n  interaction.updatePointer(event, event, element, true)\n  pointerUtils.setZeroCoords(interaction.coords.delta)\n\n  copyAction(interaction.prepared, action)\n  interaction._doPhase(signalArg)\n\n  const { Promise } = scope.window as unknown as { Promise: PromiseConstructor }\n  const reflowPromise = Promise\n    ? new Promise<undefined>((resolve) => {\n      interaction._reflowResolve = resolve\n    })\n    : undefined\n\n  interaction._reflowPromise = reflowPromise\n  interaction.start(action, interactable, element)\n\n  if (interaction._interacting) {\n    interaction.move(signalArg)\n    interaction.end(event)\n  } else {\n    interaction.stop()\n    interaction._reflowResolve()\n  }\n\n  interaction.removePointer(event, event)\n\n  return reflowPromise\n}\n\nconst reflow: Plugin = {\n  id: 'reflow',\n  install,\n  listeners: {\n    // remove completed reflow interactions\n    'interactions:stop': ({ interaction }, scope) => {\n      if (interaction.pointerType === 'reflow') {\n        if (interaction._reflowResolve) {\n          interaction._reflowResolve()\n        }\n\n        arr.remove(scope.interactions.list, interaction)\n      }\n    },\n  },\n}\n\nexport default reflow\n","import actions from '@interactjs/actions/plugin'\nimport autoScroll from '@interactjs/auto-scroll/plugin'\nimport autoStart from '@interactjs/auto-start/plugin'\nimport interactablePreventDefault from '@interactjs/core/interactablePreventDefault'\nimport devTools from '@interactjs/dev-tools/plugin'\nimport inertia from '@interactjs/inertia/plugin'\nimport interact from '@interactjs/interact'\nimport modifiers from '@interactjs/modifiers/plugin'\nimport offset from '@interactjs/offset/plugin'\nimport pointerEvents from '@interactjs/pointer-events/plugin'\nimport reflow from '@interactjs/reflow/plugin'\n\ninteract.use(interactablePreventDefault)\n\ninteract.use(offset)\n\n// pointerEvents\ninteract.use(pointerEvents)\n\n// inertia\ninteract.use(inertia)\n\n// snap, resize, etc.\ninteract.use(modifiers)\n\n// autoStart, hold\ninteract.use(autoStart)\n\n// drag and drop, resize, gesture\ninteract.use(actions)\n\n// autoScroll\ninteract.use(autoScroll)\n\n// reflow\ninteract.use(reflow)\n\n// eslint-disable-next-line no-undef\nif (process.env.NODE_ENV !== 'production') {\n  interact.use(devTools)\n}\n\nexport default interact\n\nif (typeof module === 'object' && !!module) {\n  try {\n    module.exports = interact\n  } catch {}\n}\n\n;(interact as any).default = interact\n\nconst _ = {\n  actions,\n  autoScroll,\n  autoStart,\n  interactablePreventDefault,\n  devTools,\n  inertia,\n  interact,\n  modifiers,\n  offset,\n  pointerEvents,\n  reflow,\n}\n\n// Exported so that the related module augmentations will be referenced in\n// generated .d.ts file\nexport type __internal_plugin_types__ = typeof _\n","// eslint-disable-next-line import/no-extraneous-dependencies\nimport interact from '@interactjs/interactjs'\n\nexport default interact\n\nif (typeof module === 'object' && !!module) {\n  try {\n    module.exports = interact\n  } catch {}\n}\n\n;(interact as any).default = interact\n","\nreturn _$index_79;\n\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}